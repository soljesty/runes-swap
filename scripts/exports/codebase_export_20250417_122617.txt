-e PROJECT DIRECTORY STRUCTURE:

.
â”œâ”€â”€ .env.example
â”œâ”€â”€ .env.local
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .npmrc
â”œâ”€â”€ .roo
â”‚Â Â  â””â”€â”€ rules
â”‚Â Â      â””â”€â”€ rules.md
â”œâ”€â”€ README.md
â”œâ”€â”€ eslint.config.mjs
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.ts
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ pnpm-workspace.yaml
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ Bitcoin.svg
â”‚Â Â  â”œâ”€â”€ charting_library
â”‚Â Â  â”œâ”€â”€ file.svg
â”‚Â Â  â”œâ”€â”€ fonts
â”‚Â Â  â”‚Â Â  â””â”€â”€ WindowsRegular.ttf
â”‚Â Â  â”œâ”€â”€ globe.svg
â”‚Â Â  â”œâ”€â”€ icons
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ check-0.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ collapse.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ expand.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ github-mark.svg
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ magnifying_glass-0.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ msg_error-0.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ msg_warning-0.png
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ windows_hourglass.png
â”‚Â Â  â”‚Â Â  â””â”€â”€ x-logo.svg
â”‚Â Â  â”œâ”€â”€ next.svg
â”‚Â Â  â”œâ”€â”€ vercel.svg
â”‚Â Â  â””â”€â”€ window.svg
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ export-codebase.sh
â”‚Â Â  â””â”€â”€ exports
â”‚Â Â      â””â”€â”€ codebase_export_20250417_122617.txt
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ cached-popular-runes
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ordiscan
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ btc-balance
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ list-runes
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ rune-activity
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ rune-balances
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ rune-info
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ rune-market
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ portfolio-data
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ rune-price-history
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ sats-terminal
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ popular
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ psbt
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ confirm
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ create
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â      â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ quote
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ search
â”‚Â Â  â”‚Â Â  â”‚Â Â          â””â”€â”€ route.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ docs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ favicon.ico
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ globals.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layout.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ page.module.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ page.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ providers.tsx
â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AssetSelector.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ConnectWalletButton.module.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ConnectWalletButton.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FooterComponent.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FormattedRuneAmount.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Layout.module.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Layout.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PortfolioTab.module.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PortfolioTab.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ PriceChart.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RunesInfoTab.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SwapInterface.module.css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SwapInterface.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SwapTab.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ YourTxsTab.tsx
â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â””â”€â”€ LaserEyesContext.tsx
â”‚Â Â  â”œâ”€â”€ lib
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apiClient.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apiUtils.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ popularRunesCache.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ runeMarketData.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ runesData.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ serverUtils.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ supabase.ts
â”‚Â Â  â”œâ”€â”€ store
â”‚Â Â  â”‚Â Â  â””â”€â”€ runesInfoStore.ts
â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ common.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ordiscan.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ satsTerminal.ts
â”‚Â Â  â””â”€â”€ utils
â”‚Â Â      â”œâ”€â”€ formatters.ts
â”‚Â Â      â””â”€â”€ transactionHelpers.ts
â””â”€â”€ tsconfig.json
-e 

-e 


-e 

==============================================================

-e FILE: src/app/api/cached-popular-runes/route.ts

-e ==============================================================

import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';
import { getCachedPopularRunes, cachePopularRunes } from '@/lib/popularRunesCache';
import { getSatsTerminalClient } from '@/lib/serverUtils';

export async function GET() {
  try {
    // First try to get from cache
    const cachedData = await getCachedPopularRunes();
    if (cachedData) {
      console.log('[cached-popular-runes API] Returning cached data');
      return createSuccessResponse(cachedData);
    }

    // If not in cache, fetch from SatsTerminal and store in cache
    console.log('[cached-popular-runes API] Fetching fresh data from SatsTerminal');
    const terminal = getSatsTerminalClient();
    const popularResponse = await terminal.popularCollections({});
    
    // Validate response structure
    if (!popularResponse || typeof popularResponse !== 'object') {
      return createErrorResponse('Invalid response from SatsTerminal', 'Popular collections data is malformed', 500);
    }

    // Cache the fresh data
    if (Array.isArray(popularResponse)) {
      await cachePopularRunes(popularResponse);
    }
    
    return createSuccessResponse(popularResponse);
  } catch (error) {
    const errorInfo = handleApiError(error, 'Failed to fetch cached popular collections');
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/btc-balance/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { getOrdiscanClient } from '@/lib/serverUtils';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return createErrorResponse('Address parameter is required', undefined, 400);
  }

  try {
    const ordiscan = getOrdiscanClient();
    // Use the original logic from src/lib/ordiscan.ts
    const utxos = await ordiscan.address.getUtxos({ address });

    if (!Array.isArray(utxos)) {
       console.warn(`[API Route] Invalid or empty UTXO data received for address ${address}. Expected array, got:`, utxos);
       // Return 0 balance if data is invalid
       return createSuccessResponse({ balance: 0 }); 
    }

    const totalBalance = utxos.reduce((sum, utxo) => sum + (utxo.value || 0), 0);
    return createSuccessResponse({ balance: totalBalance });

  } catch (error) {
    const errorInfo = handleApiError(error, `Failed to fetch BTC balance for ${address}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/list-runes/route.ts

-e ==============================================================

import { getOrdiscanClient } from '@/lib/serverUtils';
import { RuneInfo } from '@/types/ordiscan';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

export async function GET() {
  try {
    const ordiscan = getOrdiscanClient();
    const runes: RuneInfo[] = await ordiscan.rune.list({ sort: 'newest' });
    
    // Ensure we always return a valid array
    const validRunes = Array.isArray(runes) ? runes : [];
    
    return createSuccessResponse(validRunes);
  } catch (error) {
    const errorInfo = handleApiError(error, 'Failed to fetch runes list');
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/rune-activity/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { getOrdiscanClient } from '@/lib/serverUtils'; // <-- Import client utility
// Import the necessary types from the shared location
import { RuneActivityEvent } from '@/types/ordiscan';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

// Define local types matching the ones in the lib (or import from shared location)
// Commented out to avoid linter errors - might use later
// interface RunestoneMessage {
//   rune: string;
//   type: 'ETCH' | 'MINT' | 'TRANSFER';
// }

// Commented out to avoid linter errors - might use later
// interface RunicInput {
//   address: string;
//   rune: string | null;
//   rune_amount: string;
// }

// Commented out to avoid linter errors - might use later
// interface RunicOutput {
//   address: string;
//   rune: string | null;
//   rune_amount: string;
// }

// Commented out to avoid linter errors
// const ORDISCAN_API_BASE = 'https://api.ordiscan.com';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const address = searchParams.get('address');

  if (!address) {
    return createErrorResponse('Address parameter is required', undefined, 400);
  }

  // const apiKey = process.env.ORDISCAN_API_KEY;
  // if (!apiKey) {
  //   console.error("[API /rune-activity] Ordiscan API key is not set");
  //   return NextResponse.json({ error: "Server configuration error: API key missing" }, { status: 500 });
  // }

  // const apiUrl = `https://api.ordiscan.com/v1/address/${address}/activity/runes`;

  try {
    const ordiscan = getOrdiscanClient(); // <-- Use utility function

    // Use the method suggested by the linter
    const activity: RuneActivityEvent[] = await ordiscan.address.getRunesActivity({ address }); // <-- Corrected method name

    // Ensure we always return a valid array
    const validActivity = Array.isArray(activity) ? activity : [];
    
    return createSuccessResponse(validActivity);

    // Remove old fetch logic:
    // const apiResponse = await fetch(apiUrl, {
    //   headers: {
    //     'Authorization': `Bearer ${apiKey}`,
    //   },
    // });
    // ... removed response handling and parsing ...

  } catch (error) {
    const errorInfo = handleApiError(error, `Failed to fetch rune activity for address ${address}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/rune-balances/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { getOrdiscanClient } from '@/lib/serverUtils';
import { RuneBalance } from '@/types/ordiscan';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return createErrorResponse('Address parameter is required', undefined, 400);
  }

  try {
    const ordiscan = getOrdiscanClient();
    const balances: RuneBalance[] = await ordiscan.address.getRunes({ address });
    
    // Ensure we always return a valid array
    const validBalances: RuneBalance[] = Array.isArray(balances) ? balances : [];
    
    return createSuccessResponse(validBalances);
  } catch (error) {
    const errorInfo = handleApiError(error, `Failed to fetch Rune balances for ${address}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/rune-info/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';
import { getRuneData } from '@/lib/runesData';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const name = searchParams.get('name');

  if (!name || name.trim() === '') {
    return createErrorResponse('Rune name parameter is required', undefined, 400);
  }

  // Ensure name doesn't have spacers for the API call
  const formattedName = name.replace(/â€¢/g, '');

  try {
    const runeInfo = await getRuneData(formattedName);
    
    if (!runeInfo) {
      console.warn(`[API Route] Rune info not found for ${formattedName}`);
      // Return null data with success: true for consistent client-side handling
      return createSuccessResponse(null, 404);
    }
    
    return createSuccessResponse(runeInfo);
  } catch (error: unknown) {
    const errorInfo = handleApiError(error, `Failed to fetch info for rune ${formattedName}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/ordiscan/rune-market/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';
import { getRuneMarketData } from '@/lib/runeMarketData';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const name = searchParams.get('name');

  if (!name || name.trim() === '') {
    return createErrorResponse('Rune name parameter is required', undefined, 400);
  }

  // Ensure name doesn't have spacers for the API call
  const formattedName = name.replace(/â€¢/g, '');

  try {
    const marketInfo = await getRuneMarketData(formattedName);
    
    if (!marketInfo) {
      console.warn(`[API Route] Rune market info not found for ${formattedName}`);
      // Return null data with success: true for consistent client-side handling
      return createSuccessResponse(null, 404);
    }
    
    return createSuccessResponse(marketInfo);
  } catch (error: unknown) {
    const errorInfo = handleApiError(error, `Failed to fetch market info for rune ${formattedName}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/portfolio-data/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { getOrdiscanClient } from '@/lib/serverUtils';
import { supabase } from '@/lib/supabase';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';
import { RuneBalance, RuneMarketInfo } from '@/types/ordiscan';
import { RuneData } from '@/lib/runesData';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return createErrorResponse('Address parameter is required', undefined, 400);
  }

  try {
    // Fetch balances from Ordiscan (always fresh)
    const ordiscan = getOrdiscanClient();
    const balancesPromise = ordiscan.address.getRunes({ address });

    // Wait for balances first since we need the rune names for subsequent queries
    const balances: RuneBalance[] = await balancesPromise;
    const validBalances: RuneBalance[] = Array.isArray(balances) ? balances : [];
    
    if (validBalances.length === 0) {
      return createSuccessResponse({ balances: [], runeInfos: {}, marketData: {} });
    }
    
    // Extract all rune names
    const runeNames = validBalances.map(balance => balance.name);
    
    // Fetch rune info and market data in parallel from Supabase
    const [runeInfoResult, marketDataResult] = await Promise.all([
      // Batch fetch rune info from Supabase
      supabase
        .from('runes')
        .select('*')
        .in('name', runeNames),
      
      // Batch fetch market data from Supabase
      supabase
        .from('rune_market_data')
        .select('*')
        .in('rune_name', runeNames)
        .gt('last_updated_at', new Date(Date.now() - 10 * 60 * 1000).toISOString())
    ]);
    
    const runeInfos = runeInfoResult.data;
    const runeInfoError = runeInfoResult.error;
    const marketData = marketDataResult.data;
    const marketError = marketDataResult.error;
    
    if (runeInfoError) {
      console.error('Error fetching rune infos:', runeInfoError);
    }
    
    if (marketError) {
      console.error('Error fetching market data:', marketError);
    }
    
    // Convert array data to maps for easy client-side lookup
    const runeInfoMap: Record<string, RuneData> = {};
    const marketDataMap: Record<string, RuneMarketInfo> = {};
    
    (runeInfos || []).forEach(info => {
      runeInfoMap[info.name] = info as RuneData;
    });
    
    (marketData || []).forEach(market => {
      marketDataMap[market.rune_name] = {
        price_in_sats: market.price_in_sats,
        price_in_usd: market.price_in_usd,
        market_cap_in_btc: market.market_cap_in_btc,
        market_cap_in_usd: market.market_cap_in_usd
      };
    });
    
    // Prepare arrays for missing data
    const missingRuneNames = runeNames.filter(name => !runeInfoMap[name]);
    const missingMarketDataNames = runeNames.filter(name => !marketDataMap[name]);
    
    // Create promise arrays for missing data
    const missingRuneInfoPromises = missingRuneNames.map(runeName => 
      fetch(`${process.env.NEXT_PUBLIC_ORDISCAN_API_URL}/v1/rune/${runeName}`, {
        headers: { 'Authorization': `Bearer ${process.env.ORDISCAN_API_KEY || ''}` }
      })
      .then(res => res.json())
      .then(data => {
        if (data?.data) {
          // Store in Supabase for future use
          const runeData = {
            ...data.data,
            last_updated_at: new Date().toISOString()
          };
          
          runeInfoMap[runeName] = runeData as RuneData;
          
          // Don't await this, just fire and forget
          supabase.from('runes').insert([runeData]);
        }
        return data?.data;
      })
      .catch(err => {
        console.error(`Error fetching rune info for ${runeName}:`, err);
        return null;
      })
    );
    
    const missingMarketDataPromises = missingMarketDataNames.map(runeName =>
      fetch(`${process.env.NEXT_PUBLIC_ORDISCAN_API_URL}/v1/rune/${runeName}/market`, {
        headers: { 'Authorization': `Bearer ${process.env.ORDISCAN_API_KEY || ''}` }
      })
      .then(res => res.json())
      .then(data => {
        if (data?.data) {
          // Store in Supabase for future use
          const marketInfo = {
            rune_name: runeName,
            price_in_sats: data.data.price_in_sats,
            price_in_usd: data.data.price_in_usd,
            market_cap_in_btc: data.data.market_cap_in_btc,
            market_cap_in_usd: data.data.market_cap_in_usd,
            last_updated_at: new Date().toISOString()
          };
          
          marketDataMap[runeName] = {
            price_in_sats: data.data.price_in_sats,
            price_in_usd: data.data.price_in_usd,
            market_cap_in_btc: data.data.market_cap_in_btc,
            market_cap_in_usd: data.data.market_cap_in_usd
          };
          
          // Don't await this, just fire and forget
          supabase.from('rune_market_data').upsert(marketInfo);
        }
        return data?.data;
      })
      .catch(err => {
        console.error(`Error fetching market data for ${runeName}:`, err);
        return null;
      })
    );
    
    // Wait for all missing data to be fetched in parallel
    if (missingRuneInfoPromises.length > 0 || missingMarketDataPromises.length > 0) {
      await Promise.all([
        Promise.all(missingRuneInfoPromises),
        Promise.all(missingMarketDataPromises)
      ]);
    }
    
    // Return the combined data
    return createSuccessResponse({
      balances: validBalances,
      runeInfos: runeInfoMap,
      marketData: marketDataMap
    });
  } catch (error) {
    const errorInfo = handleApiError(error, `Failed to fetch portfolio data for ${address}`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/rune-price-history/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { createSuccessResponse, createErrorResponse } from '@/lib/apiUtils';
import { z } from 'zod';

// Define the schema for the query parameters
const QuerySchema = z.object({
  slug: z.string().min(1).max(100)
});

// Define the response type for price history
export interface PriceHistoryDataPoint {
  timestamp: number; // Unix timestamp in milliseconds
  price: number;     // Price in USD
}

export interface PriceHistoryResponse {
  slug: string;
  prices: PriceHistoryDataPoint[];
  available: boolean;
}

// Define interfaces for the API response
interface PriceDataPoint {
  date: string;
  floor_value: number;
}

export async function GET(request: NextRequest) {
  try {
    // Extract and validate the query parameters
    const { searchParams } = new URL(request.url);
    const slug = searchParams.get('slug');
    
    const validation = QuerySchema.safeParse({ slug });
    
    if (!validation.success) {
      return createErrorResponse('Invalid query parameters', validation.error.message, 400);
    }

    // Format the rune name for the API call
    // Try with different formats to ensure we get data
    const originalSlug = slug!;
    const formattedSlug = originalSlug.replace(/[â€¢.]/g, '').toUpperCase();
    
    // Define a mapping for known runes that might have formatting issues
    const knownRunes: Record<string, string> = {
      'LIQUIDIUMâ€¢TOKEN': 'LIQUIDIUMTOKEN',
      'LIQUIDIUMTOKEN': 'LIQUIDIUMTOKEN',
      'LIQUIDIUM': 'LIQUIDIUMTOKEN'
    };
    
    // Check if we have a direct mapping first
    let apiSlug = knownRunes[originalSlug] || formattedSlug;
    
    // If not a direct match, try partial matching for known runes
    if (!knownRunes[originalSlug]) {
      // Check if it includes any known rune names
      if (originalSlug.toUpperCase().includes('LIQUIDIUM')) {
        apiSlug = 'LIQUIDIUMTOKEN';
      }
    }
    
    // External API endpoint
    const apiUrl = `https://runes-floor-api.shudu.workers.dev/api/query?slug=${encodeURIComponent(apiSlug)}`;
    
    // Check if API key is set
    const apiKey = process.env.RUNES_FLOOR_API_KEY;
    if (!apiKey) {
      console.error('[API] RUNES_FLOOR_API_KEY is not set in environment variables');
      return createErrorResponse('API key not configured', 'Missing RUNES_FLOOR_API_KEY environment variable', 500);
    }
    
    // Fetch data from the external API
    const response = await fetch(apiUrl, {
      headers: {
        'X-API-Key': apiKey
      },
      next: { 
        revalidate: 300 // Cache for 5 minutes
      }
    });

    if (!response.ok) {
      if (response.status === 404) {
        // Return a successful response with available: false
        return createSuccessResponse({
          slug: formattedSlug,
          prices: [],
          available: false
        });
      }
      
      return createErrorResponse(
        `Failed to fetch price history (${response.status})`, 
        `Status: ${response.status}`, 
        500
      );
    }
    
    // Parse the response body
    const data = await response.json();
    
    // Check if we have any price data
    if (!data || !Array.isArray(data)) {
      return createSuccessResponse({
        slug: formattedSlug,
        prices: [],
        available: false
      });
    }

    // Transform the data into our desired format
    // The API returns an array of price points directly
    const prices: PriceHistoryDataPoint[] = data.map((item: PriceDataPoint) => ({
      timestamp: new Date(item.date).getTime(), // Convert date string to timestamp
      price: item.floor_value || 0 // Get price from floor_value
    }));

    // Make sure the available flag is set correctly
    const available = prices.length > 0;

    // Return the transformed data
    return createSuccessResponse({
      slug: formattedSlug,
      prices,
      available
    });
  } catch (error: unknown) {
    console.error('[API Route] Error fetching price history:', error);
    
    return createErrorResponse(
      error instanceof Error ? error.message : 'Unknown error occurred',
      error instanceof Error ? error.stack || 'No stack trace available' : 'Unknown error details',
      500
    );
  }
}-e 

==============================================================

-e FILE: src/app/api/sats-terminal/popular/route.ts

-e ==============================================================

import { getSatsTerminalClient } from '@/lib/serverUtils';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';
import { getCachedPopularRunes, cachePopularRunes } from '@/lib/popularRunesCache';

export async function GET() {
  try {
    // Check cache first
    const cachedData = await getCachedPopularRunes();
    if (cachedData) {
      console.log('[popular API] Using cached popular runes data');
      return createSuccessResponse(cachedData);
    }

    // If not in cache, fetch from SatsTerminal
    console.log('[popular API] Cache miss, fetching from SatsTerminal');
    const terminal = getSatsTerminalClient();
    const popularResponse = await terminal.popularCollections({});
    
    // Validate response structure
    if (!popularResponse || typeof popularResponse !== 'object') {
      return createErrorResponse('Invalid response from SatsTerminal', 'Popular collections data is malformed', 500);
    }
    
    // Cache the fresh data for future use
    if (Array.isArray(popularResponse)) {
      await cachePopularRunes(popularResponse);
    }
    
    return createSuccessResponse(popularResponse);
  } catch (error) {
    const errorInfo = handleApiError(error, 'Failed to fetch popular collections');
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/sats-terminal/psbt/confirm/route.ts

-e ==============================================================

import { NextRequest, NextResponse } from 'next/server';
import type { ConfirmPSBTParams, RuneOrder } from 'satsterminal-sdk';
import { getSatsTerminalClient } from '@/lib/serverUtils';
import { z } from 'zod';

// Create a more comprehensive RuneOrder schema based on observed usage
const runeOrderSchema = z.object({
  id: z.string().min(1, "Order ID is required"),
  market: z.string().min(1, "Market is required"),
  price: z.number().optional(),
  quantity: z.number().optional(),
  maker: z.string().optional(),
  side: z.enum(["BUY", "SELL"]).optional(),
  txid: z.string().optional(),
  vout: z.number().optional(),
  runeName: z.string().optional(),
  runeAmount: z.number().optional(),
  btcAmount: z.number().optional(),
  satPrice: z.number().optional(),
  status: z.string().optional(),
  timestamp: z.number().optional(),
}).passthrough(); // Use passthrough to allow additional fields expected by the SDK

const confirmPsbtParamsSchema = z.object({
  orders: z.array(runeOrderSchema),
  address: z.string().min(1, "Bitcoin address is required"),
  publicKey: z.string().min(1, "Public key is required"),
  paymentAddress: z.string().min(1, "Payment address is required"),
  paymentPublicKey: z.string().min(1, "Payment public key is required"),
  signedPsbtBase64: z.string().min(1, "Signed PSBT is required"),
  swapId: z.string().min(1, "Swap ID is required"),
  runeName: z.string().min(1, "Rune name is required"),
  sell: z.boolean().optional(),
  rbfProtection: z.boolean().optional(),
  signedRbfPsbtBase64: z.string().optional(), // Make optional initially
}).refine(data => {
    // If rbfProtection is true, signedRbfPsbtBase64 must be a non-empty string
    if (data.rbfProtection === true) {
      return typeof data.signedRbfPsbtBase64 === 'string' && data.signedRbfPsbtBase64.length > 0;
    }
    return true; // Otherwise, validation passes regarding this rule
  }, {
    message: "signedRbfPsbtBase64 is required when rbfProtection is true",
    path: ["signedRbfPsbtBase64"], // Specify the path of the error
  });

export async function POST(request: NextRequest) {
  let params;
  try {
    params = await request.json();
  } catch {
    return NextResponse.json({ error: 'Invalid JSON body', details: 'The request body could not be parsed as JSON' }, { status: 400 });
  }

  const validationResult = confirmPsbtParamsSchema.safeParse(params);

  if (!validationResult.success) {
    console.error("Confirm PSBT API Validation Error:", validationResult.error.flatten()); // Log detailed error server-side
    return NextResponse.json({
        error: 'Invalid request body for PSBT confirmation.',
        details: validationResult.error.flatten().fieldErrors
    }, { status: 400 });
  }

  // Use the validated and typed data from now on
  const validatedParams = validationResult.data;

  try {
    const terminal = getSatsTerminalClient();
    // No need for type casting since validatedParams is already properly typed
    const confirmParams: ConfirmPSBTParams = {
      ...validatedParams,
      // Need to cast orders to RuneOrder[] since Zod validation may not fully match SDK type
      orders: validatedParams.orders as unknown as RuneOrder[],
      // Ensure optional signedRbfPsbtBase64 is undefined if not provided, matching SDK type
      signedRbfPsbtBase64: validatedParams.signedRbfPsbtBase64 || undefined,
    };

    const confirmResponse = await terminal.confirmPSBT(confirmParams);
    return NextResponse.json(confirmResponse);

  } catch (error) {
    console.error(`Error confirming PSBT on server:`, error);
    const message = (error instanceof Error) ? error.message : 'Failed to confirm PSBT';
    // Check for specific API errors if needed, e.g., quote expired
    let statusCode = 500;
    if (message.includes("Quote expired") || (error && typeof error === 'object' && (error as { code?: string }).code === 'ERR677K3')) {
      statusCode = 410; // Gone (or another suitable code like 400 Bad Request)
    }
    return NextResponse.json({ 
      error: 'Failed to confirm PSBT', 
      details: message,
      code: (error && typeof error === 'object' && (error as { code?: string }).code) || 'UNKNOWN_ERROR'
    }, { status: statusCode });
  }
} -e 

==============================================================

-e FILE: src/app/api/sats-terminal/psbt/create/route.ts

-e ==============================================================

import { NextRequest, NextResponse } from 'next/server';
import type { GetPSBTParams, RuneOrder } from 'satsterminal-sdk';
import { getSatsTerminalClient } from '@/lib/serverUtils';
import { z } from 'zod';

// Create a comprehensive RuneOrder schema based on the SDK requirements
const runeOrderSchema = z.object({
  id: z.string().min(1, "Order ID is required"),
  market: z.string().min(1, "Market is required"),
  price: z.number().optional(),
  quantity: z.number().optional(),
  maker: z.string().optional(),
  side: z.enum(["BUY", "SELL"]).optional(),
  txid: z.string().optional(),
  vout: z.number().optional(),
  runeName: z.string().optional(),
  runeAmount: z.number().optional(),
  btcAmount: z.number().optional(),
  satPrice: z.number().optional(),
  status: z.string().optional(),
  timestamp: z.number().optional(),
}).passthrough(); // Use passthrough to allow additional fields expected by the SDK

const getPsbtParamsSchema = z.object({
  orders: z.array(runeOrderSchema),
  address: z.string().min(1, "Bitcoin address is required"),
  publicKey: z.string().min(1, "Public key is required"),
  paymentAddress: z.string().min(1, "Payment address is required"),
  paymentPublicKey: z.string().min(1, "Payment public key is required"),
  runeName: z.string().min(1, "Rune name is required"),
  sell: z.boolean().optional(),
  rbfProtection: z.boolean().optional(),
  feeRate: z.number().optional(),
  slippage: z.number().optional(),
});

export async function POST(request: NextRequest) {
  let params;
  try {
    params = await request.json();
  } catch {
    return NextResponse.json({ 
      error: 'Invalid JSON body', 
      details: 'The request body could not be parsed as JSON' 
    }, { status: 400 });
  }

  const validationResult = getPsbtParamsSchema.safeParse(params);

  if (!validationResult.success) {
    console.error("PSBT API Validation Error:", validationResult.error.flatten()); // Log detailed error server-side
    return NextResponse.json({
        error: 'Invalid request body for PSBT creation.',
        details: validationResult.error.flatten().fieldErrors
    }, { status: 400 });
  }

  // Use the validated and typed data from now on
  const validatedParams = validationResult.data;

  try {
    const terminal = getSatsTerminalClient();
    // Need to cast orders to RuneOrder[] since Zod validation may not fully match SDK type
    const psbtParams: GetPSBTParams = {
      ...validatedParams,
      orders: validatedParams.orders as unknown as RuneOrder[],
    };

    const psbtResponse = await terminal.getPSBT(psbtParams);
    return NextResponse.json(psbtResponse);

  } catch (error) {
    console.error(`Error getting PSBT on server:`, error);
    const message = (error instanceof Error) ? error.message : 'Failed to generate PSBT';
    
    // Check for specific API errors 
    let statusCode = 500;
    if (message.includes("Quote expired") || (error && typeof error === 'object' && (error as { code?: string }).code === 'ERR677K3')) {
      statusCode = 410; // Gone (or another suitable code for expired quotes)
    }
    
    return NextResponse.json({ 
      error: 'Failed to generate PSBT', 
      details: message,
      code: (error && typeof error === 'object' && (error as { code?: string }).code) || 'UNKNOWN_ERROR'
    }, { status: statusCode });
  }
} -e 

==============================================================

-e FILE: src/app/api/sats-terminal/quote/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import type { QuoteParams } from 'satsterminal-sdk';
import { getSatsTerminalClient } from '@/lib/serverUtils';
import { z } from 'zod';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

const quoteParamsSchema = z.object({
  btcAmount: z.union([z.string().min(1), z.number().positive()]).transform(val => String(val)), // Require non-empty string or positive number, always transform to string
  runeName: z.string().min(1),
  address: z.string().min(1),
  sell: z.boolean().optional(),
  // Add other optional fields from QuoteParams if needed, e.g.:
  // marketplaces: z.array(z.string()).optional(),
  // rbfProtection: z.boolean().optional(),
});

export async function POST(request: NextRequest) {
  let params;
  try {
    params = await request.json();
  } catch {
    return createErrorResponse('Invalid JSON body', 'Request body could not be parsed as JSON', 400);
  }

  const validationResult = quoteParamsSchema.safeParse(params);

  if (!validationResult.success) {
    const fieldErrors = validationResult.error.flatten().fieldErrors;
    return createErrorResponse(
      'Invalid request body for quote',
      JSON.stringify(fieldErrors),
      400
    );
  }

  // Use the validated and typed data from now on
  const validatedParams = validationResult.data;

  try {
    const terminal = getSatsTerminalClient();
    // Ensure btcAmount is a string for the SDK
    const quoteParams: QuoteParams = {
      ...validatedParams,
      btcAmount: validatedParams.btcAmount,
    };

    const quoteResponse = await terminal.fetchQuote(quoteParams);
    
    // Validate the response
    if (!quoteResponse || typeof quoteResponse !== 'object') {
      return createErrorResponse('Invalid quote response', 'Quote data is malformed', 500);
    }
    
    return createSuccessResponse(quoteResponse);
  } catch (error) {
    const errorInfo = handleApiError(error, 'Failed to fetch quote');
    
    // Special handling for liquidity errors (maintain 404 status)
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.toLowerCase().includes('liquidity')) {
      return createErrorResponse('No liquidity available', errorMessage, 404);
    }
    
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/api/sats-terminal/search/route.ts

-e ==============================================================

import { NextRequest } from 'next/server';
import { getSatsTerminalClient } from '@/lib/serverUtils';
import type { Rune } from '@/types/satsTerminal';
import { createSuccessResponse, createErrorResponse, handleApiError } from '@/lib/apiUtils';

// Define types for rune responses locally or import if shared
// interface Rune {
//   id: string;
//   name: string;
//   imageURI?: string;
//   formattedAmount?: string;
//   formattedUnitPrice?: string;
//   price?: number;
// }

// Simple internal type for expected order structure from search
interface SearchOrder {
  id?: string;
  rune?: string;
  etching?: { runeName?: string };
  icon_content_url_data?: string;
  imageURI?: string;
  formattedAmount?: string;
  formattedUnitPrice?: string;
  price?: number;
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query');

  if (!query || query.trim() === '') {
    return createErrorResponse('Search query is required', undefined, 400);
  }

  try {
    const terminal = getSatsTerminalClient();
    const searchResults = await terminal.search({
      rune_name: query,
      sell: false // Or get from query params if needed
    });

    // Map the response with improved type checking
    const orders: SearchOrder[] = Array.isArray(searchResults) ? searchResults :
                  (searchResults && typeof searchResults === 'object' && 'orders' in searchResults && Array.isArray(searchResults.orders)) ?
                  (searchResults.orders as SearchOrder[]) :
                  [];

    // Generate a stable ID using a hash of properties instead of random
    const generateStableId = (order: SearchOrder, index: number): string => {
      const base = order.id || order.rune || order.etching?.runeName;
      if (base) return base;
      // Fallback to a stable ID based on properties and index
      return `unknown_rune_${index}_${order.formattedAmount || ''}_${order.price || 0}`;
    };

    const runes: Rune[] = orders.map((order: SearchOrder, index: number) => ({
      id: generateStableId(order, index),
      name: order.etching?.runeName || order.rune || 'Unknown Rune',
      imageURI: order.icon_content_url_data || order.imageURI,
      formattedAmount: order.formattedAmount,
      formattedUnitPrice: order.formattedUnitPrice,
      price: order.price
    }));

    return createSuccessResponse(runes);
  } catch (error) {
    const errorInfo = handleApiError(error, `Failed to search for runes with query "${query}"`);
    return createErrorResponse(errorInfo.message, errorInfo.details, errorInfo.status);
  }
} -e 

==============================================================

-e FILE: src/app/docs/page.tsx

-e ==============================================================

'use client';

import React from 'react';
import Head from 'next/head';
import Link from 'next/link';
import styles from '../page.module.css';

export default function DocsPage() {
  return (
    <div className={styles.container}>
      <Head>
        <title>RunesSwap.app - Bitcoin Runes Swapping Platform Documentation</title>
        <meta name="description" content="Learn how to use RunesSwap.app - the premier Bitcoin Runes swap platform. Swap, buy, and sell Bitcoin Runes with our decentralized exchange (DEX)." />
        <meta name="keywords" content="bitcoin, runes, bitcoin runes, ordinals, inscriptions, swap, dex, swapping, swaps, sell, buy, decentralized exchange, bitcoin swap" />
      </Head>
      
      <h1 className={styles.title}>RunesSwap.app Documentation</h1>
      
      <div className={styles.docsContent}>
        <section>
          <h2>What is RunesSwap.app?</h2>
          <p>
            RunesSwap.app is a Bitcoin Runes swap platform built with Next.js, TypeScript, and SatsTerminal SDK. 
            Our platform provides a Uniswap-like experience for the Bitcoin ecosystem, featuring a minimalist 
            Windows 98 UI theme that offers an intuitive yet nostalgic user experience.
          </p>
        </section>
        
        <section>
          <h2>Key Features</h2>
          <ul>
            <li><strong>Seamless Bitcoin Runes Swapping</strong> - Trade your Bitcoin Runes easily</li>
            <li><strong>Wallet Integration</strong> - Connect securely with Laser Eyes wallet technology</li>
            <li><strong>Balance & UTXO Tracking</strong> - View your holdings via Ordiscan integration</li>
            <li><strong>Mobile-Friendly Design</strong> - Trade on any device with our responsive interface</li>
            <li><strong>Lightweight Performance</strong> - Enjoy fast loading times and minimal resource usage</li>
            <li><strong>Retro Windows 98 UI</strong> - Experience the nostalgic minimalist interface</li>
          </ul>
        </section>
        
        <section>
          <h2>How to Use RunesSwap.app</h2>
          
          <h3>1. Connect Your Wallet</h3>
          <p>
            Click the &ldquo;Connect Wallet&rdquo; button and select your preferred Bitcoin wallet. 
            RunesSwap.app uses Laser Eyes technology for secure wallet connections.
          </p>
          
          <h3>2. Select Tokens to Swap</h3>
          <p>
            Choose which Bitcoin Runes you want to swap from the dropdown menus.
            Select your input and output tokens and specify the amount you wish to trade.
          </p>
          
          <h3>3. Review and Confirm</h3>
          <p>
            Check the swap details, including exchange rate, fees, and estimated output.
            Once satisfied, click &ldquo;Swap&rdquo; to confirm the transaction.
          </p>
          
          <h3>4. Complete the Transaction</h3>
          <p>
            Approve the transaction in your wallet. The swap will be executed on the Bitcoin 
            blockchain using inscriptions technology.
          </p>
          
          <h3>5. View Transaction History</h3>
          <p>
            Track all your swaps in the &ldquo;Your Txs&rdquo; tab to see pending and completed transactions.
          </p>
        </section>
        
        <section>
          <h2>Technical Information</h2>
          <p>
            RunesSwap.app is built using a modern tech stack:
          </p>
          <ul>
            <li><strong>Framework:</strong> Next.js</li>
            <li><strong>Language:</strong> TypeScript</li>
            <li><strong>Styling:</strong> Regular CSS</li>
            <li><strong>Swap Logic:</strong> SatsTerminal SDK</li>
            <li><strong>Wallet Connection:</strong> Laser Eyes</li>
            <li><strong>Data Fetching:</strong> React Query (TanStack Query)</li>
            <li><strong>State Management:</strong> Zustand</li>
            <li><strong>Balance/UTXO Info:</strong> Ordiscan</li>
          </ul>
        </section>
        
        <section>
          <h2>FAQ</h2>
          
          <h3>What are Bitcoin Runes?</h3>
          <p>
            Bitcoin Runes is a token protocol built on Bitcoin that enables the creation and transfer
            of fungible tokens directly on the Bitcoin blockchain. Runes offer improved
            efficiency and capabilities for token operations on Bitcoin.
          </p>
          
          <h3>How are Runes different from Ordinals?</h3>
          <p>
            While Ordinals use inscriptions to store data, Runes use a more
            efficient method that reduces blockchain bloat while maintaining the security and
            decentralization of Bitcoin.
          </p>
          
          <h3>Are swaps instant?</h3>
          <p>
            Swaps are subject to Bitcoin blockchain confirmation times, which typically range
            from 10 minutes to an hour depending on network congestion and transaction fees.
          </p>
          
          <h3>What fees are involved?</h3>
          <p>
            RunesSwap.app doesn&apos;t charge any extra fees on top of the standard SatsTerminal fees. 
            This means we almost always provide the best exchange rates for Bitcoin Runes swaps. 
            Users only pay the standard Bitcoin network fee required for processing the transaction 
            on the blockchain.
          </p>
        </section>
        
        <section>
          <h2>Contact & Support</h2>
          <p>
            For support or inquiries, please reach out through our GitHub repository or follow
            us on Twitter/X for the latest updates.
          </p>
          <div className={styles.contactLinks}>
            <a 
              href="https://github.com/ropl-btc/RunesSwap.app" 
              target="_blank" 
              rel="noopener noreferrer"
            >
              GitHub Repository
            </a>
            <a 
              href="https://twitter.com/robin_liquidium" 
              target="_blank" 
              rel="noopener noreferrer"
            >
              Twitter/X
            </a>
          </div>
        </section>
        
        <div className={styles.backToHome}>
          <Link href="/">â† Back to Home</Link>
        </div>
      </div>
    </div>
  );
} -e 

==============================================================

-e FILE: src/app/favicon.ico

-e ==============================================================

          r  f           Ø          y  g  00      ü  à  @@      ²  Ü  €€      DX  5  ‰PNG

   IHDR         ‘h6  9IDATxœMÒKOSAğóŸ™ûhé¥”‡-­!„˜¸€Yº0Ñ•_ÃOæ–ÄÄµÈJD‘D-!iK-¦kKÛ{{çÎ­ÚY9œ³øáp— ÿ‰@ÌLDD ‰*3A`üçqŠY  ¤”¾ïÛÆU±ø7ËÌÌ$„Ğ:¶Ööz½“òwˆØZË£Å5:Áqk­Rêg³U¹ø¡ãØuİ™l¶Z«¯®®Yk¬c,ÛëV³ı»İùuutøÉ&z¹xÇuäB~Qk}qş±rvtÓ×J¹Ì¤‚túÕÎ›×?›’n®Ğ×+OıÎ³ûÅdéh¯`wËµúl Ls7^NOg€v·7
­F½Y=ãüš–^Øï§§¦—äA¥ZÛûbmo'õÒNÂ® b%¥H"?ptÃaÄR9Ñ suİ|²µPÌËÊeÔ‹==h™$D@9Ø¦rœDB¹lTşTÊıPêœ5Œï;7½Ğ÷ÓR "ŠÂËZ¥g½®õò·8(›ÍÅAÚÙ\1·ÃLv>·üÜ“VãxóÁº5¥t&`1^·|>{ïîRPØª^vn‡‰Na3¿XLtˆÃ÷o=Ï÷=Çã8N¥Z#Ç?)Ÿ²µDÌ$·=R€‡‰¡ DQ4C"€ç§¾ŸfR~.7£µ¾5?$C@1>ï¿q‰¥c‘R‘1Æ;iSM0%cGqb `äÄ#K£N‹aœOzÿöÕª,	Ù¯    IEND®B`‚‰PNG

   IHDR         oª¯  VIDATxœ]•Ïo[EÇgv÷½ç÷ìØqš8iÒ8I“¥j@(¥-©¸@ !8ôˆÄ¿Ã	¸À©.TPZ”¶DjÒ*!!)¥iZŠš‰›8µıvßÛÏÏvÙÓ®43ßÙÙÏàÒü,   0 C²˜Z ¹¹ãÄW1 ¶Í˜;=ş·@ÄÄ,•ØiÖvDf ffb¢f
Ä„©÷òÀª™é‹‹1ãyÍk¡C-…DF!·rI\Ô‹Q’K!ã8úó¯ûRHbò\wşö"1Ïœ;Ó_*i­…À¶d3  sruF@¢øŞƒGA£^E!ÈÚó33¥Òµk×üŒÛ]È[k-‘µDd Ìø¾#‘(fDILë÷‡Ëåœïàáa(}ßíí+5"WWŒ%Ê™\ t
”ˆ¨˜Ùuİ…Åß—7…"¢ŠuM
±±SÅÎÅŞ‹,íïüğÓÏS'¦mmskóRB·tdüƒ‰ñ1İ¨!JÅ JÊo¾»´sêÓ¢ğªïuŸ8íd²öäáÆÕçû•HxÊ‘¯L¿¦Ÿ­Mâå§l·«¶+Cù§‡7Àçãc£Úh‘<ã¨Ş¾>·¶—aS_º’÷İ ›ó}OH	ŸU•ÌååGüÕµïoÔn®èb±è‹JuıÛİı†#…hõ[d+o}Ñj½³p¬M*“ÜÛZ¬è·^-”ûÕ'o3.ş¶rĞ]ÈSc³òï¶ãº 
¶æè›ª\!;4	LœÔ#©®rªõøøQ÷Ô„ÿËBucË¸J Pİ€RÒŒ˜	…Ü[s²…¸^µ&DD@D D´–äÕÊÃpşn} èœŸÎİ¾WvHİY#‚HšPtü€uÍïîí¯ı³†d¥ëY”`òÓ¾¬¬W÷ŸóæıãaøşÙO6Œs¼¿H£’^µ~úh=çùQ×àsëÄùcÛodv?{ ãFNOÜ­}<á]úì]ØÚ³¾ìrwÃáş“Y©£oÍzûÅ—_¯İ˜í*01ÅFº™(¬¿<5962<sîŒë¸Ì¥?77‹·€"bg`xêá¡Ş0
\š¿ ®ëDfJ~³¸»W9l˜•Õ»}=…#==Dd"½pgåõÓgGGÊa¨ßqelt„R0sÂ#µnâ€•Tw–W/\¸088øëõÆVâ8ÊesSS/å<8FqÌ‹(0ñÁ¥ùÙ
“ïÌ B`ê«³7ë¡96>GQÔ_ê)c;)† ŒKó³I2³R’ˆln”EŠ2k­‰"‚™S>6y¦Ú m¶x5ˆ­EÀ±Ñrê¶4¢HPƒ­‘vlrNÂ¦ünS†uò?µé
( :NM	äTH èdÇdh©6ıDš]Ûº98-c‡"0§#[´g øÑAØ10Ó”    IEND®B`‚‰PNG

   IHDR           üí£  @IDATxœ]V}ŒTW?çÜûŞ¼™™ı€,è²,°H¡B,Ğ¥€¤Š¶üa"FÔÄÄhüÇÆlüCÆ˜¨iÔT1jŒÔÖØ4ÕØ*¦TÁVÛm·»eYØ²°Å]ö›Ù…Ï÷uïñûŞ›YßLŞ¼¹ïŞs~çsÏï‡C€ ˜0ú03 Cô`!^Ö|™!6Ö ˜ ÀØ3s1^Êœ¬æU"ëÑ_67óŒÀ¡1« ÿ
3FLHÀQ”˜¸D D`cXŒ^30!0 Æ(ôUápÃk¶RŠs Œ÷1ŠÌLc4Ş(6f6ã &p ¥”ÒJk¥”VJBk>gYsœ2-‚ÁlÌr”ˆ±*U€Ì,årÙ\KK¶¥%›Í´æs„øì_˜™I;¬Ji?1…€8<p!Ê||÷˜!eÛÅå¥¯ıÇ¶lf€TÊ¾99•om+—Êİ];ñh¹\!ÂÎÆVàğÀES…ÌœT©E!D¥R¼4º¯¯¯X,
!˜9Ãõ…ÂÖÍiÇyş…ÃÀí?¸¿V«# "5j™YÆN	¥´“84ë´ãÌÎ/Ì,,Ú##Å…yKJĞJßpœ­=İKËËÕÊÊ¾û÷Øv†DÊäT®ëˆˆå]šªB(­oÏN!³Ö 		¥Vwn½¿¡=wú3§jÕ#ä³Ù_ÿî÷#—¯Œ]İÖ»ëÊØøôÔ‹ÒZ3ˆ{wííYïyu@a*I0†Z}ûû?š€u™$	Ö+Z…D"»şàÁÑİ»®w
ç¢Öüê?Î=òğ•7ŸÙ¹fdÛ&ğ\ í9khäß‹sŸ>räh½V6e+™Á’ryyiàK›¿ô³Ü7Í¿ñ’®U“-­ìÕ9÷î–@$¤Êóı?rüNÙ¿9|öäÎ+“K™¿½Y^Û&ï”Õ¦NêíÖAıÙ×^ÇşC‡<ÏeDŠ€è8„¾·pÓ/NËtËÄÙo…wçAyà–BS‡ˆ Â ­cíĞ[¯éºtîqö\qjÁ}w¼rcºşÉägfu>Írá¹ñ›ó)ÛfJ3£ ²@ªN½—íŞ9ùÒV!
 ÀIÙ×&f×òàb9Sh‡í]Î+ƒ•îÎTİÕ_ùÁÔãı¹Áqu_—wõİ	ËÑZQ\¸ ¬4kRŞ½ö–•iÓï¯…eëøœ"*¥¥ßŸ­ïİùú©BWÁzâTá':Ş¾V’2¸}72 Hs|ÌED @Bîıæn&×½+³q«ö]ZRÔ}™„@Ï×•º.ÕôÃ_»¾TÒÛ»RB¨5 	D DŠ; 3³&!B¯>úô-¶èĞs‹3 mŒç  *ÅCÛ¡†Å•Ğ²àÇ_ıÀ¹Ÿl›-¿ıS±-+[„AÍÇ„kĞ¸`í»ùû¼;VKşöày”6+…¦9#øa¸¾Ğ¶èvŞß#^~£ò3³ÇOşrîSONœ|°uÿŒh²í-Ì
e£
Ë²²yi.ßõ¡ÂşNşåi«õiÙÂ²4k¥ „¡ZÛmíúØøì™ã{Ò¶ÀîÎTg‡µ°ôíj›	İËÏõûDŸïÖIBÌÌ\ŸÖ*lë{\ÉTñ¿7œmèÀ_¸vie~.“éË¤r)0êhÿ¾‹¯{ºø›äàõ´VaGÎÊÛ¸®Û}ytÇ¡G¾œu´0 H³ûD"ß’ºû×§JBIÖŠµB!±Z­ë?8teÜ™˜<°o½î"a¹´rôpÿğÈš¿ı9+&¦¥ÍãsbQ|ğøÉµm)×ó	‰%"j¥3™Ì/ú¡VaÜËói HÙ©Ñ«cwÊõâÒÜ£µ"’ "A•Jåòå¡®î‡
»Â „6¢Ã›×…¾ëy¾ Ò†n“v-„H2a|"z{hxİº;wîøÎw¿·mË–0‰X³°¬Jiå‹Ÿÿl¹\6ÍÜõD2ÂP&ì†aD±"ªÕj·¦gûêXÓñ¹Ó§‹ËË–”Zk¥t>Ÿ+—JËÅÛÕªëŠÜ  À¡˜ 6"!æ7f–Rº®÷ÓŸÿêÃ{v¿76Ö»µ'B"DD×ó6vv~à€ëºæ<13"23&‡.ğjB5	³f¶,É ¯şób{{ûñ#‡«Õ	Ãä¨”r]—ˆ¢Jg%Sƒ}qhàb³h‰7	ã  0“N‡aX«×MmŠ%"³Ø´<ÑfPÆüÀ‘jc£Îb±€À\©TA  Ä ±‰œa,9Œì&Óš‚`n†5[BD4^ÔØOLòÈq(ÑLŠjXºI¿ÅYIÆ#‡€‘Š„æFuæ²¨Ğ£‡XS'p8ú6TR„‘9	­a7ˆAn,Se“‡¦P°¹À8ò«òÙü¢‘…8íø?êªípÑ!Ù    IEND®B`‚‰PNG

   IHDR   0   0   Ø`nĞ  ÃIDATxœUYi”UÕ•şö>÷Mõj.E(@$Q±p@;­†e\1Q™QH í$ÚbkŒ[blJœ±m³TD;¶‰H”D@ÅJ¦™j®7ß»wÿ8çÜW²jU«Î=wßŞûÛß£Ö¿  PA¡P"Rû+AE€ˆ   ¨*€?(ªäïÔş ğÿ¹G!€½Gão`‚ ÄdOÛäŞâÆ€@w
U9œ5Pˆ@DTşaõoV …ûAÉİíìeç™ÿƒ’ªı™ˆ ªöjõO¨¨…5]íÕª3¬! ëŒ5Š”TUUÈf@m\«!s—€@Êîv[g	äÜ÷ñ!g;©óMm¸T]²\¤¬ÏqŞï“ºl@öre{¹º\ª{`c®êÍuéVµ	tvÇÁp;«¿a°gì…³ÚƒÉñ9¶7{Çíq%ï¶Zóê¿à]$m‡"‚ŸªKµ÷¬)ƒ”¼.ş6<lMdöªBUÜ!j{6~vú5~÷ dÆÅçìË¡ª`"Q±ˆ…ªŠJŒàØpr)P V! "_¬PTƒD.Œ¢‘µŞÿI=8S“‘0ŒÂ(Tıs R©†Ù6:{E7	kº³Ü@U-&(.LUUi¨¯g6qØíÉÀ˜\>ÿ‹n>yÒñç{N:•*†úŞW ù¢¯ÆY”˜  ¾ ‰lAkœQïŠ@:~õ¯¯—Ëe&[Ø f
ŒéØóu©Xn3öûÓgßúëÅgqZwo¯a#ˆo%×rãÔÙvJ®°‚oœ³‡qÜúlE•@"QmmíŸ^Xµ¿³§©©Q¢ÈEP€‰‹•hÆŒçÌU.UÖ¿ûn2™œ|Ò¤\.ÇÌ®PH!(‘‡Š}?hã†7- ]!Ø®AU+áK.i¨¯æÙçƒtÍõ×/Ş½»ƒ	`VQ@UTUGQ*;;;‡Z,¯¾öß›zæÄ	GŠd	ß8ª±€BIƒ*Ö}	«DÉzøÙ;T4_mß9gŞœ•/®\vßıÙÚ,)ªª†M±Tœ~Á´i?<)—Ë<şäøÃÇ|{ü¸|!GÄ[gğ=’|=Å%F¶Êâ–¨‘H"HpÂx«ºİ5™D¢©¹qÉíw×Ö¤—?po>Ÿ'°½YÉdòš_Ş0ùämk»÷¾e]]?š7'_(G’"RÇã4ª„Q?ıL!  Q…fÒ™\.—ëï%;á³G€’ˆôtrB[C:1²uTgWw`XU‰€Š šÍÖ477ßÿĞÃæÏ›ûÅW_¯ZùÌ¶mÛR©TE ‰J¶&=sö‚Ñ#‡'T®DÆ°. Àv/%ìİ·ï7KîŞS4ÙÆ&ˆ¸ê›@ªH&‚Ú†º=«ß»ğŒí‹\ŞİİÃJÄLı¹Ü²ª«I]¹ğÇO­Xñöšg®¹¨áäÙ©r¹
CI$h_wá×O\?dÄä+æÿ$•ĞrE™}‹'6IcCÃòGŸøÇú÷¦,~²eüQQ%äD’ “HT
y•Ğö}‰¢T¶¡ë­WŠ¹ÁÆÏN×h¾3ù¤J¥²àŠyxø©CKÏ½tïèBş×óK¡Šh&Å=}²ğ‡Íÿ½tÜêW?|øáû-úi"†¡Ø¢SÑ İP¤Séd2ÅQ•²ô¶¯¼W£P*¥q³'j›¥œgX…£"K…™I¶«L\.—g^x~*•|ôñ‡„/üëå­ËÿgÿÇÛµIŞ±·<óìÆ»Ş÷«ù#î\ñumÆüîšÑ0›{ìùWüXUˆP"8 UQ	ÃPTPc¤4PÉõ»ô7œmŞ¼ìj)å)‘ &bQuÔ&n¶‘0ã•×ßß·ùÉE—öèsí»K§M©ÚoI6$h¬5S­]úÓQ§MÌŞ²¼cÊ”“ßúãŠÿ=dXK%íMÄ"îĞj˜E4Õth~×ç£ÎÕtÔ”¿0*æ8HX²æŠÅÍ<"?:ºz[?ycæw[öï¬ücSoKƒ™ñ³-KÚ÷Ğªƒ'-ÜòÊúş©×´çÑ´iC»{+«×tuÖpô¿ÿÑ§ÛjÒiQU€U-	„g‰àÀ¨¨ªp2Õõéº~ÿ“CÏ¸¸nÜqŸ-ÿ¥„e60àH û—H˜ı;¿|ûÔS†,{şÀÜsšgÕôÒï3µéÍG¾ıàÏ[7U˜{ÛƒÅ«g_ı^Kmí0óå¦Í[³5i!9Òå'X%T[ÉA¦¦ïÀ¾İ¯­øÖŒë¢°¿‡Œ!fÕÈ³øÆª Œá ™‘beëîÂØC’£F¦Ï9±®R–	c3§MmYtAË´ïÔ¯ÙÔ_ì—±­é½İ•|w…™t:E‘í/íÃkÙúe&ÃlLT.6Œ›xÔÌŸµLüçM÷,Ê>&¨¢QÈ ˜$´[F<kP&¤S\
!%éê‹2~åŞüİ;ÚÛO¿Şsı%Ã[L%%8€H¨ 6F	 ªâÇZì¬#–êFOhxÆş¯Ùú#,©ä{5
A?dI‚õÇ¥ŞÁ’ ÑH+ŠL’6|VXÿI.“	j2æ“mÅ‚4Õ–…;¢äé9;æ·?…hDÄIdv½şÌßÿeJãøIG¿ã¥’Ùz‰ˆ¥¶I9ÚªX UÈGÙt`²fäĞD÷@´ø’a½oMÚûç¶§oj}íŞKoß4Å
T ²°,L…²ÛÁ–¬‹H…IHføèí/İ?îâk?^vuÇ_<ìÌYˆ·3r1±¨0‘($ªPÂ|wRıÚÆî/ÿiM)ŞŞ<°ô‘¯K%Éd¸udzÆ™k×õµN×Kª„a%²®0Q@nER‚2ÙQÁªÂLA²àÃÏ_˜ÛßÑ±æ©£,ùô7?íÂÀÑPˆ@Š¥rëˆæopşŠ—^{îaWİ³ıˆQ©'^ëjª1o}”sc.”JÑ£ÿŞ:oŞ¡‹®Û:ûœa[¶ØU>nÑ©Ç÷ä˜*Ø²o»¥ŠŠ¦RnO{û‡…î£ÎˆÚŸ[jRi
¿.U»†ª&æè	'®ı˜ÃdåÒëì‰–ß<æE‡şêÒá_n»øÌÆhİ	Æfn½{çIÇÔ~Jí+oô<üÄ–¦Úr%²ı9  äšQ"]CÌ©ÆaMGŸ,ù†ÃÛÂ¾ƒcÎ[¸kõS0	IN&QF$"*ÆîÂÆ˜Şşü¤¶1Åüu·=xÏWIkËÿmèş²£t ;ìßÿ<wãÃ{sı•ãÆ×Î»hÈß™:gÎô©»z±enE"¨0s"0a_÷Á-Ÿ©DuG‰\oWw·a®{bF_nÎÔ7umo/6—ëj³¥b¡\.d9i˜şşÜ§[‰şí¦î»nzêŸ®¹îÃB%”RY¦ÚÜÕM=©.ÔâıíÚ—¾è²ç÷õõ&€ßº‚¡DT,–ò==?º8ŒDU	DÌˆD°1"ÅqwİòÎº¹|nâ1ÇDQäõ0›Ş¾³O=>i®œµôéé“Lh­T*}}È&iåšück³“§\8wÆ}ı}ÄÆ)L*J¬{“"’NeŞıàƒïmL§Q$vğzƒˆ¡Peâb©8±mBCCã‹şKwg×=wİZ(İ>¬nu# ¡¾>‘L­xöÅ/¶lK¥’a$™TòŠ¹3Òé \,)Àn³sÌš6nXKnÚk&N¥Ó"–Är~ Â0jin~õ¯«7mşìòy—ıö®»î¸ùÆb©DÄåP˜€ûú®¿éÖ|>¿øçW\[n ÏlD$Òß?`m×xAu•åö2'Š…\Î®Ø‹@ZV¢0jjjzö¹ç?ı¢ıÛnİ½g÷gŸñüª—Ã0²Æ[‚mîììxìÄş¾O>ù|ÜØ±v;sË+`Œ´‘Ó`5! Ü€‚ˆƒ€¿9.=Û%H$µõµ{óï;vï]rû-QÖdk¦_pÁ}ƒÀ=·G"édêÎÛo¾á†`c¡A<<ÕT¿l¢AUÎ¡A:Üf+=ÖÄHÂC†kß±óË-[Ç;¼6[»`şåaÙ$+ı‘j2Zµre1Ÿ;ı{Srl\ow´Ë½ÍmZU’çÊ¾ªE8U(N“ßp‰	LT,•:r|C}ıUW_;zôèÿøí’Ù—\ÖP_ÇlI‚Š*³)—KcF·.úÑá0Œ\,ßµ&»­İ+€°+hãú7‰q@ÇQ=œm|E¢l6»«cÏ«^Î—Ê»;:üÏ¥ùB°Íp“QÃHDØªAö½¨‚¹Z“şj·ımt*¬¤KiÕ×tUb²:3¤¥ùõ¿­5Æ´stX½àD~T+è1±$ uúkÕŒx·÷ëß¨*·_zPûîâR_İ„¡aÖ×Õ‰j¡P°\DPõØ/±K4è÷Øs«ˆ ªâ@Í€@ÉÏZË¯”<$ù× ¹|ñSU9Ï:ÀˆE7‹L/rÄcìxMLÌ.S ûnøMñU=o³İİmO®6-ÈHÕ¶ÏA•TE`i»Vñ‰Aop’ƒm2
ê}rHvİ-ÊX½ko‰ªÏD¬‰©ªXfâ$µÚ¼¡šÌX¦ò¿Ò`$Õ¬ªùà…ÅXUÓØ,ƒ¤j¨½làĞí»ÀÕÄ¹)¬¾QŒT%"&±ñq3TmHH=Õ·T·Úª,½´ßÙéçˆ{´³ØJ£jy±%KN²‰u§ªP|¥?”Å_`;…×[áÇ)©øOªeáà¯O6tî
û1C5)¶ª•EğN.©êµDª~jã1M ÿ¡‡ú¨úzTñçMv8õµéG¹Vm ÷&õasÓJ•]áŞæƒe6¸ky?]Íˆ,ùÚôaô‚»¸œ{âIæ
É òŠˆèÿı¿ïÎ¼ğ    IEND®B`‚‰PNG

   IHDR   @   @   %æ‰  yIDATxœezkŒ]×uŞ·Ö>÷Ş¹wîÌpÈá[$%’v"Ç0ŠíŸ(Ğı‘¦n‚¶–`;AjË²%êIJâk(¾Ä‡HëAQVd[/+±ZM#Fa-Z%ˆ•ÀN”˜Òˆ”H‰–DrŞwæ³××kïs)”ÈyÜ³ÏŞëñ­o}kËÏ_ÿ™ €˜™¨˜ÿ I@@€@ Bš'€ÿJ ’ ( " ! €ô+R BHˆú»èJ0­L¾óªªBÿ¡ª@Ò²*ğúV}uÿ^ ’!€øÎÅ¿@’Pÿ^%}"¯LËËŠBDHˆ ©"0ÑWVQ·	#	
ÌmE@DÄÿa²@%y’¤ÙR¾Y’féy˜‘¤ª@Òù$ùE88¼ïµ]óòô³ÒÙ{PUF˜™?Hñm'#Â!-›¾ò?*¢î[’¤»×ü-’<¡
Ó†D(¢$i ÓSµ¹ĞX; ‚h>
MGNçe:	AÔ†&AÉ›%!µd`$@‘‚W P~PT„’ÎK@SÀ§˜pW’–"=Y X4UñÇ,ïÓ·ì6=‘Üu$ëSEÅ½ª
 Jrç…ÛÕHf‹ ¹Rˆ?lî @ƒ( Ìâ™³€"¢BŠJN=ß¾?iR'MÆƒ:£$mÌÁM«{`ìôê”Ai{š²<ç™,™š“9{¯‹Ï,"Ù4ç4t¾ÿ/xå:·=”,£ò¦+–Ï˜ -§€¢P?TÕÏ'§Ã§;µ¶AÒTTE‘Î­ì9‘÷‘,}¦LôxÎf éªA	>sØø‡4É!&õÂjıAÒüø–ÖÏãœ¤š'Yq	Ñ~ehs?æ(sg1§&aî.$g×µ Aš±†|:f #(
MzRS©â ïüHt ÓäLĞ÷aîá„A^>Äõº –”¦îwQ7C(†Ñ`¾	0'[F`E®£LBKŸIQçp’#…ChÚv.RğŠH«!×A\$¤ È'zJù*î·>Ô  É¹Åy£vG@VÑTE4¸#¼ú¹I²ÿm°ßÁ&ÀÁf`D!^"Üâ¥™ÉËòªb„ˆ‰s¤Qá b ±B‘AÛ„0°Q³ss·İqo«ÕzôØÁ£#CCíXU¢î½)Ù5í/ágÂ¦ÔrøÈPW¸›áÅEé€ *f¬œ°I<ç0ÈjBQÕk33ÙQ)€Šj°C×¦gcä3OŸ¹oç|åÙ§_¿vMYUîÇh9ZSê˜…hôšäUÂ’û!n#yãõŸåBJx™´„&N%<ÜÔÖµS½Ài—>ø`ïGzK½BCŒæğ'ñHˆJUUÍfó'ñ£Ù™Ùÿ¾Øi>vxÃ†ue¿¬áÕK$r¦`qj”Ñâù&ó—¯Ñ š­ìÎ¢Q4  ÑaŞÉ£Ü€ÑŠPüúÃœüÖSgœXµ*ZLxÅELÈ\•ı¢(:ívŠÅŞâ•+WïİùÀîwoÜ¸ÁÙSÎäÂn¼ş ‚\½aA” fÆº@ Q 7¾h}âÚ"n\6Íé™Ùİ“GÏœybûömæÆO±‡ iĞ5«G»]‰1v:Omßzü‘ÃG}lvvNƒÖõ1O&‡€â%?•[§^ç¹®@6ñyzNòf@#go¹·víêË¿¾|Ë­_™Ÿ›+…"c¤hD‹ÎğË/>·vÍj£yU;÷öÔääÁC{©ÊRT3çı'äDNî`ış‘ `HášH¦Ê'Ö…ÀR7“ˆ¶™©èÛSS;wî>:¹glÅhŒ&™ ©(ÈÂÕééÿüµÛ_}åå±±1U½xñÒ]÷Ü¿ï¡7Ü°¤JBÀŒuT•1½Ì½#	ES4Q!IQYßµBQs¨hT˜©.3£-4ív;¨~óö»TuíÚ5ÃvUVÈåİ(!ˆb~n¡,«¡¡¡sçÎİuï®É=»nÜ²©¿ÜŸ™]`r& Í_£]Q-«JEë–0¿ô¹"…½‚Ñ ˆª@æççcŒN‡SMòÚ3ÊŒzSóØ‰ÃeÕ/ŠÆÒÒ’BDs±I•”"¨ªX4B»=tşİwwÜ³sr÷®-7lüøÊÌüÜÜäÃûzEQĞ,AMĞXUNûø±“İn·Ûi›™ÓQ¥[‘"ñŠSp¹råêûZX¡ÑÈ¾ƒWÙœü×Ã¨j Dª2¶Ÿÿ£3#Ã#1–™¸ÒÁÁhF¼{ñÒ‡íß½kÛÖß}ïıİ{÷xpãŠÑ¢ì[0VÀ 2×ÃÜ¿3bèÑc'Ö¯[]Å˜ 	B˜g¥B
O[ U]\\üæİ;?š™¿ñ‹¯úôgÀ(’ÚGQ‘ØïTu‚%$aQ­åù™Ï?àÃH4d«ÙŒUu÷=÷Ÿ:~xÓÆõS.=rxïİ7:±rb¤İ¸6WiÌ …4”‘BrãDñÓÇ6x¥ÿÕ#û<¹iıêå~?±ˆ©4+H!M58ïe¡×QV§«@$âòb E A›£ã±ª´£ªBDU%ci*0gº DD¥ŠÖzñÙ³¥ÅUããç/^>~tßKŒmÛÔ¹2gï\^şÊ‘óMWİN `q1¶š:Ò?8¸e¼[lÛ4üâ.~õÈıo\·:šy¯ãÔ˜‚B$
¢Ò(Š^¿,´Á+û‹¿<s'iŞÂ}vÇ™ÆÈÊªì«ˆEŠHÙï‡fƒe$)PR˜úÉÕªÚívDôÒ—OİÿÒCc[7O]ì}éè;ß½ùÖÃçÿì‘›Tù;½óç§¶©ğ–ïxõğöOm~áA¹í‘}<9±j<U£šNKıÀ*V1zù`YV¡ˆ-şæ7»yÇSV•¿|jG\˜Ö¢côú)Ai /øô.­†m1F ³ó‹{÷îıŞ}İ›6´§.-ßvúÒ3÷oşÁ-İN‚VSD©ÀæÕCşèö—'·|ıôù·Şïo_ßyîş‘={÷/,.7Š@Psv*5K©±†sÉc³Ù`‚†šCí‘UÿäHüâÌÕôG¡!¼¾KMÌ1«N$#-5¨"‹ŠŞÄÊÖ•Ùøå#S§ï\wÛé÷şå½oıëûŞº<]}~Ç¹ÏßùöWªßÙ=uşrbE±ı†öÓ÷l¼õĞÔ•ùjõxÓâÜÜü¼‹'<.Åä®WEDDƒ:¯¨…†`ıŞßœüÊü…_ş³ƒ?4Úß½{éÚ¯™ä A–T%›?µ­*B°ÂÌìÂ¾ı{_Ü0<Ô˜™¢ºj4Ğ¸Üs½Üë?,¿°wêüû}V®(
‘k3U§]üğà†É‡÷OÏ.4ŠzoQMÔ#÷“¢êì3ïíÌ*(Hô—ß|arú­¿ıÜÏğwOßÍş’6
ÀHó½‚ff‰ú$“,,,6æñå#^Ú³iíxã§Onû?ÏşfwHÛ-ùŸg¶¿ñü§úøö­ë›—>îÿî¾©«3ÕøhñÊ¡›~ÿØÅ™9®èÊüì3Ã	˜BEU“<àHì÷«~DjU!@Ñl²ìÿê…}ÍöØgï8E3VeªE#V•Y$¿±dİé“Ğ ‘Q-ôª±aÕ c#Ñv[W6Æ:Å–µWŞ2ÖÑæªh”öÎ/–ÑhVƒŒfª"B-ÃõäÕyQA…zyW„F«Ñİzë¾Ø›ÿûïìV-DCŒ´ -4‚w7–ÏvĞ$³Ñ,¨( ªŠU‰äÕÙRP\›¯¾rìÂÜ¢m^×
Q…€fÔPÄ‰ºˆ^W³H£µ !ª¢jUÆX´:ŸÛù]Ò44ÿúø— á·îx­aZ„&FÑTk%9±¤UŠ$¢ñìqÓˆp~!ş«{ßruíêœ­-~pà¦ñ®ÆHgxFŠ™Yt¬×Ò u'QV¦VÜ2±WU’Á$uhdyi¡êÜüµãÃë6Ì¥7-
˜€Pï,ÔÍ%kfí:É'ôW4EMz+¡kÆs‹öå£ç/_²ª&
ÑBî #Õ;,‡'¡Z 1–^ˆTTC(——şúøüıÙ{ZİñOõø¯^š\¼|^B"•YŒQ4C*$IƒŞ$uå²¨*T%4¤QÀÈN[ÿ÷3¿ñË—?ó‹ïßüÚÙí›Ö„©÷—ÿíCoÏÎÇVSJoÓ+¤‰.¦h¸DèwÖ{@ Ze4¡iC§ÏıÕÅŸ<?ºåæ•Ÿù¿8»£œùH‹"„B³IÍq"4Ô1	•hV¨n,.Ç2r¡gÓsĞf‘ËıØm‡?™Ü:Ú•QEæ{q¬S¨°!V¹©ò,rNb¯jR~HÆÊCªşRc¨{ó?ù‡ç÷¯øì?ÿÛOØwìOİõOwÍ–‘eøDc›5z½étÚÓqÓêÖK{7ış±w_™Üü…½ç?œ.cE	øüo)ÁŸÃØhñ?NßDğ–ƒ^9°e´-—>®ºÃÃ’[¯0šÇ‰ı:Ï3Šj!I	A$­-vV®ùìOşêå£Óoş¯m_|´şr„E³2²–Í:bÊ®²_·O<òè-G.Í/V£#¯ÌÅ¢ÁvKG†Wà)è-Å~ÉvS~rú¦kZN—fï6æ{Õ:|ñè±£#ÃUŒ¢êä¬ ­– qÎ¦³¨¢^É,ö«…‹qyiihÍ¿õÍ'ŞüÎƒ[~ï®bhXhAÜ"0Éˆif9“;T´Ó®lèÃ«ıOİ8üÇ“[n?õŞ÷Ü²z´(cüİıïüøô§ùïöMıÙ±Ç»¡Œ|ó|oÇ™‹¯¹q|¬8÷nÏĞn·½ZŠ‘^§†KVÃ£Oşşñû«ªŠ¢ß^»é3w<ñÎ{œˆ¡9ä²™#…}İôˆˆhb•Ån§yúÔ£·Ÿ™?÷ŞÂ¶Úß{pÓßzïÖÃSsK ¤_ZiÖ[Ñtn‰¿ıĞÔ¿ğ½6o]×šzoşëOÎ:ùh·Ó*Ëè{sQ¸P¢ŞU¦AÒhµ)ªmv>wß3¤	‚¶†Ì,.-­Zÿ¹]/˜Šf¹¼šÍ¤æ’€Q‘W
…Ü¸víıG¿~lß‹ÊÖÃ?>µõê‚}éÈ…ùEû½ıS$Íä{ŞéèŞ21Ö\Ño]\üÚãsûœX¿n¢ßïË`ÌG¸¸›†%æj)cöê‡¿zÓªRB Ùj—ËËKB%h¡écA¥h,^û8V% E £—f™`“ı~ËÆõûœüÃGö>wÖŒ7·¬mıøävŒÒ" ŠÑvXèUç.,}íñÙÉÇ7¬ŸX^î»Èˆ¯T
Š[İ'|Yö{ÿû	¨z7¤HÅG$
¬giU\71^4Š™Ù3ë´ÛNmIª¡EŒT•²êoZ¿æÀä#·îİ«ìÿğĞÆU£E¿4G±Ò|¨(./ßrô’IçÔ±ãë×¯.ËJT…™³« bfÓ –¦q2Òíâ#U  ¤¥Æ4§Y{¬ûí'O-,öØwh©×{şÙ§ºİáXÅ¤@H¨‹}"eUmÚ°şÙ§Ÿ™[XüòäùùQE-¿ªÄÊ:íö±cOt:Ñ‘NŒ±¨¹Ì#
•7^YìuØXZZª',-/i”\ji‘ulŠfãêGW?væèáCwî¸û™']9¾²¬*d1˜ƒi\^^&D—J#¨4¤ºx¶jÅ(€²,ÅëanE™5íC\[uÊ7P…\xtŒÑ¤ƒ´V«uñâ¥Ã'N?÷gºİ®š­¡P#ë*ï™`°††……Ş~ã®ªª†ZC/~÷l·;\•U‚?š‹½,«*¬eAÙ³…¸x	†
beIZËówºÄãı¹÷±r:‚¡VëíwÎ?õÄ³ß>»yóæË—?ˆ1^¹r5ÆªªLFª®èÙ(ŠéÙ™‘‘‘Ó'İsß®¥^¯=Ô®¢%4º>H:i†¹î“éCªU*J!\Z$u˜¹©õÓišT«ëH¢9œ
…PÕ‹—.~òì·Ï>±iÓÆåå^Q44„ûÚ\©"ÅgÏfP£u‡‡ÿøûÏtGÌB=O&¦ jĞDC±@]ÚQd¬öd
Ò¼³*ÖÃ˜4íÜK	AçæçœøÖ©“Ç·mİÚ/K3v:¿øÑŸÆhBêÊ”¬d”P-&V¯œzûíf«™¡,7æIŠÎwXÒÈBÔ$¬‹3|çãòÆ_¾–F	itNç¤’o¨L¡Ù3H”‰Nn¡¢\¾|êÌ·;urbbU{¨cµ\ö]d†Ç=]·ZœÕk×®İ¿ëÁİ÷ß³~ıº£d!Hæóx˜ËE©A!±Fùùë¯¥ÈÀ`ğÁ„hi˜áùçFJ*x¢Ñf£¸ôşå÷êõz?úÓWÇÆFÿÍo¡¿Üo4Œ!ˆI¤	%¡,Ë‘nçä±ÃkWOTU•oFxÕörı¸Èê/f~yZËÿ÷géò¤î_ÙÈA$±Y’x/yˆ”>Îf³uéı¾y÷®•+W>ùø©Û¾qç©ã‡V®XQ–•gpN+±ÊD±r|Ü'C*ê+‡˜¬†C¢~J(¢®!‘n.XçáKúëkÕ[÷ÿ¹Ëa:çP)ûıuëÖü——¿;;7¿ãû®[³z¤Û­ªJ õtK®ûŠf’ªÊ¬\ä_Q NmD]MAH®äØRÈÏ_ÿÙÀüğÉS¤›©·Y]Sõzç4Ñt‹¥ø‰àÚô İáNªvùşXJÉp˜¡Šš‡BqçRS¯¦€%8 E*óBXÚ=éàEB~ã$_¿¸U·?.ÊçÖÙ,#@3!ğÛ$ÆJ%ä†!¼œ–0™ N}Ky¶„×T™¼.‘,²dxß-?†ôÈ'CÀ)2<5¯+“ `#©¹l
`U3ÒÓ¨®ÿåU}É„H”,ã’ãËëVå‹z®JºK†AW˜´åëM¤«[š‚Ì™iÊqO4D‚æ;©Œ‰ä^ğ©sJÁtˆIæñÛné9æË„yŞ j¦Sî›Âi	#T”Yó'÷ŸÇ§g[‚ ç-î„ÔÍ;Í»s»Yº–¦K à»F¦g€º¢V£†×Ij
Ï|ã†ùR§ƒ
D@M]LRı²›`>+ÒTJ–Á"´lgä:S/á7ò¨¯ÖşÒ•”$Zx•ÈY¨Òˆä:Šà7W\³ßî­¯…¹Ë DÔòU,æÓ¥‹¢HòUND&,›Qó¶“ûò*–:PS §¬éw	¬Z_>“„$X$Í ¯)»™dıÉ¨á×*€ß¼B’‰k,®§¬¨o«å¸«1'ßètz‹œ‡é³‚:Ës‚°¼.ÈH	d!‚é'i+T	Ğ$ı˜)NœT¡)ŒuÀ_i ƒ6jt×ZÛg&ˆ	é‘8GŠ«©^H×Y0pC:hš´æ)¬ b.R$CÕjE6¿3ğ\¥5™€_ÖIÉÇìÔš¤ä€Åuÿ_wÁkÒ‡ı–[¾«'™2åH’Â³*]MÂ ª ß^cFëOTÈü^8R©M!ïÕQ7İc½®JøFÌÒ5ŠÁ2šÒ@ ¯õ¢u©·Î)Ój¼1¦YÊ—´|ı®eÙí>:CŠ2æüMIìyÏ„œ	T… YJö:xİHı1rıÊu/ßĞÌ2!P#!^%%Ó=•4ÚËrE†TŠH:€™‘PŠ¦”¯Ñ%ßNxœx‡kRÿ”¹~ªGHy§Ÿ ôÙ„i|˜ñ”¢Pu„$YBşSızğ/¸›    IEND®B`‚‰PNG

   IHDR   €   €   L\öœ  XIDATxœEıYÌnívˆ1æ³ŞïÛÿÜ€')(ÀÆÆØç¸lL	¤ U`Ü7J))¹H$r©„pÉ&ÒT]—EªDû¸9î;ª€	¸ï;°éª’¨(nÎŞû}×3ÇÈÅ\ßïsuö¿÷şöû®õ4snòÇèï‰t\*»†H	;A$" ˜˜QĞ	9f"€è˜@I`'’º·H	"M­ö+‰d›”Ü–ÂÒùè%AA †ë7BÁ§Y0F,¶¸XöFFbĞa	‰#®ZEhw×Øb×ª
¼êhï€
²J½OªSê•QÊ2@Ò@MĞ ‚
R»ÅR±ƒIÛA@m»‹
’a˜™ï;U00 â ‘Ì_Dwoo¨º[Q@Ù)PÚ·cA²8N”ÛZ´,1Ìª% #2Ş›IÇ¢¸T*I@"+qF”T‰,;ÅHt‰‰c*²Èt$XU  ÆYK æÛ•€UA&xYÆŠÛÒA†aŒbBÒR¹½æ»3H–„p"JÕİ×b"»;N
"ã)Idæ7lpL Äa"SU)ˆ °V¥c B '_I,‘4b÷’’•$	¯ehwDAH›al$±;YµD&‘*ww’Ré4‚6ÏgMªªÜdƒÁpz÷î­bà6:m gM2µªªfí’«$	H@@¢ P¤İJ[”»C¤;¤‘*1 ªİ İ9ÖÁÌEUq•‚$œŸí AT%‘š]Š@¢­#0ƒë%¹I6Ad?NŠâl; @ªMÌî&	8ôNì®ªÀ¦`€%ñìGaÎI1J¢R£ŠBb7ÀYn±gywÄi§ã}Şó£Jé¼0¤dï½{Û8[ ã8Ù[âŞ!°œW*ªG”{×Z$Y!•ôœ§™!QÍ¡™î€k¯U‰ DÀI¼Óîf)	(İP¢I&B3ªµ°wŸM±ª’`vĞüc‘"ÛDX¢ˆÌR%U¤ àXN’‚:#"‰°‡„$'j Ù½Û[ƒZ"P‡àùÛ®ª9ªEFœ×)èÜ ¤µ6´[™_°²£% Ò©$KrzVx'‰‰¨
	íÆl{ÖÛ1r›mbÎŠt‚$»;A(¤óÍëÈp‘R‚´a­£úì¹ ! @Ü	æ²’"6S,IDÜ¶{·‘9uÃ½÷ü¿8JÜÎÜéÉ*T×z*U ·“Ä)­À³¨EJIvoK‰ÑÉíéf8b y9H€”Ø€4{Hd6J›µæKÎÂµ‘¹ï8G !=ö.)1Á8!âl»ªÃA˜¾Íœ§±E%ÔéÍJÎ´İ×kˆñŞ»B#XK%ivLl@¡J –Ò6Œ¥"¢½½=w‹H#İ½´¨h­ !kİBš 2¯SµXäTMIâíM‚$K1çøòµ~Ìp·<Ã‰S³Hz7 ¥Š!–ª8×$,I„( n‹A”@¥0Vs2Uœ½iw7–t¶%Å&YUUJ S‚4EE.p• †¡–aÌ®²=×Œƒ9‡ °ç&»Û¶ÉÒ¤‘ùò»R¤@bÎ©UÈÙç/·;§¤Ú6A}Î­ºwÛ	•ÀH(A ‚½H‰pÀk_ V-Bq€´„é¸_véÓ‰‰Yt¡Z+f¶“ ×1à8ÖÒê‡ TÑI€s¹x7U±w1˜ÿÌµcáôì¯Yş¹#ÑB!š2A‚„a,UUS BW­îB¥(,áºRI±<÷ı<dWh.öSxNMjZ1	¢€B"¿<âÌ]Ò‚’$İÙîî´U°Š€QÚi?@IÅ9*ínOQ)„‹Ò«RªĞÍL“À"	Ô¼9 ¨Hjiïtvq‰Ëi€‹³ŠÍyEª¾n÷€DEIjŞlÜ}:Ù	 ÃF¼OŠÜñ”á¸.âÙóEm·T U…XB„tàÌÎ@bU=ß¤X 0ëå–_ê4b š&$0(I€¯í’ë8ÚÍù—’(!w:±””–8+Ô»°ÓÓ¸I¦Ø
l²an.DœÎ@ÂTÕŞ;SÑçãáN‚Zdd„˜¹”Lâ¶´|è}6’yrs˜t "¤ UUª°æÃ]çüµdÉ„HïÎ\Ã™Æ{‘éNOÕOtøòÑ8–ì T	İF‚!×ÁÂøª¾§k'íiVR…«ä-$b9ğvAièİvV-€ÊT>@;‰¢ÚÉuĞöZGPín{V>v8µä”Rs¤“,!8¸cèmPğoà"ì6ÉØ­5mÙüL ›ÈÜ3Òj7OK1Uf×1Á”^FTUÒu½BBT@U+¤HP³S2//³"ÂØÁ |Š0˜¦ÖËSÙİ«òè£§{_›š›”¤!Pœ&¾Ö*–»Iª`*W„p‚àíyR`¦s¤}TªŠø)FÕ8ŞÂbæ€Pm§^~şªéAĞÓ’u-x¾·ëØ¹5… ÛÉ®ÌÅ÷ô}¡¯[°ˆLŸé9ˆ¦É@Àš^=A€½÷À,dE°Áœnš!1	C„h›™/MyäAx¢Y¥VÕ|5@sª°ÊÆüÅ¹:ç†§¼Áp‰Ûº]çêI€½jŠÚŞDIë8¹¨*Bù‚7É=(
fõ„ Ù‹å »y¨g/v`´±÷ `1IKòDÂéATÜ®¹oÄ9 ŠËîn÷µÉR:8,3/I§‹/¥R:LÆHïR!-–¨¢HÎ#t«Öq#Çˆw+´e.ÅİM“šÈ)òèZÁôÒS5Ìë ÓÉU–8”¨Øuhëê~p«±ªf­ a´¸¥Ò4õñf¦¼_b¥®‹ˆèİˆÚ¾Îv¦Ä*:P’T²9oìx3Ó—°=W/N¯µ¾·lIN¨€uİ¼„¶ûj}@À%©ÊÀ™¦ä÷ÚN\uA8Î}Î%ˆv•@«Ømdj1œ›İmÓ4H ²¨ƒœ±4è\]ûGs«±¤ŞFv ÛÑ–Ôƒ‘Ş›I’Jl»ÛSÿfÚ¬99 "’ %)ƒNÁâ|Úv²÷IÆI·‡ƒ\è:£$NsIt·J×5Ïé]Ø¡0sÏq®F1ñQ‡È¡âÜi0bÍE2•ñ…íÌŠƒÒÏq£îM²»)Ù¼ÎÉ`.x×÷—(`(e[%Ø	©0&ÒÉ %*5ºm2É¼5MÌšo\oÚERÔµrIH´ÛVØiF¾ ¹Á-ÂÙæ1œ8ƒ­—Ö°bŠ•ncwÎ2P—$wÏ§`(rÍ‚ƒDHBtÕ*¡“¤rlTB§{ÀA¾´å	‰FÜ]T‚äàˆºvü<Ó9rA#P«H`Î…î=wÇîµ^ZÄˆYÓÊÎş˜Ö¬\Õ¦şI®Õ3´(;§ü2b¤D‰@‡™ö­J8Ğo¥@ZL'\ºîZ’Óƒås€W8HdÁ16YAt{
üër~êfN5-ÃÒ¢P˜f~ªuHl“lÓ	Œ½wúºf= œdQ€ÂÍA¸Šñµ`woV‘¼úÂ¹~C;%õn0İg0o•D UÁS]@f¥á;/Óüh³qÉ«c¾pi&=ÿ¶/šÔ‘{GGÔZSñ§Eªí €DèİÓ–VÉ¤û,v„îÌÇ¡ŠÅÀ1cÏJ'ÙvÒ²hn?p°î=•$8 fUÎbzºİæõMK)¸z:ÀAV§ÌØ=‡lUÍiÈ;8­H·h$Ğy¶T¼ëì"Ú‰—_¿$ƒƒÁ€ş0³ÁXÄö`&nhIœ†5¥ÚdçD‚©tÀ` È ¥„ìîš¦ŞV(â Ù€M)Ñˆ4_7,Œ.„ \Û4WXä´¬Læf,òºÉ¦‚ò…ß¥í&‡T!is‘1‡é„PÄ¹7‹¤úº„„)šcƒóí‰K;QâšDØ1‹iKµcÂK20›À¢ôĞÈšÕ$vïº6²–n¶‹d]€X%•ŠºØÀÙAàİ ¥RÃºµ"në8.h©(ÕZW_˜+Ñ{ê½¬š¢ §[œëZªR©
/­~ÈP=CXd£U>°céºú4UN°4,ß|rC	
…Áa®ß™#czn¨c.+©–â¬9¶’›ÖÔCŒ„ì!ÑÃ‰.–$EèÙ iMg×H‰D¦ãˆ@,V‰„dş=„ó˜æâ™.„¹czo’¸@3ñ2Í1
ålA±’töŞµÖœŸKškhŠAlù¯µ®²9!ÊN¡
Dääbê(gÓK‹Ğ{8æŞ My·»%€œòĞŞ‹DvgzÚö }s{“«„~¡©E€1ÉÀ	?„äïäÕè1‘æ¥²Cbæ¿KCÒÙ>İœ\7Ì´Œèn®‹E 8nªd›˜<BíîÏÿ¢¯ªCm§ııßóa5†>÷l²w/h‚KôAÂFÉ»kU;%jœ ´X£¡¤¯’Àî@XS_Œ]µLs
èv­BÇ=õ‰©²£‹|–Òñ¼:Lıˆ(Ï«šóÙI2T45Õ·±/àiÁ€ãã¶¦~+!³ŞëR·ˆƒS{Àë¾º­[÷9ëĞAöY*ˆî±¶AâP!¹àF@© ½P—!én91²Ï¡A.¤¨ä¸W‡‹—$Á¬8Z»†ÔBˆ¨æbÅlÆ!°ŠKê6AznHÒhR»ı¢qa:ƒ™ÏósĞ»,f¶28àSÑb…°ÍJ¶QâU' n.M{^Z‚Ph³¡»¦¹å À™0(Yæ‚EÇZ1 ŒÔºeoÔhaV`†Ëö•;NPªáÚªÎs_§«†iÉ¹ı~ñ§c¿ÿ³?gøp‘ß÷]ß:¥mïÍ©îJİ®*j‚ìmR¯æ¬&$‹íTMçCÛ{Cn¿§¢âhbæ¸„£ÅXdo‹Ô¡Ş‘1A”VvæŸŞîvÏbœ…Ì˜€İäü’ ^È“šZ¿…£’İg€öN<0¡w0Z(I‚ÏsÈ°ïí·oÖBH©–
îm/“ùÛÇqÔQ2¬Û­ª(a¤Tá@ñUrûjİBlt·Âí³–XµÖÁÑ#ÅÓ·s7½“`apT9×z'œš*éRdÄx9‹€ÓU;0sÅ`ò§ôï·w·W­ıW‚‹æ‹vÕÊÕCáb	0ÃK›ú"£Ö%â¾BhH–tº¨”j ÁmQN>ÿ‹¿`ïÑ;{ŸDEVM‘ˆ´¥#/7OÒÃÚ2kgH*ÈÏıôÛ–ÃµŞÿÙ([ßw~«ªâPênÎÓºpÓ»ĞŠ±Õé*Ñ<İU¹ÖÚİ±Á
r”Ú¹z´9^°I’`z§Šo€Ç:‚@Èu.#â0:<*#“a·÷NGTóGAHuŸRİn×YĞªKµ½µG‚vx­H²`»M_¤ |ôÒÇNuÔ´÷Şı˜’$bBí‘‚1èÙ“yÔŞÑì}5N˜òhjôn­`	QÜİ¶§àÌtÚ³>İè´¤ G@·õò÷ÉìİÓÌ®â½§d{Èóùš+: ÀéKZ)jjOCmä
ã¹ÔÛKŠ
ñŞšÒS¥!Ç^x£ ±c‰Ş=Ü/_ğg¿¬ƒŸÿÈÏìó±$‘½·ªzïâ2/Á;¨ÊŞ·[=¶I¦Q«ÒLîÁ¥zôìÆàDUıìOşèÜÏ‡Oÿ¬?Ğíïÿo>JÔN(ƒüŸ}°UILIeŸµ–=*@šîêtªªa8«s©Bº{°kŞ«×Ò>[â¹¡…%!ƒ—æÍ­Ma*ß£´çIñê0×CÚ©ªéoê8Àpt;4˜³ò"İz³#Ø¦„X¥˜ê¡Ü% ï¹e§?“HÛ+±¸=¿y+]€I1©!œ.X‹à†€÷Şk-vªÊŞV¶õÒ¢¨÷‰Kp {pïaÜÛ-Ê-j˜1€EîÙRH í.(¤™áŞQÅŸü‘ÿTæ“Íçabô{Ó¥‡iÏ­cjçBWÄ¸¿ H”ûa@«ä´9Áî”hdQöŞD}ş—|¥Û?öã?ü|Ü À¹ŠÌ7gé(3+°¤!åµ÷E±»µôO#¡;ÃèĞSdÒIÚü´Ïü@éö}ßù¡£Ö€w˜¢È;#AáRY…uéeôŠáü\¶ªF$¹íá*bƒ‹ÕŞ äQY`6vŸU¥ÑÀö(£ÈBw“(*!f2rpc§•pô‡¼èİé«–: (8™jLDàªµOÿGönïÜne8°1€;°X	çúÅë¸Aeo&Nï½{¨:^àİ­¹òl³}Á8×E{,¬ã¦¼ {ÛÃf6z*¹t5½£:¶S¥é6_–‰¯¬ªÆÅèÁ(­t¦ıî˜,aP™Qsu[œ}C'€2.‰1†‘h_Ÿ5d·“á uİãŒA£xÕ HŒ°±òË µ ‡
8nõ©ïÿì½Ov uù UÚ;ÇZñ¾Ti*Û™*BĞÛªú™ŸüáYË 2-JMßçŠüŒÏş<’û;?,ÉğŞçà4¾v¹/yğ¢":£ø¥{“tXA­5'>¨9O§ÿÒT‚ÃŞy`.Ä}*d-%qO]ò£EQÕº­—<ç=[:ezÒ‚l—Á!=Gª‘0€ÄŞÑv‰Â|_Ô¥Pºú×ìîNc[ÁZK‡
7ŠÙŒ†]¶	<IÄE~¬ƒÓ’ŠPIdVÀ¾.ú IÃÏıØçcï¶ Uu·XÔ¥kêqvöHÌ˜h–ÚtÎÔ*õ%o…Šñ6È@Uµxq+íJiT3zu¹MÉBìVæ¨À×Zè~Ä5’&`•vöPØ×ö–ªİ§§›S’LÁ0¸”D*ÇKÓƒ$Æx€ëø}ø Âüîõ‰zªûÛóÕóS'
}nU…õ8ß>ßµwA¦Ê}>N¿ÿ³>ûù¸ıäÿÁCÇaàœ>ğYŸCñ¿çÛÆW š½B4@t·Fİ£«Úép”ÖÙ{­Õ½GÉ1|"EoöÙë8àUí¤8RÍ-â´CXDÊf'™“Ğ¬ZqÈĞ£™ŞD´´ªîŞ’FfË»Å%1 ¥…`÷fH­Q&z–¤ÄsŸ),ÕÈŠ‹ÉâóÓÓbûÛ@o{¯c8cÈıîÓ3aìs‰É¾UÁ»Xï{ç¶tÜ·1’€îZWu'AG­cj•êĞªáE²³5:/jâLÑ¿=B±ƒI›$Áİ=¼¦w“Zµ¶{0â’d BŠ&ÌAÀãdÅ&5Ö»9"<@Pã4TEÛCh8W™G ÛëPÜ==2LÍ¼vI±.,g½´Ñû\k¼;O·í³ó÷àdø‚Ş«Ïcâ0ÖŒa¨¸xP¸:jÚ1ú´÷V1RÅOÿÌÏAğƒßóá8‚§œM7„Ä«
¦ØÀ`ÑF
H3ƒ‘s(÷,Õà+>T¼Êêce®å¶×èú”­¶SKB´÷ÀAÂËnáQ$Ö ­ƒØOf»ti?wogÛf¦ä·K N†s2ÅÊĞZ ©R»°ğÂêÇî7oÏéÚŒ.¢m/²´…NïáâQÒÔWï#Ö>„wOİ6§y}){7^(W•Î»g·^ˆÕÍîİ{«ãqéÈz„ºUƒë"tÁà…v…50ºÛËÌªÒ€¡«Îl4·78Ş‘z¥ô¹Ömà­‹%wjUï]ÇB{-aJÕ—\×_Å¨i¹;B;%ıíïşö)õ½›œı…$¾D,0q>ã¶×!Ÿ2›Å!«ÆñÑV÷XëÎ(ùÏúœŞû¿úïb3É>O®¢ãd©şÔ¿tg¨¥?@q)÷í¢:[IêĞ¨e`tùÛßóm‹ƒ¹„`º_#+$tÈà®5XTgXD@Òø
†äêiÕ‘£P(¡Ô»%–VÒ§M¤»cm;İCókÕ\©î=¦ªîö_øw!$ÎŞÛÀ›7óÚøÜpº?².®HIíõÃØicÖ¡bµÛ{!d4#‚”¹Œj$"k=?y·ÑˆWÕqUÅä±÷:D‚«
Y9¤á§5æqÔHÖLUÍ½QÚê×?æÿ‰ª£ÛŠÖ4ø¸vQS2ÙµÜÙÜvæÄ y{aaï½nËöŸú³_†éx9çî†j-ÁqlCE‘I°ÖyïU¡p?}ˆÜíUÕ£í’–xŒÅ<ºAÁ»j%ûoç·T|.ÀÕœƒ‚
Üí*yX9b¤AÔğö‹ÅOûÀgõÙç¾f§K¥¢;êó¿ØÒrßÿÅ7ÿÓ»UKç[¬wÜooUFÎ%#ËŞõjå¾#ÕÁ*ıÛ_øİ¦ÀÍïù®My'XUn7ç î~xÕ!º½‡C(­ 5tZÃeînUhÀÉã|¬U{7Uµ]Z5õI3ƒœÄØ¶--ò2«Ú·ÏSì@ƒ=„¬:kwPÕŞ>]ÚØUë8¸õÒ¥|ù(Æ6á'Æş0ÀÅº„C*·)å…9÷)pQë8Îís?
èø|œ™Ã:«wCOíÇ!Ñ)Ÿ§j­beå{iß·G¨±É7±±ª(ñPœzº	°Ñ§U%h6ıív§´Ñ´è»»ö¼aI5²¯Ë
æ¹§½O`[ı'ÿÌRÇüâ“şÿ©ôüÛ~ï§¬'Üß¼½Õ«3w@‹Eáqßëéx¼yóêùé~æùÕòÎıñ†&«×zuö	r©´ıÄÕû¾ÄonOïîñ2‚?ü—şäÁ:jísŒCc. ±U‹`š‚PÁ¥‡ÑÇ"iöøCŸè¿û[xŸ:
¬#üãüb’ÿí7ZxÛè1g;L¶‰ƒñ2ÕÊ5·ã¶[Ïãuç_|Ûg¸û¼ÃÛÿèK¾"»ÿî|×AÂq·$ˆÜm0½µJÔÅj!Lõî /[çÒ)yH.ïıb÷´¤WùI¬§·~İ÷“öÙ¯_­'t3{ßßPÍ}õüÜ½ß}¥ûë·ñ^ªÛ;Oâ­û|Zëàñ¸ßÕº¿ı7ÜÛ9q¾}õüî~ììöãñ¤S)Ì~´ªªBX³;‰Œ?zk•´Ö*Ÿ-ÌM<„H(Át¶q–6¢gĞèì’@¶û¨[&Y8÷Æ£ãª£¶³¯Û;KãÒÔ8ïİ/ïÔ“ÓDÀ„.ßÛã¿8]®,¢wÖ’²›¹TZU%a?ÎQúMeõÑ_ÿ7#OwïÒ¢xßÜuT§Š·÷óv[İ{?öy>ºAp²oHŞÏ7OOï<ÎÇ:VVÙ—[ÙÂ¹/ÓÊö9Ş\åÖX½bƒâî” 1(_Ûú/¿û[3Mrï‡“Iğƒ_ó}Ó§¿S¾Ÿu,vzUıÎ/ÿÈhAÄn®(÷{#}ÆDVğŸ}Ë§IÚI…7şê‡>Àøÿì—üïúVÖ ²¦úJ€¥…Õèîçú˜@Hwïskà;’}ú¸íNG:Û-çÇ*­Çy9zs>ŞŞ^=‘¶ÌR‰KKÇZ¦™ØÍcÄíx•ìu,@£`K|¦çç·o^¯5z|-–÷ÓK‘(™Vå6q\´×Ş62Oê’¤¢ÖñTÑ;Oï0–ü”ŞÑ:*~ÀÂR'¸ñ vÆ*ÒPşt[¥î6a„‹µÂé¿¡Lª&·ã…9î{Æ2âê?Ò™oA¡¤EUÜ´G#5 ‚¤îÖ 	$¤JJÌªÒãéß¾yË
òøÇş£8i¬:Ú'¥ŞûóşÏÿeq};jÌˆKëì×ènç©x?œvƒxº=õıqÔ‘tµc¶¡ò»­Uè-•İ“İdIí]Zq‹xœ/ø’¯<¨öáÏô>Ç6éÓªú½_ıÓI±¡£åo~@ïèw}ğ§QÇ?ı¦Occ¿ÂÓ[~â_øy½Z¿ô×?åû#Ï‡~÷Wıì
BìÎ?ù¦Ïˆ¤<å—¿í÷¼}Ò¹¿÷;¾c¬;Ør %^DıÔ²O&Z5¥Å€Vİ™ÒíÄûê÷“OOO
Wñ£}r­Q7¬°Ç*×Şºf³üx{û¶’ûy&ñŞûkêÆ‚OµAhH:ïçã|ÈéÔíi‚;Øá!»/VT`rœ£OOŒ6ˆí¶ñØ»§ñ£öÙ÷ó‘fx`|“Z,Â^+èâÓê79JQLŸÈ¼åİÊ›û	\Ç¶ªñÖ#Âí&t·A¬ÃÏ»‘ô¹áq‰9HÖm]ãH„¦ÁZ¥¸:¸(Ç±ÛcGæxx…;!+ÛD?Û±oO y<¯µöã¬ÛsÄşkßi•Ï‡øêGşòŸZÔİïôıúïH2ƒ¸fúÿ~£:t”í}\Çmi• `³½¥iÚ¡ZÛ{ØA“¬ÉWÕÜWğ(]ƒ%Eüü?û•»÷ÿï›?Ğ·…{G¦„½~÷Ÿÿñø§ßòY
oÏ¥oÙAÜ4´èDğv´SÒùØvnÕ¿òŸb‚ìıI_õ‘müòßøtÁİgE¿ò¡OÏøªÿùîşğ·~oƒè©`jgä_B«c,}!º=B/³}>šã¥ÒàéĞÛ}6-ÙˆÎ}¦>Ï€èòıM‚íÎ]P¨­:Šû<>Üh?éº=a? %¨Û:íí6B-ª³1$÷Ù@ÈJ_ü¶ ÜÃZ%á#Í‘¶ÏÔ]w‡gP`†JèÚoÇõÃã8ª\–İ–ªŠèĞ^·´·YÅÑÒ€l9®õx<¸×#8ÄåŞÌä×~óõ@‚„“ˆ³ê8÷®Á8Æ²(Á]kÕX¹’îÓCj‘ª'sÊ>a|ôÍÛwß÷¾èö´zıÑß\kIÇ”ãı8T§çÏúß}›îø±¯ÿ’*şø×üiğ?ş°êù¶tƒÏÍâışúX7:tXzô[QµtIòÇãz|Ï»kiôyó{İ¡pÔ±÷éøéé©³½ÍZ‹JìĞÛucvPø”¯ü¹˜ÿèCï¿Uı/û©UÚqEGáîæS!ù=î#ÊNbQuğ¿úçåüòßø@ä–æŸ~è³ÑOú÷ÿQŸü•oüÔK¤cˆ—ô‚·UU—-—7pôŸŒî;•î1kfUów©’´ïmƒÑ”®Ï·§ÇG_Oï°xÜŸ_=gOæ‰0»Ã÷½zçéc_cBG9p&kê² PzZ·Ë<¦©¿s<=ø`Õê¤TkÍ’ÂÔHÕG™wÙ‡–¥$ò~~DZAoÇÌ*ñv£]Åı¦SƒzõÃ÷£dãĞJ²MZŞNÇÛª'° 6ÒÛj`&‹êİ´ğx ÷NNv´GK¼0Ìal \ËbTªµB8\GtsD/Š’\¾‘íÕx`BH~4ÑûTá ß¾9ŸŸ%²ÂpU;?õW¾PÌgü¥¿y{÷cşğÿéûqöÿ•ºñ“õ+bî×÷y>TŠ½;ÏÇ­İZÇ˜‹z?¸ªTÛÖ…<‡ÌX!»{QÑ2.âI½Ú×‰‰"R°ûOá—&üo>ôş¯÷ÆQ7àö¾•&U‚ZÈX´I¸¥nGØ<*v¬UNßj}âŸû9-şÊ_?‹\Ì(»n¬¥‚ÎÓ·bÌ{ø«ßø½ö§|ÙWg÷~Ï·õ~ *¢v(•lx÷4pSı+&g^È ’Aªˆw^½zõô<&­†^½zzìı¸?T@|h±O Në§şî´Ñ£¼Tõî½[7ÖÜ»ŸŸn¯ß¼É`Û—•ƒòp©šLƒØ äN½Ğ$úÜS¨"ó\RUİBöæ}óé89¸ˆ[!Ø¬â#Wç¹‡ëiGäiÕnèA¦ÑpüÖCQ ÆZdáv+$§ûÕóÆ­ä¤N`'WIQâº"&.jšÛE0kW­ö¦é¸H¡F‡SU#”tœ:jéÍëÇ;¯Ş}{{0¬ÕIŒ³Sµöã¡cYõ_÷ÅŸ÷ŸüÜ_ÿ¡ÿı‡ú‰¯ûâ‚~ä?üwOëóşÚwÕºu÷ó»Ïi„íÇÔ½÷;Ïï¨*»}™îX£ëéÑãÛ ÂĞØŞs^-Ñá*½÷ŞUrñ¶´Oä®Oşêlá—şúï_K¶©õËãı¨]dÕí¿êçDÄyuÓ/ş­O^ÄT}ô5>ã?ø…ó~®Z$ÏWş¬£_ı¶OóƒUÜô¯|èıeı[_şşÅ7}š›É;Œ:":°Ï-ÕĞBá%”c2Uë=K±íŞƒî¥*sŒzZëş¯Kõöõk{"G&çĞë@ïíºnHşèø'Ú¦Ö•l*u¬ZRb·9ÌÎ>ëV<x;Àè-¾ˆr¬#P«'ÃÍ*.$(ªwU…3ç İ"ºåPëˆV3›ıP’rkµªrT†ïÅç³á ß¨wŞ}àc­0`ê¦uÃ±®tÎÜ³9(ôMÜwp‰Ç¡Z6Üng­¢\U—x`¢“¹3°X[14Aªƒ‘÷‰â(°&Ïï£¿ş›$·wâ~ì½÷yÅê³J:–.ñbĞéŸø+_T{‡ü#_ÿ½ôë¿bçvã¶ºûíÛ×Zëlyçì>çh¹º{©ÖˆŒB,=a~b:#9é‘½´=aÛöŞö¶Ã@O¼ŸÃ"_½sæR†¶Ô“Şw"cOÅî®U×İı«ßğş_ı[Ÿ5'ø&êÜ‰ë¶œç.ªÛ*î·[ƒ¹Ä‚½½İm{Â¼.P^±%ˆd³'›dÒî ¡ï8PÉ£@%´7ÀóÜÇQµêy§ÖÓD°o¹É/É‹MûzŞ“J¯#Äèİ»{< õÎ«5ÀÊéµXçyºˆ†½AnLEaUñ:ŒpI‹’ Öe:+	Év7P›š¨Š>iûìğ8ê˜ !Uè8ìÀ^º|>öéî@çNÂŞ}ªÊB-$Ö¤tÈÁ«§£)]2Ï »#DiÍ™*@1û<µGuUÑK/e©	 Øoï“.“3u«Ó†Ç¹÷£ÖQ,Äçy²VvsÕ›ÿî_ıñÿëßßŞ¯ŸÿßÿÑŸVw¸ X)pŸ;xz~Zox¬¥tG+13GK‘4z¬Éİ]Å‘qä‚¥=‹E¬À@²÷ªê³U¬Ôã¼sĞ½Cİ9€Çéa=_­jc­c	ó!‰toŒ0³\•OüÊ_4[¡Áù²r‘n]J©T‘’“ï÷ıêùÇy÷Î0çXònÚÓ²XqS”Pµ”VI³á®¢'°T`x’ïûm¿]¬§µR‹,l¬ãÆ:’6èìª‰g	^ôıßşaçöÙ;-j½ç DĞûw%÷×oµj `Â5^ÚJIºÛDåÉ°EèbÍv·êèóÜö>İİ1¹dïà`·Å:èÇSˆ¸Ûªep7k\ªåáâ. kZ¬PÄÓ±ú*œcŠ¬«j$YAğè³{##\[GáÒë7D_IDZWÌROpE¥Äİ~zºİÏ³"í+<·ÇŞ¹==}ôõo¾z~w½»Îû]£øŞçñêİ?üü¾·¿ù›ï~ìÇİï÷UËÙ?òµ_Ô*Ûùœ¿ö]GğÆûv‹|ô®:v?ÛÓŞ{ÇrMÊäã|#¬ãXœC_÷r2&puQç>ÉR-÷Xk­XÅŞ Ö­’u0§‹ÜŒ¼31ÎßñI_õó#Î(Id?NWÑ ÀÆ¯~ë§tîÇä¿Dé·ûxB6ßøÜ£6N·ªí=ù<ØtC^¡•x®}4R‚İ-á*`Ä^K Şı˜7÷··'İïoK:¯_¿~}x·Yålß^½}<nOó<*ts„G½_Ÿ{©Üw‚ŞŞ_½eû¶nwŸ–UÇñtÌ~)²Ûİİ{“pàdÿVvT‰qïİªª¥Z‡N\a]Âî8&öİz³JûŠó³‘‚ÀùÒyÜ÷³£Ê•‡Á¶İ°Áq[:iÔÓ‘ÖZ¸ØŠhùèvï¤£Bk®6¼OÇK¡ÑÇ=X·QR«ÏMÁ`ûÊ9Üûô¹ß©ãí›ûÓóóy*HÜ«8I3Äí8´÷cß«ôæqÏŞµô¹_ûá¬£§…3AŸv»Š@kİï'«Œ`#`­ênœ´0ÏŒÖáNèâ2‹ö,›}´+Æóñä´.÷¾®sõF‘½UûmÆæ,”¸q9es©Ç©0kİİZ“'‚ºñSşü/İşìşû L4K=×¹ÏŠÖ*ŸQ-×&øü|›Î|”ÂH’åëñ¤¯MàI+1N÷ÎXd•52QU.4y{çUq­soµS9ÏG§Ş—„Dk‰ëÁœñÛÉÔ qÜJ¢Äû›ûmÕíé‰Æ2gïÛqŒ¡B~ˆ²7+“¥B÷Pw»/·S_‰8¬Òc4h¯"éÑé!ªgí½U²ÇísİÈpŸ÷~.ÅÉ¶÷¹»÷ãşXOUOµEîÜ»ÂQSÎry:ªõ¬³EròˆD¹'
­m,»ÅÂxëÊşˆº^Õ)°Çüª>gcßw-õŞOµ¶û¸½J˜î®ƒ~üÈ×|	ÿıÿÇşï?¼õşÜ¯ÿngÿÄ×}	?ğußÒöùh•ÛİŞö~êµnuTìîªE°Ï^71²{­ÕÛĞt›Rùsn¬ÒãqR+ŒÓõD¶nã<{.pMÑí–$¥'_1İ# ù'ßúş£Ie_­EñŞ~'ŸüÅ!BéL~ÿŸûÈãíã—¾å³Õä¡z*ì-÷Êp?s²ÁÛ[Z»Ïd(JÕXã¬µÖDßM–ÆªÅ	“è}‰å' ¤Obk¡1u‡r×RÑsó(	OŸğÛè/ş±C¢Öıõ»÷yZ:ĞIûwŸ“Ü^¡ªT‹z¼}ûvßS·M;^ë˜Êa–ÒäP¶“z©¬=´/É‚QQµjw+ UCñRn«Âj ê
L¬QµmrdQN:İ÷ì	p+áSrG&õ[ªäÑÈ:n7toİ½Ï&úx:péd±}>ëÊ	GTÒ"M¾@›€’MÂ{Ç»¼ø„tçq—1YF|{õ¾W¯ŞñŞ·­ãmïûã‘œg×íÕSİ¤ËdSÿq¿øù‹DŞ}uŞïŸğ)Ÿ]«~ôk?øc_ûµq™<î÷U·ÅÔq«„ûí¤Ê{JˆI¤¥1Ã‡¬UëênL£16ÛmB·£/êá‰¬‘ô,ÆîlJ¨PäÎ*x´õÉZäÜ)ä>{l“¿ò¡Ïü'ßôÙç}“#.5nÏG!~Ì|´ÛáÓs^µŞ>ÎÉC7‚¼¤¢l÷RU•¤½Ö
W©&šì2Q»û¸=×t— 7ıµG÷º­§ãÉö;OOFqo>š•ŞIDm÷¯ı«òoşñOc?ŞùØßö©ÿËÿô÷~Åÿ6Ÿ¤¼MÕq;XŠÂ­¸o=Òy4¬crŒİ‰Ç¼8
Ø€4z”6 Ö± ¾İ=uŒ‰·ÍÀ‹ØZH©,ÍìÍó­œÀµ<8ÔÙi¥owÈ®5×tÂ½A$.Ô
ÅB7Œû}Ã5ñD·Û!jÌP‚`i2[öš­ë-å’ŸuŒ†Íà•ï€¨U·¤ß¼ŞÏ7•øæÍkÕ„Ézïñ¹oÏ¯öÙø?ş0Ÿ_ığ×ü™_şÏÿò¿óŸıÄù¯ÿ?ºóş?ö?ù#ù—?òƒÿà/ÿ{Üøwş“ï+®Ç¹¹ªßì~*<NO Ö±8ƒ` k(§…İ\*Ö\ef®ˆe•>ª`Zı¸ïç[õİ¨üâÿãSğêé“¿ú'ã§_ú/~/Ãßı¿Ğı¨£Jìí³]àïùâŸ¨6nÕŞíãY	¶É€K·Ä¿úMï_ûx+ŸúU¿dçŸ~ø9;´÷±
n÷Şçyª´7WÕcïÛZC%`ÚqÌFF&¾>W>æÌDaâŠâÉèÂz~îç£îûÔqÜ–rÕª Ù8ÏÇ$tôıÒÒñCñs~ûç~ÁB~çÿ7ÿÃ?şåEQ…fw·Ûmäí›7ë¸U-Pûíƒ·¯\,^Gk™Fr.}ÕT Öî]Q(Ãıtk;OOëfQ¥İ>œçíX™-­:®h CÅë¨­WM¨Ö!7œº¹!±{‡»º³VH(ŒèÇn“ÛQ}Ç+v^RŸ[KmONÙD73>¤±¦{4ú2~<ªÓµj'N^ÿÆo|ìÇ}\±ÏÇãbh…N+EŞ´2²(•şÁ¯ığÓñê~íçÿçÿ?ÿşå¿ş±}¼¹ÿ®ÿÙ_øoÿÎ7…y{Şß9ŞÚL!îôöÃnÕ±–ön3
GêÃ+ra [ªä}E|áJÕˆ‘¾ë[¾ùévûü"ÚÿøŞ¿Š*Ş¤*µh½£ NW­ÉsğKê„D{…àv¬½7 ~Ü¥"ı¿ùı
£ÚçƒÖztg£Ä½ƒÅs÷ïı×ßşîoWqïsô{¸0LBõÅ9êĞ•ø0Ã?$mw·¯Lq){—Êyğ±÷ñGKHój"àª£¤$·U×’Ş«éùÕÓãü 4¾ïßı|ÂøÜµ„Z«FÌŞ½°´øÍıñæoÏåÀÑCPÇs05L@Ï}À»K‹¸ËÌM¤¹Ö£7{:ˆ÷ıú_ß33g® Lñi¾ä§¦¢Êö9ÒQVIÜÖb.Æ½x<åÅ:ªN½Q\b•úq¿ãòıb8z&m¤cG\#"RÈ5ì9ÒœhL°÷Y/&º·¯ÓµÖ{çùùÕ>¶Uëá^uĞÒÁ7ï}¼z÷şÕï|%şƒ¯ù‚ïşüOøßşÿıõŸùQ$n÷ıäTWOï<gÈ–dëØ&Æn6|"q®øäFæ´{kÄ¥	Tìï>Ï~z*·£õ‹ßğûnkıÛ_ú3Ç«õ«ëı^zbü@J-òWşÂnüó¿Ÿæ~ãã)¿ë«~¡ˆ_ıæß¿>¾}³]­Rôo}ÙG„ü‹ïü>tî]OBÛo›rûq.ilÉÁòEb`~k|Ü&½·ÇŒ<VtPš¨"F16¯W·cù1–˜G‰ıõ_;ïw"{ŸEúíkWìî“o_´V¥M˜·''I~ğ?áö	¿Ã@•^½û±O¯Ş½O¯^½ót[çÛ³óqŸrßLŸ`$N
4Œ.•0ô„#æé¸óPF­5Ë<İ®™‚–®bUuúé©l¥è~?6¯Qsİ©‰eMpxOWu -
Öñ|#£;u Ÿê3»wzŒ³¦—¬Ûqƒğ8w‰{÷*îİ¸üZW°€¬ª½”³ÉQAË„;3njbjE&çÃ+ÁöE=Îû«wŞ9ûKÊİít±ß*ÖmrÑŠLïÏı«ßµVıĞ×|şßÿ_ÿ!ÂXu?Ïwê¸¿m’×·oZ7ÚH´Ö>Ïµnèi;W4Mú2K,n{a]KÇ»¿çÛ?$Ö'}á—/ó?ô©MA©]¿ô×?R¿çË~FÏëÍë7…úçßñYéÌd–Ç†Ü"y“íû›íp‘­dç“¾øç¹0Ã1şÑßüŒ*fÉªÅOùª_x³÷ßûşïêîö9¦w›GçéµV0–ùçIWu^²Jƒ	sfØÉª©ƒ.ÅÂ\ªÇ!OĞ)V!4šM˜nï5$¾yıÎŞµ…ç~è¸ávğ˜ˆ2^Åó<¹Êğ~<:Üaìsü@­ås_1FFI»‡œ®’zïN*iï™g"
¹CUp,
¹ûdØovMœÖWó&Ú¯ãÕq2KK¨ªzz&…mÃn÷ºvÜR[Dá¸­¥uSêª†lß;~Z5JÚ€İ¦htàcÕîW:Ç!ÊŸü‡ÿ54¶/ôÄ”LY3Q\njıÉ/ø’v¥Ÿò¿úÏî}ı;>ë3ßşÆ¯???ïn°îo^¯–òôğıĞóí¦ıHÊ²ß¾}ÜÖêø}û1÷·"6À>àm­sŸeÙ»§Y~~î³èkşÌøî-ã9JG‡öc‹di¶FŸâvs:Ş±‹N™1x`Üù÷>øÅ<ÿæ›ß¿w®Ä{HÜ»ŠÒ'~ÅÏîíCªU5zN£VÎæ•İİ#Úÿô›>u»j-spféôïüó¿àì¿û}ßa#½1I Ûµ–Ó˜P/Ïşî/Ò!€mïës‡Å }Å“¼@à½ÛÍ·¯ß¼z÷İÜïu{2	¬E”Ä¬µğ´n¢ß~ô£î·o~ı7©õî;·–şÆ¯ıÚcŸ;½ï÷NpúşæõûÜ½ŸnëVKÇÙ{F.A¸­ÛxGË Vq¤ÑC¹¯3Úr¢Fğ’	@%Ûıôt”pïè`‚ã £*XöÁZk•êñ8'·{ûŠ1sRZÈyÒò¹²™S0äTÉÛ'û@/ÃgĞ/÷m;Æø‘0)`Ù,ogÙÇne:–j£!*eok­UÚ÷}¾}ıšü×?ı3“2ğüôêöêéìö£W¡w¿zçé<±÷\ÿjr@åó~ÿ˜ıøîDoïÇéøéwÎó„óüôü/ß¼~ßÇ}¼}îÇıñØ@“ºß÷:”I5öœib¨DYW\‘q%f¬¥që±f¾¹
…úŞïúöó||Ê¥[¿úŸnk|4(î“¿ü7?C9¡!ìÙF¥N€M¬pãJ;*¸‰ÈÁ~ôïşêŸGóï~ÿwÂÛŒ»UlRLÚ(é wŸ(¹w5ÙA“à«+ñ¦'ˆlFÑL*ÅDK·Ò­ôêùÕoûm¿J)íûış›¿AøÍıí»û.w@c·óx:êí>»û¸}†ºô£Z¥[µ;;}nU=Î·¯Ş÷Î~¼şõó›oŞÜ+×H¿ÛíĞTÎÛp°®Ô§¶]Æ&öuEÌÅÑ»	•êjèQ‡Ô{«Œ&½^ùş8‰µ˜@˜=Ó‚trç5ÜµÁ|äv[i&ğK´b?¥íÜ›Ô¬íô% Çzv—Ö
jBé¥âyîZ…#!u^ÒO0C/9‡¼óÏÿæ_êÍõ¤:ät™-VÎS…ÿÎUÂ5aÀµAØ'MüfeX6»ªè<ïkİfDÕêäÑ÷¥CÄ8Í÷¹µÊ<šŒErw$j´\µÈZûq^jD…>#ÂÛßûáoßûíïüÒŸİ·ZàŸı­ßïÁ—–nÇ{ƒ¨¥¾c©‰‘÷y¢j¿ñ§şãí:¾÷Ãß,bŸ½ÖbQÉ$Mˆe‘î"U…rŸm´Ü¾=-8„k©£Zënªè[Ó¡–ÒQÜ§ÍûÁbÔßP‚…E”HvnÇÌİ›ÇBÖ²E­ã˜ô»Tİ&Èc"Æ+.-{ƒ¤”\:¯™>JiæY3™`Ìİ;ç®¥vÇ^«ÒMM+[Çò«ãö®%çÂ]ŸZµáìG¯šÙ†•Éóˆö‰Û*€Ü8$Õ;ï{wœ©ªª£&‘rEL>Å˜ı}èeöF UZÅÉ‚övÇ‹JÂªt+8İDMÔrñ®P5vbú*6&å7s‡ç|Ü—ØœÌka6ÂôuÊô \²X†×Óónë7ş?Ÿ#ñ±Ö|ù_Hûş¸Oë{¾å›TK×é>B¨ñ©¾7SãÊÊr¼jÍ,…Åhb¥ò-ßü7V‘T=}ò¿°nÅ{?†¥¢oBŒ×ÒÙJºÖôxœë	«ó:xúÎoû†u31ôv¬öA7ÁjÎ¦ÂHA]cqh:'®œ`X¢ú·â” øJGKØ»k ¦†µ”â¸<ü:#Ÿvéšµ›Ä±`†m4‡ A/q_>¥ês aÆM!S¥>P=??‘Eá~î·oï°Uå·¹r`=“ŸæteIxIÎ¯ñëwˆy²&xÌ×”ÉÒ»¯`<zSM
á—´a4
YûÒ¬­d§YØ3ÉÙ·ÛÀ:j'#e¤sö&RkH?o©jòk&Á´ `ó'~èï])LÌUsÈ¡4–ÜÉíHg{‰‘÷ÇhÖW±ƒ›Ôİë¨ıØòsÚ¥
‰àX`ÄöyhİwÏ^L\XÃµdİö~ç¨u¿ß?ÿ‹¾Òä/üüÏˆú´|ö±ôİßözyä“JpÚ5ÖªvWUï½tPñÈœÛ¥ÚŞäÉ #©#œmT¥72ƒ½wPâğª§Ç¾W .X<÷É ·Ÿ5E“Â8ÌÅ
ü^ ;NÎ=qF-Ú¡gÌ#„+ÿ2c˜IhÆêdkaŸí¤8ò|–f(+ŸÅôHq×@wÄŞM•Tn+é’‡ªr>‚ÎŞŠ*(qt7ªò¾/é8ÖîèXëù¹Ö1ePöù8ï‹šyzİíÎv*WÎ4‰º†ˆ¬Ó»~ÙÔ$fT30•‰ùÉÌõàAV­Û¡"×±JÁš>¢¼=âokù
•s<»Ü×ÓŸ¸ši«4F{o(íín¯¢G¨Ì}Í9O ™?Wötº½÷Ì/Á5”jÆ¾]íh÷h2ŠÛ3›3­ÖĞäĞøŠŸ›±ÚíyîsÊÏî?óg¿ÔáG~æÇ‰IZµÖ)ÍÒÊøÖóå™‡¶Œkö‘Àñ·ì=Ã€"Cª»ï_ğ…_Ùî@k¨~<şÎ~ŒUÜ;”½ƒdÉ•ğ+bŸ^µx=så‚‘„mëJFÈK¦260Î	ˆ ¥
LHİkÉğÄİgFŒRJ½1“gqæÂI&†“jÌà)Ö*»=“ñÜX/Q—}¼n¿%ÇQÅèÓŸfRÚ6êhH¥5C$gŞ¬@B½O	¥jÇ°ªÚÜç¾¤ I`á¬£º{]Ly>nPAëv\åõíöD£Ó½[—»F«d;JU‰Ü¶“š€o)HM4IØ0â±ùOğê¼{û…³³{ªşëó½Ä}ÚJ­+×¬71©‰xÉÕ»èØ×ÇF1Y7ˆ%Íğ™LUó‰9SÅF¾9y8ãÉ™ô¯Ißà/spLšÂŞv>øå_åÆ?şÈÏ´³÷xK{¾À¹ÛÁvÇñ87²µª²&—âøòÅB	 " ¨Ä@µ³J?ıc?´ÏşÌ?ü?½Éí–Ö0a3çlÇ”–®	b…¼à%qÒY f{“kh©ª&G£…˜ñª÷Ç9QO ŠõØç€*’F—HgÍ/Ó¦µ,ÍP—É›b“éF2ƒC†´i›Nu˜œYIr)›GFØé¹	‘IcYµU·£LÎL¡ííl–i¥ÈíX{ŸûÜç~hU/#İ«†ÈEV­u(É³Ïz/å=8ÏûíeÈÜz^ákş^ê%D˜ÅcÜ©5HÄV1«f~†‘+
˜ÓØ\S0:× Ñ9©F¸ç8pgÍ®¥V‘X»w‘Â3«pÕ=¸"’4²Jí”êâ^œqÂÏ·[¬µfÒ]u .Üe$˜Ó_L.híş3_ôa~ö§~İ“FwîğfM$ğ'¾ğËoB7N÷­ª'‡wŸ‡ˆ*®U³ÏqÕ¤«Ip:Uúÿ¿:[€Ş.Õã’ëô&VîŞŸÖ\sàª¥J°ãÃ3İë>{I‘é1óš`Ñiáš{3ããgPÓÒ1èó"à—A®k‘AúªL’Ti`…$»›ˆQ3Y2Ô5ÏW3âqö1Ïóæ¿Ûîf#ÁZÚ6Å-ÄCGéºkY´ûX«fj+“ZC•’ù´(g«YªqÄÊbE¥ö’˜UÄµ–İûñïsáj¸a^q·İÉ<×æ¤+p†´\‘)«K3ÑZkïSUî=Ê7Îpf±ÂàJl¹ƒÄAàB\¼¥w¦gém•–êJ,AzÆ[ìÍiú¥´§´í„à&63K¦ÒÌ[è9æ!hiÏô¨¨f Ê¡ô§¾ğËü8îgjé
H¢®‰ÊWrbø“?şöéUd÷^µTWé¹;,Èkû˜ZŞ'0pE4¬™¦.œg+×tEÇ1šCU3™ÑÄĞØFE
Ğ¡İ´Ü¸¼¦N`×Œ£j›U3ÔuÖÔÌ¥mO*Ñ\ì	‡D.éŞg¦†$¤1İn·­#ŞL¸Hk§k§Vç)®Éú›H´ìİ8Ša.SÑŠ£5)AkÍlÔÉš&î¦º˜›œB·õ2+y|
Ì¾ÏO·Ë£?‘‰Ä5ÀÂÏóÈsÜë&^5ñÖ™0¡C$Öö¾>À„œ…*Ú®E7.õ]@É=Ğ3ê’˜^{ãCÒc|TÈ¥î ¤1½)®¤Wf`cİVÉ&¸Xòn-¤}ÉUcTYkµ÷6„RÎ"Åİ½ÖÍé•uú,‰¬îÍ‚·)J5yU•îH«èî*íN²­ vÇ‡¾AÅÏşœ?r¬õş_wŒ>ù?ãÊZa«E6€=3î;6®a§Ûá„_LeR¬)ånĞŸ÷GÿØ>ßûmßhhQVbÃØvUU©»qE_)êóÃj•”6À,Ê¼fÓ”ÅWJ¸®œ9@§)1×\Ÿ0çİªš´>b-BTM1{$ºJ¡³·È™I‘4&^è´ £Ç$íŞzoÔ6²ÏÇ€B¶ûjÈgVÏğE»¨ˆ™S·¤c=î÷·oîÇZ%ÎtyÇ"«Ø3{ïÜ/0:™¬ÛÑáì¡Şçä1¨uÀ9÷9åƒ°z–1Ñ¨uãy?·s{z¥+€Q!j­ym³4õÅ"ørHs·EÔ8¡g h_Ó•Æúğ’%;WƒVÌL/HäOüĞß›—«€Ø}8ÍÁM Lç9bœ¸U+™€ä8Ú–òef'×*;¥1ŒÈT/@V­Ó½cøşà—|õÙ½ ?û?Z«’ô©ŸùÙê8»oï¼ÓûŒ½Æfµ·{øˆ±Cùt­e¸„=©ç\?ø=†Ø÷ûØ~ÏÓÇí˜EN)ïI›*×6‚oBq0DR½î2recÊCN^xÆÅâŠ	œŒø
;ÈS²€˜³5É<¤T¾¹¾* )/_¢f/ÕKö4Ë¸¦¯êj†`KïDç“#ÅÎyµœ^š™Ë:uÅ‹äQGs{o„d…5©”#sg$İ%•½÷q[sˆÔe8 ûÌÆx¾@®uà8ßÇ¤F‡qî^Å>»Ö‰÷™ª's¶ã^ÇÑEQâp_X;§´Ú-Õ|g<¦UùÉú»¤Õû1¡¼Ş=1æ#bÙ{S¦ö·ŞÊ^2´ê	¯µ'ûvŸªc÷)êXkwCd‡u%ğÎÈ*‚ƒ{ÇDq?ú‹ÿÜ{»õK¿ğS ?ı3?ó¶¾åoıkqª½·oß¬u{œ'¥µX,İ[¬µ¸sÑOÇ­_²ÆÏÇyÁq[µj$èI—êR‚Hv¿À›$Åº~†p­™=%u–ö¾‚fğg|Í¹Õœ•¹R±Äk#"£¹§íQ|Œé‡¤w^âÀ_NAT8dŒ{7ÇÏ««Kïı|ÜÖ¿“†'åĞë+árX$Zd5"C´t¨L';Fñˆğî»Oî«×øØ÷½/âí,Rİ^«ºûöôÊ¸R©ëâÆt›U¯opL-¢'¿<¨dƒKæ3aÏ`	ˆÀ³7¯Q Ğ®’
aœ9¯Á5ÒPıÉˆ:8¡‘ÉT">Ãñ"kòöÚ^KSaÁfÜ§Y$Ÿ¸Ìä×*Q‘EQÙ=Š‹F|FÒcSu'G¼­š›b¡T‰ÁŞqÕñ½ßñM!KëÜıéŸù‡>=ûıš0ó±4HY«¦ßáåØ¬ì+)µ¸8¹PÀŒ„l H÷£Xµ†J<ğ2é|âÿ/HÜFÕ¤e^ïÔßÌµ2ÍËRŒÍ_Ws3¡áÊè¼j€ãI' ,E¸*õéŠ±»÷–Ö÷™¹“ğRã-”s÷àáço‘š0FJ×5O‘—‘á2Ã§İöÈŒûvpÕí¶Ö>÷Ó:ˆË0{Iø%;i¾°pFÖLæF0·Ú¸..éĞŒ%ºÚÒp¦t xqïînr<£ã¸/zÜí„ïNÇ½‰iz•KoÂ\ó|4fã…‹EW‘"şøÿ½zd9Õj˜â%úeJÙ{ØHŠÚ®QÏ[˜\³ØçÕÔq¤÷Ë¢U×è•ı8«fªM_“ü¦,o ³©Õ<óÎ€×÷ûâ€ø v—xÀ^l¤‚…wÂa°“t¯cí6‘Ş¾ÚÑn»F#ãŠtBµè³QWü1İø÷~Ë«€ÀjÎ*Ç,3¿HH_ó]æäOR2M š\Úmöø¿®Ï¼ÊĞ	l÷?£–Òa)—Ù#‚È=oB×$³—É™3%•#æy?@Ô¤ÃÍc·ÇÖÖ±Ÿc-©
(§G(3Ã.%=+Şø¥ˆv‹ÔQ×ò.ÖU`Ï
Ï0¿Äxyq8 Ü¾ |8»ÑûÄÈ’RaĞwÎ„› „­c­ª0œÊ¡	Ò¹ó ³¨RéŞÇmQ@P/s¬ˆk*7ô[”Â0áÓİÌµú[ó(g¢± ˜åöš~Õİ&Š,bäá
üôêé:L;+@Is=Ô…³®ZqUŠg²ÌZ%MûÁ¾$&¨ZápPD’mÃ3ÖS§_†…Íğ‡¥p²Y '×;kzİ†]Uä5³¾¯ğØ‹Â½âû‘tÇ`˜"@5‰ñÕj‘Pu[*ı`²Tî=çÔ¯&%yY¯WUu%yOÀûŞNFá‚»jLgu9)vûR0Rt65Î+ì˜+&ğ`Mjˆ’,j¿3§/ŒÁ¹r¡fLI:‡$%gFšfïæäÀD=‘«³åÅã¦³/vÒ \†;&Pµ	,ÖlÇ¬šãwÄT“e´®qv“}×*ùŒ1üšth¸“«+rß¹®°{s¢Û¥åxğeÏØl¾8°z{ÎıÄ‰J”XQ©¹2:Jkö9GÕl3Ø@ÎL/¸fÛî)4F	*£ÓsìôF¤š‘!ƒC{ï8Ç:–®i@@E1ÈRõŞãûy0†›‰0¬ªk„Û3Wy+œÁ=¸2—¦Aà±bi)v¼G‹ê˜$M*Â°{óeÊ•¤±éI
†½w-Fz(÷íÆ¨ª˜‹îÓ¤½á'NvÒÜfÀ^&ËQ4’Î`ññ˜£ÁG§¯·jÏ+‰gæÎ±Í,z^Í®È0$Ôz‘Ÿu^ë6ŒQÖÄC`ï--5ö•M3(ŒTç5wô"˜=7Ñ»]pi 1 ĞŒÛ¬ÑÄ]}>H.±Xša­öÔº¾ †€‡ÌHr†¤ŠÚ#qEuŒ9fU5@â8îÜª¹ÈÑ.RÃ÷;zI`œ­O Ûİ.	¡gXÆïQi&›‚¸º’©ÒuŒš¢Èİ£<l±J¥ÊüŞÄš8í9Şëw&{ÏA:{šŒdÂâ^¤™~¢µj¦-LF»³F!á:‚r!-ãÛE2so¨‘µyUÄ]¬æLAFw:¿$F\{_±¬¢ä©Üv¶›
nk\éïša{÷\×ÜO qk¬Iœ¹¨×$ÙMâŠSeÍH6O¶àÔ=BƒKœ ›í¾J g"0£yAÌ­G`UMu_(Aà€X5êÒiü]ri®jÏó˜®à¨ºÀŒ”0ÌË8±ecäzy[kŞ(5N‹Ìú~	ÅšØÿiAN‚.]NOõ¦*^İÉˆº×’öŞ	HT- ë8Vİ¸&ÉøEj©BÀši’=è$jLs#s¶yş±—ç:¹ ˜Ñó§¨B¤ˆåÄ½àt!Hz7fîhâü¯„Ñ}NÓƒô@ëU5êr4 FH•pB{zM ÌdE^ÈLaÆÍW8Îœe“•\£Çõ<é\èã é,äËR+áP•^Ê$s:=âÍÙ»7®x)@ f÷è#¦‰/d{UM—Œo4/‘¤U“†Êä ’&V)™äüºc÷†ôˆŒ¨\‡Õñå$µ®X¡)‡KŸšfjÄ\q+S8áe–ùÕ·ÏYuUkP4}Ñ)béúÊ¹zGFyïZ×˜¡«œO±fçÍ›b.×12#i‰Eœé5tğ@—yAØ½5Ä9ûñèİ›¥±>Íxb#3nïM÷UÇŠã'¯Ñ{f²'ùë4³1&®k/Ø/IÜûÜkJHe~Æ¤QZS¬ñ0Eé‹_„ª
@hZøY%îØ6A^<?píf¤Çg1ƒ_‘v(#=mÅxCŠÀ¥~8»öšt.„3{f:éëÁ(Í8#Ï2Àæ÷s¯y·;Ó˜_ …aó „Fê%²Öl®é,aãvÜ&àjÒV!¯wOÕˆ·êz=#ÛÉŞO¼–ˆÇ¦	prˆ/+X`¥ÖAÍÊbf§izóJ²Û%Nõ¥Ğ†']—BGÕ{ºÌ½·ƒ}îÉI¼€È•l­CŒ<È‹Â/^ÔyÿMNc:İ	Ÿé‚étz¨ywgPåñ³Í©&³Æ!nàL:qäÜA{ºı=LÔåŞŸoëó|LìJw#í¾rFcXU¾V-rQ4œëäjyáB¤:ã"³'Oj•înÃ3§|äLÃÃ3•jDª£Ÿìœyn¶Ax»ê6`mUa¦u±˜–™˜“^ÙÔsôw[¬N×jfÕ2³T™ûÆPˆ«
)”Ú°hFOG¢ìvHœ=Sw¥«'œï5iu8²P…‰×Ü8ó"aä•„Ô:VŒªr€Bî8îÆ„ö^ñÔ°=¹ñS";Yª!Û¯ñIÄQ!2c¸¹>ê:µÉ)<¶û¨Ky±q­QÓlï ~aù[ïĞz|ƒz`M	>êÎÖ}ß—7‰§ò™G7‘%Ø=Ê¡8#‹QÀ4âäºZ(`(5+¯&éôm~”¸ŠT£Ø[3èĞ˜.æŠ
şs{áõØíÁf¯Qä%{¿Ì›Æ’ífz¦ã%xGÂ5·mĞsÁ¥š¶!pUåóˆ«tHI¯¹yçtä¤•¥½oÎ%AiëBú‚.Ägúåú“–$Õ¬cª„8ø’óBZñ§°§­‹×9æy
Š-Ö°ÆáåÌ:Šƒ•OwVXâñ’¡¯@‘LIè!µ‘Aq¦ÄdiÖÈ$2™2 Y/V	di…\U/ÇÍìPsĞ!¾°P&;a	àŒL‘Œée"2:íK5P'.áäÜó¶]EI&{ægS³½IÕS;Â¡x2ØSAÅ=bdGCH1½¯Î©Ç–À™rM8ËH¤8äå_s)¸RešSU»7ƒWàPAŠ—3´dıI¶k”Ä>IIgì…ú! âvg8G£Ã˜k:=s‰¦dé}Ep
&$…º†c,hS§Àí‘K	Ò—J’š¼ ¼ç³ )´¯¢òJãUóÏÑ$"­	‹ŞŒ&‘‘xÚ½Î€,ÌËJõÂï6 Û‰q¥èKWg«IºŸ«ÊÎ1‚é¹e½F€*†QBŒzw^†·‘¹µF¯XÊHİ–N?4jõéõçn"ÑV-ÕêATÈmÆ5èPvo{7G>c fª«Ç)—	‹¢·ó3Eµ=­ÆT½ ø»w-ŠòEa%ÙØ›¸ôâ‰v_£?F«x­^bDyœ>g’×£Zš\ÓQ\#}‚šlªİ±:¥U2áB5z6;IØÊ´qu~SÄifür°»Qi÷L(ØöŒááŒˆ¹Ğç’à’×Jr>î"¯ø"è¨Ò{S%\$„ŠÉüÇa
ˆ`Iï?Sv1,^ÅÅ¥&¸Öu|ãÅgx!+Õ¨m¸„%u2Ú,Ä×`4f?Ú´.Ëqc¿AfŠCÛ\£œ‡|V2’®›"$4©øÒÀ‡‚Ö1#w:¸r„Ò½»£d±qå}o’8{ô`V”ÃA»/šn¬[ªºÜK#ğĞˆ¶c™3­6xİcÜ©Zš2q–IØÀjxe&Äb”ä#AÜİWÛ8Â'±2¦miäÒ`åêF&Â‹€ìíZë¨¶ËÛ;EJ5qÔ0æ Í¶ûz[¥Ê8OÛãòmş
Í&¸êš¤9Ğ -àÜØa·={ƒ•ŒrxĞHÈ¸SsÁSÓHYÍKÕÔRu_¤+IC’f”p•û’ƒ$—ydVn¿\fÔ‹‚†¥Q±AL)dÒ&vïøÜ£†Ğm»¯`Z‰•	W<Öh5N„İ/aAIúšË–D#	€r¤½O85ÍÔU OáÀå …ÙãE(û=x¦zÁ5øÅ$©V]×™ >â|‹Ó®iQï¶ùMÓİµÖP¯óƒfú÷¶C³È¨Æ	©¸3 u«xi`fî/l÷¯•¦§ÿ··D¼¨ÕªÁb%²0¬Ş^G07#LJDqï&¯”‘«!‚qÆ²Në‡,Í(qC–Àİ»s¡£v{TÍ”3:ı-Ö$—^×üÈIÕ¾×¡ëîÌvÀ ÿ3d20¦O&Úz¹¦ÆÊJ®EÍ…¤Òºæš#nx²Ln;ñªÂÕ`bÈ¤½O¾X.: S½¡(•Ü¹®Üàœ>©…rû%urÚ1˜éQIhj²"jiŸ[°H¤³s;ªİ`æÈA.;Tí³}ö¥œè	«Ô°c½¡Òu³^¬ˆ¯°ÂšÃ„;pİóô¥n©ÚWÛÁà+Ô)ÊŞ;SÖUÈu…<‡ØÔä67¦¿óäÄ(»İÃl"°÷ãL7Šİíx+×ˆ!Úá…nN×\6_Kçâ‘'>G¼?"´ˆ4k±£AÆuéÿ¯È›„Á].v
*pÌ0²GklOk=èNİjĞP)2˜e¿·Œ†q%Ç§ ªNH#Üg‹â¸§Å¾ªÄbM>D÷îİñ…ˆ£ÔÃ!gïŒÇÏ˜7dÔ ä×¬é±UÄK@.*ÌV	µ–¤	´ªV­ã<ÑƒúE¬PëÀ<IàÈ¢‰böT—v/ªæ\§OO–5¡€4ã>•s‚0q¥"h@÷%­3Î¯âì&Å*å½j¦¦N¯ Ìú.t5'|Mü‹$w»JWá%ã¡Á`Pe†óÌ;ÉşæBƒa§¹‡ã#­Â—ÔzN›¬R’¶§ä`òŞoã0åÁÀCdcÀ€PdöÅšRR`IÒ"ı#3Á¹ï VÍ™zéßjÄ­t§“	Ÿ1wäWD&µOëT¥ªëG“Õw|ÍOñâÒ1ZÎáö§lvŞØ»%ô Û!†ıÿŠáx›Çµ    IEND®B`‚-e 

==============================================================

-e FILE: src/app/globals.css

-e ==============================================================

/* src/app/globals.css */

/* Define Win98 Color Palette as CSS Variables */
:root {
  --win98-gray: #C0C0C0;
  --win98-blue: #000080;
  --win98-white: #FFFFFF;
  --win98-black: #000000;
  --win98-dark-gray: #808080;
  --win98-light-gray: #DFDFDF;

  /* Define primary font */
  --font-primary: Tahoma, Verdana, sans-serif;
}

/* Basic Reset and Body Styles */
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  background-color: var(--win98-gray);
  color: var(--win98-black);
  font-family: var(--font-windows), Tahoma, Verdana, sans-serif;
  font-size: 12px; /* Typical Win98 font size */

  /* Optional: Disable anti-aliasing for sharper pixel look (can be inconsistent) */
  /* font-smooth: never; */
  /* -webkit-font-smoothing: none; */
  /* -moz-osx-font-smoothing: grayscale; */
}

a {
  color: inherit;
  text-decoration: none;
}

button,
input,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
}

/* Basic button reset */
button {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  color: inherit;
}

/* Basic input reset */
input {
  border: none;
  background-image: none;
  background-color: transparent;
  -webkit-box-shadow: none;
  -moz-box-shadow: none;
  box-shadow: none;
  outline: none;
}

/* Disable number input spinners */
input[type=number] {
  -moz-appearance: textfield;
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
-e 

==============================================================

-e FILE: src/app/layout.tsx

-e ==============================================================

import localFont from 'next/font/local';
import type { Metadata } from "next";
import { Analytics } from "@vercel/analytics/react";
import "./globals.css";
import Layout from "@/components/Layout";
import { Providers } from "./providers";

export const metadata: Metadata = {
  title: "RunesSwap.app",
  description: "Bitcoin Runes Swap Platform",
};

// Configure the custom font
const windowsFont = localFont({
  src: '../../public/fonts/WindowsRegular.ttf',
  display: 'swap',
  variable: '--font-windows',
});

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className={windowsFont.variable}>
      <body>
        <Providers>
          <Layout>{children}</Layout>
          <Analytics />
        </Providers>
      </body>
    </html>
  );
}
-e 

==============================================================

-e FILE: src/app/page.module.css

-e ==============================================================

/* src/app/page.module.css */

.mainContainer {
  padding: 1rem;
  /* Add any overall container styles if needed */
}

/* Alpha version disclaimer */
.disclaimer {
  background-color: #ffffcc; /* Light yellow background */
  border: 2px solid #ff9900; /* Orange border */
  color: #cc3300; /* Dark red text */
  text-align: center;
  padding: 0.5rem;
  margin-bottom: 1rem;
  font-weight: bold;
  box-shadow: inset -1px -1px 0px var(--win98-black), inset 1px 1px 0px var(--win98-white);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.warningIcon {
  width: 16px;
  height: 16px;
}

/* --- New Header Styles --- */
.headerContainer {
  display: flex;
  justify-content: space-between; /* Pushes tabs left, button right */
  align-items: flex-end; /* Align items to the bottom */
  margin-bottom: 1rem; /* Space below the header */
  /* Add a bottom border maybe? */
  /* border-bottom: 2px solid var(--win98-dark-gray); */
  /* padding-bottom: 0.5rem; */
}

.tabsInHeader {
  display: flex;
  /* Add styles for the group of tabs */
}

/* Style for individual tab buttons in the page header */
.pageTabButton {
  padding: 0.5rem 1rem;
  background-color: var(--win98-gray);
  /* Use standard Win98 button border */
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  /* Remove tab-specific styles */
  /* border-bottom: none; */ 
  /* margin-right: 2px; */ /* Keep margin */
  margin-right: 2px;
  position: relative;
  /* bottom: -2px; */ /* Remove lift */
  font-weight: bold;
  color: var(--win98-black);
  /* border-top-left-radius: 3px; */ /* Remove radius */
  /* border-top-right-radius: 3px; */ /* Remove radius */
  
  /* Reuse Win98 button shadow - Might need adjustment if border changes */
  box-shadow: inset -1px -1px 0px var(--win98-black), inset 1px 1px 0px var(--win98-white), inset -2px -2px 0px var(--win98-dark-gray), inset 2px 2px 0px var(--win98-light-gray);
}

.pageTabButton:hover {
  background-color: var(--win98-light-gray);
}

.pageTabButton:active {
  /* Standard button active state */
  background-color: var(--win98-gray); /* Keep gray */
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  box-shadow: none; /* Remove shadow on press */
  /* Add slight padding adjustment for press effect */
  padding-top: 0.6rem; 
  padding-bottom: 0.4rem;
}

.pageTabActive {
  /* Style active tab like a pressed button or slightly different background */
  background-color: var(--win98-gray); /* Keep standard gray */
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  box-shadow: none; /* Remove shadow for pressed look */
  /* Adjust padding to match active state */
  padding-top: 0.6rem; 
  padding-bottom: 0.4rem;
}

.pageTabActive:hover {
  /* Keep pressed look on hover */
  background-color: var(--win98-gray);
}

/* --- End New Header Styles --- */

.connectButtonContainer {
  /* Keep original styles or adjust as needed */
  /* Example: Add some margin if needed */
  /* margin-bottom: 2px; /* Align better with raised tabs */
}

/* Add mobile-specific styles */
@media (max-width: 640px) {
  .disclaimer {
    font-size: 0.875rem; /* Smaller font on mobile */
    padding: 0.375rem;
    margin-bottom: 0.75rem;
  }
  
  .headerContainer {
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }
  
  .connectButtonContainer {
    order: -1; /* Places connect button above tabs */
    margin-bottom: 0.5rem;
    width: 100%; /* Full width on mobile */
    display: flex;
    justify-content: center;
  }
  
  .tabsInHeader {
    width: 100%;
    justify-content: space-between;
  }
  
  .pageTabButton {
    flex: 1;
    margin-right: 1px;
    font-size: 0.875rem; /* Slightly smaller font on mobile */
    padding: 0.375rem 0.5rem; /* Smaller padding on mobile */
  }
  
  .pageTabActive {
    padding-top: 0.475rem; /* Adjust active state padding for mobile */
    padding-bottom: 0.275rem;
  }
  
  .pageTabButton:active {
    padding-top: 0.475rem; /* Adjust active state padding for mobile */
    padding-bottom: 0.275rem;
  }
}

/* Add any other styles for page.tsx here */ 

/* Docs Page Styles */
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 1rem;
}

.title {
  font-size: 1.75rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
  text-align: center;
  color: var(--win98-dark-blue);
}

.docsContent {
  background-color: var(--win98-white);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  padding: 1.5rem;
}

.docsContent section {
  margin-bottom: 2rem;
}

.docsContent h2 {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 1rem;
  color: var(--win98-blue);
  border-bottom: 1px solid var(--win98-gray);
  padding-bottom: 0.5rem;
}

.docsContent h3 {
  font-size: 1.25rem;
  font-weight: bold;
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  color: var(--win98-dark-blue);
}

.docsContent p {
  margin-bottom: 1rem;
  line-height: 1.5;
}

.docsContent ul {
  list-style-type: square;
  margin-left: 1.5rem;
  margin-bottom: 1rem;
}

.docsContent li {
  margin-bottom: 0.5rem;
  line-height: 1.5;
}

.contactLinks {
  display: flex;
  gap: 1.5rem;
  margin-top: 1rem;
}

.contactLinks a {
  color: var(--win98-blue);
  text-decoration: underline;
}

.contactLinks a:hover {
  text-decoration: none;
}

.backToHome {
  margin-top: 2rem;
  text-align: center;
}

.backToHome a {
  display: inline-block;
  color: var(--win98-blue);
  text-decoration: none;
  padding: 0.5rem 1rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
}

.backToHome a:hover {
  background-color: var(--win98-light-gray);
}

.backToHome a:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

/* Media queries for docs page */
@media (max-width: 640px) {
  .container {
    padding: 0.5rem;
  }
  
  .docsContent {
    padding: 1rem;
  }
  
  .title {
    font-size: 1.5rem;
  }
  
  .docsContent h2 {
    font-size: 1.25rem;
  }
  
  .docsContent h3 {
    font-size: 1.125rem;
  }
} -e 

==============================================================

-e FILE: src/app/page.tsx

-e ==============================================================

'use client';

import React, { useState } from 'react';
import Image from 'next/image';
import { ConnectWalletButton } from '@/components/ConnectWalletButton';
import { SwapInterface } from '@/components/SwapInterface';
import styles from './page.module.css';

// Define the tab type
type ActiveTab = 'swap' | 'runesInfo' | 'yourTxs' | 'portfolio';

export default function Home() {
  // Get URL parameters
  const searchParams = new URLSearchParams(typeof window !== 'undefined' ? window.location.search : '');
  const tabParam = searchParams.get('tab') as ActiveTab | null;
  const runeParam = searchParams.get('rune');

  console.log('[Home] URL Parameters:', { tabParam, runeParam });

  // State for the active tab
  const [activeTab, setActiveTab] = useState<ActiveTab>(tabParam || 'swap');

  // Listen for tab change events
  React.useEffect(() => {
    const handleTabChange = (event: CustomEvent) => {
      const { tab } = event.detail;
      setActiveTab(tab as ActiveTab);
    };

    window.addEventListener('tabChange', handleTabChange as EventListener);
    return () => window.removeEventListener('tabChange', handleTabChange as EventListener);
  }, []);

  // Update URL when tab changes
  const handleTabChange = (tab: ActiveTab) => {
    setActiveTab(tab);
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('tab', tab);
    // Preserve the rune parameter if it exists and we're switching to swap tab
    const runeParam = searchParams.get('rune');
    if (tab === 'swap' && runeParam) {
      newUrl.searchParams.set('rune', runeParam);
    } else {
      newUrl.searchParams.delete('rune');
    }
    window.history.pushState({}, '', newUrl.toString());
  };

  return (
    <div className={styles.mainContainer}>
      {/* Alpha Version Disclaimer */}
      <div className={styles.disclaimer}>
        <Image 
          src="/icons/msg_warning-0.png" 
          alt="Warning" 
          className={styles.warningIcon}
          width={16}
          height={16}
        />
        This is an alpha version. Use at your own risk.
      </div>

      {/* New Header Container */}
      <div className={styles.headerContainer}>
        {/* Tab Buttons */}
        <div className={styles.tabsInHeader}>
          <button 
            className={`${styles.pageTabButton} ${activeTab === 'swap' ? styles.pageTabActive : ''}`}
            onClick={() => handleTabChange('swap')}
          >
            Swap
          </button>
          <button 
            className={`${styles.pageTabButton} ${activeTab === 'runesInfo' ? styles.pageTabActive : ''}`}
            onClick={() => handleTabChange('runesInfo')}
          >
            Runes Info
          </button>
          <button 
            className={`${styles.pageTabButton} ${activeTab === 'yourTxs' ? styles.pageTabActive : ''}`}
            onClick={() => handleTabChange('yourTxs')}
          >
            Your TXs
          </button>
          <button 
            className={`${styles.pageTabButton} ${activeTab === 'portfolio' ? styles.pageTabActive : ''}`}
            onClick={() => handleTabChange('portfolio')}
          >
            Portfolio
          </button>
        </div>

        {/* Connect Wallet Button */}
        <div className={styles.connectButtonContainer}> 
           <ConnectWalletButton />
        </div>
      </div>

      {/* Pass activeTab as a prop */}
      <SwapInterface activeTab={activeTab} />

      {/* Optional: Add other content/components below */}
      {/* <p className="pt-4 text-xs">Status: Ready</p> */}
    </div>
  );
}
-e 

==============================================================

-e FILE: src/app/providers.tsx

-e ==============================================================

'use client';

import React, { useState, useEffect } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { LaserEyesProvider, MAINNET, useLaserEyes } from '@omnisat/lasereyes';
import { LaserEyesContext } from '@/context/LaserEyesContext';

function SharedLaserEyesProvider({ children }: { children: React.ReactNode }) {
  const laserEyesData = useLaserEyes();

  return (
    <LaserEyesContext.Provider value={laserEyesData}>
      {children}
    </LaserEyesContext.Provider>
  );
}

export function Providers({ children }: { children: React.ReactNode }) {
  // This ensures we create only a single instance of the QueryClient
  const [queryClient] = React.useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000, // 5 minutes 
        gcTime: 60 * 60 * 1000, // 1 hour
        refetchOnMount: false,
        refetchOnWindowFocus: false,
        refetchOnReconnect: false,
      },
    },
  }));
  
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return null;
  }

  return (
    <LaserEyesProvider config={{ network: MAINNET }}>
      <SharedLaserEyesProvider>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </SharedLaserEyesProvider>
    </LaserEyesProvider>
  );
} -e 

==============================================================

-e FILE: src/components/AssetSelector.tsx

-e ==============================================================

import React, { useState, useMemo, Fragment } from 'react';
import { Listbox, Transition } from '@headlessui/react';
import { ChevronUpDownIcon, CheckIcon } from '@heroicons/react/24/solid';
import Image from 'next/image';
import { Asset, BTC_ASSET } from '@/types/common';
import styles from './SwapInterface.module.css'; // Use correct CSS module

interface AssetSelectorProps {
  value: Asset | null;
  onChange: (asset: Asset) => void;
  disabled: boolean;
  purpose: 'selectRune' | 'selectBtcOrRune';
  otherAsset: Asset | null; // Asset selected in the *other* input/output
  availableAssets: Asset[];
  isPopularLoading: boolean;
  popularError: string | null;
}

export function AssetSelector({ 
    value, 
    onChange, 
    disabled, 
    purpose, 
    otherAsset, 
    availableAssets, 
    isPopularLoading, 
    popularError 
}: AssetSelectorProps) {
    const [internalSearchQuery, setInternalSearchQuery] = useState('');

    const options = useMemo(() => {
        const query = internalSearchQuery.toLowerCase();
        let results = [...availableAssets];
        if (purpose === 'selectBtcOrRune') {
            // Ensure BTC is an option if needed
            if (!results.some(a => a.isBTC)) results.unshift(BTC_ASSET);
        } else {
            // Filter out BTC if only Runes are allowed
            results = results.filter(a => !a.isBTC);
        }
        // Filter by search query
        if (query) results = results.filter(a => a.name?.toLowerCase().includes(query) || a.id?.toLowerCase().includes(query));
        // Filter out the asset selected in the other input/output field
        if (otherAsset) results = results.filter(a => a.id !== otherAsset.id);
        return results;
    }, [internalSearchQuery, availableAssets, purpose, otherAsset]);

    const displaySelectedValue = (selected: Asset | null) => {
        if (!selected) return <span className={styles.placeholder}>Select Token</span>;
        const ticker = selected.isBTC ? 'BTC' : (selected.name.split('â€¢')[0] || selected.name);
        return (
            <span className={styles.selectedToken}>
                {selected.imageURI && (
                  <Image 
                    src={selected.imageURI} 
                    alt={ticker} 
                    className={styles.tokenIcon} 
                    width={20}
                    height={20}
                    onError={(e) => {
                      const target = e.target as HTMLImageElement;
                      if (target) {
                        target.style.display = 'none';
                      }
                    }}
                  />
                )} {ticker}
            </span>
        );
    };

    // Find the full asset object corresponding to the current value ID to ensure Listbox gets the correct object reference
    const currentValueObject = value ? availableAssets.concat(BTC_ASSET).find(opt => opt.id === value.id) || value : null;

    return (
        <Listbox value={currentValueObject} onChange={onChange} disabled={disabled}>
            <div className={styles.listBoxContainer}>
                <Listbox.Button className={styles.listboxButton}>
                    {displaySelectedValue(currentValueObject)}
                    <span className={styles.listboxButtonIconContainer}>
                        <ChevronUpDownIcon className={styles.listboxButtonIcon} aria-hidden="true" />
                    </span>
                </Listbox.Button>
                <Transition as={Fragment} leave="transition ease-in duration-100" leaveFrom="opacity-100" leaveTo="opacity-0">
                    <Listbox.Options className={styles.listBoxOptions}>
                        <div className={styles.searchContainer}>
                            <input 
                                type="text" 
                                placeholder="Search name or ID" 
                                value={internalSearchQuery} 
                                onChange={e => setInternalSearchQuery(e.target.value)} 
                                className={styles.searchInput} 
                                autoComplete="off" 
                            />
                        </div>
                        {isPopularLoading && !internalSearchQuery && options.length === 0 ? (
                            <div className={styles.loadingOrError}>Loading...</div>
                        ) : popularError && options.length === 0 ? (
                            <div className={styles.loadingOrError}>{popularError}</div>
                        ) : options.length === 0 ? (
                            <div className={styles.noResults}>{internalSearchQuery ? 'No match' : 'No assets'}</div>
                        ) : (
                            <div className={styles.optionsScroll}>
                                {options.map((asset) => (
                                    <Listbox.Option key={asset.id} className={({ active }) => `${styles.listboxOption} ${active ? styles.listboxOptionActive : styles.listboxOptionInactive}`} value={asset}>
                                        {({ selected }) => {
                                            const ticker = asset.isBTC ? 'BTC' : (asset.name.split('â€¢')[0] || asset.name);
                                            return (
                                                <>
                                                    <span className={`${styles.optionContent} ${selected ? styles.listboxOptionTextSelected : styles.listboxOptionTextUnselected}`}>
                                                        {asset.imageURI && (
                                                          <Image 
                                                            src={asset.imageURI} 
                                                            alt={ticker} 
                                                            className={styles.tokenIcon} 
                                                            width={20}
                                                            height={20}
                                                            onError={(e) => {
                                                              const target = e.target as HTMLImageElement;
                                                              if (target) {
                                                                target.style.display = 'none';
                                                              }
                                                            }}
                                                          />
                                                        )}
                                                        <span className={styles.optionTicker}>{ticker}</span>
                                                        {!asset.isBTC && <span className={styles.optionName}>({asset.name})</span>}
                                                    </span>
                                                    {selected && <span className={styles.checkIconContainer}><CheckIcon className={styles.checkIcon} aria-hidden="true" /></span>}
                                                </>
                                            );
                                        }}
                                    </Listbox.Option>
                                ))}
                            </div>
                        )}
                    </Listbox.Options>
                </Transition>
            </div>
        </Listbox>
    );
} -e 

==============================================================

-e FILE: src/components/ConnectWalletButton.module.css

-e ==============================================================

/* src/components/ConnectWalletButton.module.css */

.connectButton {
  padding: 0.25rem 0.75rem; /* px-3 py-1 */
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-size: 0.875rem; /* text-sm */
  line-height: 1.25rem; /* text-sm */
  color: var(--win98-black);
}

.connectButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  /* Optional: slightly inset look */
  /* padding-top: 0.3rem; */
  /* padding-left: 0.8rem; */
}

.buttonContainer {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem; /* gap-2 */
}

.connectedInfo {
  display: flex;
  align-items: center;
  gap: 0.5rem; /* space-x-2 */
}

.connectedText {
  font-size: 0.875rem; /* text-sm */
}

/* New styles for dropdown */
.connectContainer {
  position: relative; /* Needed for absolute positioning of the dropdown */
  display: inline-block; /* Or block, depending on layout needs */
}

.dropdown {
  position: absolute;
  top: 100%; /* Position below the button */
  left: 0;
  width: 100%; /* Make dropdown exactly the same width as the button */
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-dark-gray); /* Inset border look */
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  z-index: 50; /* Ensure dropdown is above other content - Increased z-index */
  padding: 2px; /* Inner padding for the border effect */
  box-shadow: 2px 2px 0px 0px var(--win98-dark-gray); /* Optional: subtle shadow */
}

.dropdownItemContainer {
  position: relative;
  width: 100%;
}

.dropdownItem {
  display: block;
  width: 100%;
  padding: 0.25rem 0.5rem;
  text-align: left;
  background-color: var(--win98-gray);
  border: none;
  cursor: pointer;
  font-size: 0.875rem; /* text-sm */
  position: relative; /* For positioning the warning icon */
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dropdownItem:hover {
  background-color: var(--win98-blue);
  color: white;
}

.dropdownItem:disabled {
  color: var(--win98-dark-gray);
  cursor: not-allowed;
  background-color: var(--win98-gray);
}

.warningIconContainer {
  width: 16px;
  height: 16px;
  margin-left: 4px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.warningIcon {
  width: 16px;
  height: 16px;
}

/* Error message styling */
.errorMessage {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  margin-top: 4px;
  padding: 8px;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  color: var(--win98-black);
  font-size: 0.875rem;
  z-index: 50;
  box-shadow: 2px 2px 0px 0px var(--win98-dark-gray);
}

.errorMessage p {
  margin: 0;
  margin-bottom: 8px;
}

.errorMessage p:last-child {
  margin-bottom: 0;
}

.installLink {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-size: 0.75rem;
  text-decoration: none;
  color: var(--win98-black);
}

.installLink:hover {
  text-decoration: underline;
}

.installLink:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
} -e 

==============================================================

-e FILE: src/components/ConnectWalletButton.tsx

-e ==============================================================

'use client';

import React, { useState, useEffect, useRef } from 'react';
// Import ONLY the types/constants needed
import {
  UNISAT,
  XVERSE,
  LEATHER,
  OYL,
  MAGIC_EDEN,
  OKX,
  ORANGE,
  PHANTOM,
  WIZZ,
  type ProviderType, 
} from '@omnisat/lasereyes';
import { useSharedLaserEyes } from '@/context/LaserEyesContext'; // Import the shared hook
import styles from './ConnectWalletButton.module.css'; // Import CSS module
import Image from 'next/image';

// Helper function to truncate address
const truncateAddress = (address: string) => {
  if (!address) return "";
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
};

// Wallet-specific error patterns to identify installation issues
interface WalletErrorPatterns {
  notInstalledPatterns: string[];
  otherPatterns?: {
    [key: string]: string[];
  };
}

const WALLET_ERROR_PATTERNS: Partial<Record<ProviderType, WalletErrorPatterns>> = {
  [UNISAT]: {
    notInstalledPatterns: ['not detected', 'not installed', 'not found']
  },
  [XVERSE]: {
    notInstalledPatterns: ['no bitcoin wallet installed', 'extension not installed', 'is not defined']
  },
  [LEATHER]: {
    notInstalledPatterns: ['leather isn\'t installed']
  },
  [OYL]: {
    notInstalledPatterns: ['oyl isn\'t installed']
  },
  [MAGIC_EDEN]: {
    notInstalledPatterns: ['no bitcoin wallet installed']
  },
  [OKX]: {
    notInstalledPatterns: ['cannot read properties of undefined', 'provider not available']
  },
  [ORANGE]: {
    notInstalledPatterns: ['no orange bitcoin wallet installed']
  },
  [PHANTOM]: {
    notInstalledPatterns: ['phantom isn\'t installed', 'provider unavailable', 'no provider']
  },
  [WIZZ]: {
    notInstalledPatterns: ['wallet is not installed']
  }
};

// Common error patterns for all wallets
const COMMON_ERROR_PATTERNS: string[] = [
  'not installed', 
  'not detected', 
  'not found',
  'provider not available',
  'wallet not found',
  'extension not installed',
  'missing provider',
  'undefined provider',
  'provider unavailable',
  'no provider',
  'cannot find',
  'not connected',
  'is not defined',
  'is undefined',
  'not exist'
];

// Wallet installation links
const WALLET_INSTALL_LINKS: Partial<Record<ProviderType, string>> = {
  [UNISAT]: 'https://unisat.io/download',
  [XVERSE]: 'https://www.xverse.app/download',
  [LEATHER]: 'https://leather.io/install-extension',
  [OYL]: 'https://chromewebstore.google.com/detail/oyl-wallet-bitcoin-ordina/ilolmnhjbbggkmopnemiphomhaojndmb',
  [MAGIC_EDEN]: 'https://wallet.magiceden.io/download',
  [OKX]: 'https://web3.okx.com/en-eu/download',
  [ORANGE]: 'https://chromewebstore.google.com/detail/orange-wallet/glmhbknppefdmpemdmjnjlinpbclokhn?hl=en&authuser=0',
  [PHANTOM]: 'https://phantom.com/download',
  [WIZZ]: 'https://wizzwallet.io/',
};

// Define the list of available wallets
const AVAILABLE_WALLETS: { name: string; provider: ProviderType; disclaimer?: string }[] = [
  { name: 'Xverse', provider: XVERSE },
  { name: 'Unisat', provider: UNISAT },
  { name: 'Leather', provider: LEATHER },
  { name: 'OKX', provider: OKX },
  { name: 'Magic Eden', provider: MAGIC_EDEN },
  { name: 'OYL', provider: OYL },
  { name: 'Orange', provider: ORANGE },
  { name: 'Phantom', provider: PHANTOM, disclaimer: 'Runes are not supported in Phantom wallet. Use with caution.' },
  { name: 'Wizz', provider: WIZZ },
];

export function ConnectWalletButton() {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [installLink, setInstallLink] = useState<string | null>(null);

  // Use the shared hook
  const {
    connect,
    disconnect,
    connected,
    isConnecting,
    address,
    provider,
    hasUnisat,
  } = useSharedLaserEyes();

  // Check if wallet is installed before attempting connection
  const checkWalletInstalled = (providerToConnect: ProviderType): boolean => {
    switch (providerToConnect) {
      case UNISAT:
        return hasUnisat || false;
      // Add more cases for other wallets when LaserEyes API provides them
      default:
        // For wallets we can't check, assume they're installed and let the error handling manage it
        return true;
    }
  };

  const handleConnect = async (providerToConnect: ProviderType) => {
    setIsDropdownOpen(false);
    setConnectionError(null);
    setInstallLink(null);
    
    if (isConnecting) {
      return;
    }

    // Get wallet name for messages
    const walletName = AVAILABLE_WALLETS.find(w => w.provider === providerToConnect)?.name || providerToConnect;

    // Check if wallet is installed
    if (!checkWalletInstalled(providerToConnect)) {
      console.log(`[ConnectWalletButton] ${walletName} wallet not installed (detected by hasUnisat check)`);
      setConnectionError(`${walletName} wallet not installed.`);
      setInstallLink(WALLET_INSTALL_LINKS[providerToConnect] || null);
      return;
    }
    
    try {
      console.log(`[ConnectWalletButton] Attempting to connect to ${walletName} wallet...`);
      await connect(providerToConnect);
      console.log(`[ConnectWalletButton] Successfully connected to ${walletName} wallet`);
    } catch (error) {
      // Detailed error logging for debugging
      console.error(`[ConnectWalletButton] Failed to connect ${walletName} wallet:`, error);
      
      // Determine if this is a "wallet not installed" error
      let isWalletNotInstalledError = false;
      let errorMessage = '';
      
      if (error instanceof Error) {
        const errorString = error.message.toLowerCase();
        
        // First check wallet-specific patterns if available
        const walletPatterns = WALLET_ERROR_PATTERNS[providerToConnect];
        if (walletPatterns) {
          // Check against wallet-specific patterns
          isWalletNotInstalledError = walletPatterns.notInstalledPatterns.some(pattern => 
            errorString.includes(pattern.toLowerCase())
          );
        }
        
        // If no wallet-specific match, fall back to common patterns
        if (!isWalletNotInstalledError) {
          isWalletNotInstalledError = COMMON_ERROR_PATTERNS.some(pattern => 
            errorString.includes(pattern.toLowerCase())
          );
        }
        
        errorMessage = error.message;
      } else {
        // For non-Error objects, assume they're related to wallet installation
        isWalletNotInstalledError = true;
        errorMessage = 'Wallet provider unavailable';
      }
      
      if (isWalletNotInstalledError) {
        setConnectionError(`${walletName} wallet not installed.`);
        setInstallLink(WALLET_INSTALL_LINKS[providerToConnect] || null);
      } else {
        // Other connection errors
        setConnectionError(`Failed to connect to ${walletName}: ${errorMessage || 'Unknown error'}`);
        setInstallLink(null);
      }
    }
  };

  const handleDisconnect = () => {
    disconnect();
    setConnectionError(null);
    setInstallLink(null);
  };

  const toggleDropdown = () => {
    setIsDropdownOpen(!isDropdownOpen);
    // Clear errors when opening/closing dropdown
    setConnectionError(null);
    setInstallLink(null);
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Simplified Render Logic:

  // 1. Show connected info if connected.
  if (connected && address) {
    const connectedWalletName = AVAILABLE_WALLETS.find(w => w.provider === provider)?.name || provider || 'Wallet';
    return (
      <div className={styles.connectedInfo}>
        <span className={styles.connectedText}>{connectedWalletName}: {truncateAddress(address)}</span>
        <button
          onClick={handleDisconnect}
          className={styles.connectButton}
        >
          Disconnect
        </button>
      </div>
    );
  }

  // 2. Show loading button ONLY if actively connecting.
  if (isConnecting) {
    return (
      <button className={styles.connectButton} disabled>
        Connecting...
      </button>
    );
  }

  // 3. Show connect button and dropdown if not connected AND not connecting.
  return (
    <div className={styles.connectContainer} ref={dropdownRef}>
      <button
        onClick={toggleDropdown}
        className={styles.connectButton}
        disabled={isConnecting}
      >
        Connect Wallet
      </button>
      {isDropdownOpen && (
        <div className={styles.dropdown}>
          {AVAILABLE_WALLETS.map(({ name, provider: walletProvider, disclaimer }) => (
            <div key={walletProvider} className={styles.dropdownItemContainer}>
              <button
                onClick={() => handleConnect(walletProvider)}
                className={styles.dropdownItem}
                disabled={isConnecting}
              >
                <span>{name}</span>
                {disclaimer && (
                  <div className={styles.warningIconContainer} title={`Warning: ${disclaimer}`}>
                    <Image 
                      src="/icons/msg_warning-0.png" 
                      alt="Warning" 
                      className={styles.warningIcon} 
                      width={16}
                      height={16}
                    />
                  </div>
                )}
              </button>
            </div>
          ))}
        </div>
      )}
      {connectionError && (
        <div className={styles.errorMessage}>
          <p>{connectionError}</p>
          {installLink && (
            <a 
              href={installLink} 
              target="_blank" 
              rel="noopener noreferrer" 
              className={styles.installLink}
            >
              Install Wallet
            </a>
          )}
        </div>
      )}
    </div>
  );
}

export default ConnectWalletButton;-e 

==============================================================

-e FILE: src/components/FooterComponent.tsx

-e ==============================================================

'use client';

import React from 'react';
import Image from 'next/image';
import Link from 'next/link';
import styles from './SwapInterface.module.css';

interface FooterComponentProps {
  btcPriceUsd: number | undefined;
  isBtcPriceLoading: boolean;
  btcPriceError: Error | null;
}

export function FooterComponent({ btcPriceUsd, isBtcPriceLoading, btcPriceError }: FooterComponentProps) {
  return (
    <div className={styles.btcPriceFooter}>
      {isBtcPriceLoading ? (
        <span>Loading BTC price...</span>
      ) : btcPriceError ? (
        <span className={styles.errorText}>Error loading price</span>
      ) : btcPriceUsd ? (
        <span>BTC Price: {btcPriceUsd.toLocaleString(undefined, { style: 'currency', currency: 'USD' })}</span>
      ) : (
        <span>BTC Price: N/A</span>
      )}
      <div className={styles.socialLinks}>
        <Link
          href="/docs"
          className={styles.docsButton}
          title="Documentation"
        >
          Docs
        </Link>
        <a
          href="https://github.com/ropl-btc/RunesSwap.app"
          target="_blank"
          rel="noopener noreferrer"
          title="GitHub"
          className={styles.socialLink}
        >
          <Image
            src="/icons/github-mark.svg"
            alt="GitHub"
            width={16}
            height={16}
          />
        </a>
        <a
          href="https://twitter.com/robin_liquidium"
          target="_blank"
          rel="noopener noreferrer"
          title="X (Twitter)"
          className={styles.socialLink}
        >
          <Image
            src="/icons/x-logo.svg"
            alt="X (Twitter)"
            width={16}
            height={16}
          />
        </a>
      </div>
    </div>
  );
}

export default FooterComponent;-e 

==============================================================

-e FILE: src/components/FormattedRuneAmount.tsx

-e ==============================================================

'use client';

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { fetchRuneInfoFromApi } from '@/lib/apiClient';
import type { RuneData } from '@/lib/runesData';

interface FormattedRuneAmountProps {
  runeName: string | null | undefined;
  rawAmount: string | null | undefined;
}

export function FormattedRuneAmount({ runeName, rawAmount }: FormattedRuneAmountProps) {
  const {
    data: runeInfo,
    isLoading,
    error,
  } = useQuery<RuneData | null, Error>({
    // Update queryKey to reflect API usage
    queryKey: ['runeInfoApi', (runeName || '').toUpperCase()], 
    // Use the new API client function
    queryFn: () => (runeName ? fetchRuneInfoFromApi(runeName) : Promise.resolve(null)),
    enabled: !!runeName && rawAmount !== 'N/A' && rawAmount !== null && rawAmount !== undefined, // Only run if we have a rune name and a valid raw amount
    staleTime: Infinity, // Decimals rarely change, cache indefinitely
    // Remove specific 404 retry logic, as API client returns null for 404 (treated as success by useQuery)
    retry: 2 // Retry other network/server errors twice
  });

  if (rawAmount === 'N/A' || rawAmount === null || rawAmount === undefined) {
    return <span>N/A</span>;
  }
  
  if (!runeName) {
     return <span>{rawAmount} (Unknown Rune)</span>; // Should not happen if enabled logic works
  }

  if (isLoading) {
    return <span>{rawAmount} (Loading decimals...)</span>;
  }

  if (error) {
      // 404 is handled by runeInfo being null, so this only catches other errors
      console.error("Error fetching rune info for decimals:", error);
      return <span>{rawAmount} (&apos;Error fetching decimals&apos;)</span>;
  }

  if (!runeInfo || typeof runeInfo.decimals !== 'number') {
      // Rune info loaded but no decimals found (or invalid format), show raw amount
      return <span>{rawAmount} (Decimals N/A)</span>;
  }

  const decimals = runeInfo.decimals;
  
  // Handle case where decimals are 0
  if (decimals === 0) {
      try {
          // Format even if 0 decimals for consistency (e.g., add commas)
          const amountNum = BigInt(rawAmount); // Use BigInt for potentially large raw amounts
          return <span>{amountNum.toLocaleString()}</span>;
      } catch (e) {
          console.error("Error formatting raw amount (0 decimals):", e);
          return <span>{rawAmount} (Invalid Raw)</span>; // Fallback for invalid rawAmount
      }
  }

  // Calculate and format with decimals
  try {
    // Use BigInt for precision with large numbers before converting to Number for division
    const rawAmountBigInt = BigInt(rawAmount);
    const divisor = BigInt(10 ** decimals);
    
    // Perform division carefully to handle potential floating point issues
    // For display, Number should be sufficient after scaling down
    const formattedAmount = Number(rawAmountBigInt) / Number(divisor);

    if (isNaN(formattedAmount)) {
        throw new Error("Calculated amount is NaN");
    }

    // Format the number with appropriate decimal places
    return <span>{formattedAmount.toLocaleString(undefined, { maximumFractionDigits: decimals })}</span>;
  } catch (e) {
    console.error("Error formatting rune amount:", e);
    return <span>{rawAmount} (Formatting Error)</span>; // Fallback
  }
} -e 

==============================================================

-e FILE: src/components/Layout.module.css

-e ==============================================================

/* src/components/Layout.module.css */

.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem; /* p-4 */
  background-color: var(--win98-gray);
}

.window {
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  width: 100%;
  max-width: 42rem; /* max-w-2xl */
  box-shadow: 1px 1px 0 1px var(--win98-black); /* Simple shadow */
  /* Add more robust shadow/bevel later if needed */
}

.titleBar {
  background-color: var(--win98-blue);
  color: var(--win98-white);
  padding: 0.125rem 0.5rem; /* py-0.5 px-2 */
  font-size: 0.875rem; /* text-sm */
  line-height: 1.25rem; /* text-sm */
  font-weight: 700; /* font-bold */
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.content {
  padding: 1rem; /* p-4 */
} -e 

==============================================================

-e FILE: src/components/Layout.tsx

-e ==============================================================

'use client'; // Required for hooks

import React, { useEffect } from 'react'; // Added useEffect
import styles from './Layout.module.css'; // Import the CSS module
import { useSharedLaserEyes } from '@/context/LaserEyesContext'; // Import shared hook

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  // Use shared hook to get disconnect
  const { disconnect } = useSharedLaserEyes();

  // WORKAROUND: Force disconnect wallet on initial mount.
  // This is a workaround for a bug observed with the LaserEyes library (v0.0.134)
  // where refreshing the page while connected (especially with Xverse) triggers
  // multiple simultaneous connection prompts from the wallet extension.
  // This occurs even when using a single shared hook instance and with React Strict Mode off,
  // suggesting an issue with the library's internal auto-reconnect/initialization logic.
  // Forcing disconnect on mount prevents these multiple prompts, requiring manual reconnect after refresh.
  useEffect(() => {
    disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Use empty dependency array to run only ONCE on mount

  return (
    // Apply styles using the styles object
    <div className={styles.container}>
      {/* The main "window" */}
      <div className={styles.window}>
        {/* Optional Title Bar */}
        <div className={styles.titleBar}>
          <span>RunesSwap.app</span>
          {/* Placeholder for window controls maybe? */}
        </div>
        {/* Window Content Area */}
        <div className={styles.content}>
          {children}
        </div>
      </div>
    </div>
  );
}

export default Layout;-e 

==============================================================

-e FILE: src/components/PortfolioTab.module.css

-e ==============================================================

.container {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  padding: 0;
}

.message {
  text-align: center;
  padding: 2rem;
}

.listContainer {
  background: var(--win98-surface);
  border: var(--win98-border-raised-outer);
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  width: 100%;
}

.listHeader {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 80px;
  padding: 0.5rem;
  background: var(--win98-surface);
  border-bottom: var(--win98-border-sunken-outer);
  font-weight: bold;
}

.sortable {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.sortable:hover {
  text-decoration: underline;
}

.listContent {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

.listItem {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 80px;
  padding: 0.5rem;
  border-bottom: 1px solid var(--win98-border-raised-outer);
}

.listItem:last-child {
  border-bottom: none;
}

.runeNameContent {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.runeImage {
  width: 24px;
  height: 24px;
  border-radius: 4px;
}

.runeNameText {
  display: flex;
  flex-direction: column;
}

.runeFullName {
  font-weight: 500;
}

.runeTicker {
  font-size: 0.875rem;
  color: var(--win98-text-muted);
}

.portfolioTotals {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 80px;
  padding: 0.75rem 0.5rem;
  background: var(--win98-surface);
  border-top: var(--win98-border-sunken-outer);
  font-weight: bold;
}

.swapButton {
  padding: 2px 8px;
  background: var(--win98-surface);
  border: 2px solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 24px;
}

.swapButton:hover {
  background: var(--win98-surface-hover);
}

.swapButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  padding: 3px 7px 1px 9px;
}

.sortArrow {
  font-family: monospace;
  font-size: 12px;
  font-weight: bold;
  display: inline-block;
  margin-left: 2px;
  line-height: 1;
  position: relative;
  top: -1px;
}

/* Mobile Responsive Styles */
@media (max-width: 640px) {
  .listHeader,
  .listItem,
  .portfolioTotals {
    grid-template-columns: 2fr 1fr;
    gap: 0.5rem;
  }

  /* Hide all header items except USD Value */
  .listHeader > div {
    display: none;
  }

  /* Only show and style USD Value header */
  .listHeader > div:nth-child(3) {
    display: block;
    grid-column: 2;
    text-align: right;
  }

  .listHeader > div:nth-child(3).sortable {
    display: flex;
    justify-content: flex-end;
  }

  /* Show balance in the first column and USD value in the second */
  .listItem > div:nth-child(1) {
    grid-column: 1;
  }
  
  .listItem > div:nth-child(2) {
    display: none;
  }
  
  .listItem > div:nth-child(3) {
    grid-column: 2;
    display: block;
    text-align: right;
  }

  /* Hide portfolio total's BTC value on mobile */
  .portfolioTotals > div:nth-child(2) {
    display: none;
  }
  
  .portfolioTotals > div:nth-child(3) {
    grid-column: 2;
    display: block;
    text-align: right;
  }

  /* Move swap button below */
  .swapButton {
    grid-column: span 2;
    margin-top: 0.5rem;
    width: 100%;
  }

  .listItem {
    padding: 0.75rem 0.5rem;
  }

  .runeNameContent {
    gap: 0.75rem;
  }

  /* Style for USD value in mobile */
  .runeValue {
    font-size: 0.875rem;
  }

  /* Adjust portfolio totals for mobile */
  .portfolioTotals > div:first-child {
    grid-column: 1;
  }
} -e 

==============================================================

-e FILE: src/components/PortfolioTab.tsx

-e ==============================================================

import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { useSharedLaserEyes } from '@/context/LaserEyesContext';
import { fetchPortfolioDataFromApi } from '@/lib/apiClient';
import { QUERY_KEYS } from '@/lib/apiClient';
import { FormattedRuneAmount } from './FormattedRuneAmount';
import styles from './PortfolioTab.module.css';

type SortField = 'name' | 'balance' | 'value';
type SortDirection = 'asc' | 'desc';

export default function PortfolioTab() {
  const router = useRouter();
  const { address } = useSharedLaserEyes();
  const [sortField, setSortField] = useState<SortField>('value');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // Use the new batch API endpoint
  const { data: portfolioData, isLoading, error } = useQuery({
    queryKey: [QUERY_KEYS.PORTFOLIO_DATA, address],
    queryFn: () => fetchPortfolioDataFromApi(address || ''),
    enabled: !!address,
    staleTime: 30000, // Cache for 30 seconds
  });

  // Extract data from the combined response
  const runeBalances = portfolioData?.balances || [];
  const runeInfoData = portfolioData?.runeInfos || {};
  const marketData = portfolioData?.marketData || {};

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('desc');
    }
  };

  const handleSwap = (runeName: string) => {
    // Update URL without page refresh
    router.push(`/?tab=swap&rune=${encodeURIComponent(runeName)}`, { scroll: false });
    // Emit custom event to notify parent components
    window.dispatchEvent(new CustomEvent('tabChange', { detail: { tab: 'swap', rune: runeName } }));
  };

  if (!address) {
    return (
      <div className={styles.container}>
        <div className={styles.message}>
          Connect your wallet to view your portfolio
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className={styles.container}>
        <div className={styles.message}>Loading your portfolio...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div className={styles.container}>
        <div className={styles.message}>Error loading portfolio</div>
      </div>
    );
  }

  if (!runeBalances?.length) {
    return (
      <div className={styles.container}>
        <div className={styles.message}>No runes found in your wallet</div>
      </div>
    );
  }

  // Calculate values and sort the balances
  const sortedBalances = [...runeBalances].map(rune => {
    const marketInfo = marketData?.[rune.name];
    const runeInfo = runeInfoData?.[rune.name];
    const decimals = runeInfo?.decimals || 0;
    const actualBalance = Number(rune.balance) / Math.pow(10, decimals);
    const btcValue = marketInfo?.price_in_sats ? (actualBalance * marketInfo.price_in_sats) / 1e8 : 0;
    const usdValue = marketInfo?.price_in_usd ? actualBalance * marketInfo.price_in_usd : 0;
    const imageURI = `https://icon.unisat.io/icon/runes/${encodeURIComponent(rune.name)}`;

    return {
      ...rune,
      actualBalance,
      btcValue,
      usdValue,
      imageURI,
      formattedName: runeInfo?.formatted_name || rune.name,
    };
  }).sort((a, b) => {
    let comparison = 0;
    switch (sortField) {
      case 'name':
        comparison = a.name.localeCompare(b.name);
        break;
      case 'balance':
        comparison = a.actualBalance - b.actualBalance;
        break;
      case 'value':
        comparison = a.usdValue - b.usdValue;
        break;
    }
    return sortDirection === 'asc' ? comparison : -comparison;
  });

  // Calculate totals
  const totalBtcValue = sortedBalances.reduce((sum, rune) => sum + rune.btcValue, 0);
  const totalUsdValue = sortedBalances.reduce((sum, rune) => sum + rune.usdValue, 0);

  return (
    <div className={styles.container}>
      <div className={styles.listContainer}>
        <div className={styles.listHeader}>
          <div 
            className={`${styles.runeNameHeader} ${styles.sortable}`}
            onClick={() => handleSort('name')}
          >
            Rune Name
            {sortField === 'name' && (
              <span className={styles.sortArrow}>
                {sortDirection === 'asc' ? 'â†‘' : 'â†“'}
              </span>
            )}
          </div>
          <div 
            className={`${styles.runeBalanceHeader} ${styles.sortable}`}
            onClick={() => handleSort('balance')}
          >
            Balance
            {sortField === 'balance' && (
              <span className={styles.sortArrow}>
                {sortDirection === 'asc' ? 'â†‘' : 'â†“'}
              </span>
            )}
          </div>
          <div 
            className={`${styles.runeValueHeader} ${styles.sortable}`}
            onClick={() => handleSort('value')}
          >
            Value (USD)
            {sortField === 'value' && (
              <span className={styles.sortArrow}>
                {sortDirection === 'asc' ? 'â†‘' : 'â†“'}
              </span>
            )}
          </div>
          <div>Action</div>
        </div>
        <div className={styles.listContent}>
          {sortedBalances.map((rune) => {
            const marketInfo = marketData?.[rune.name];
            const usdValue = marketInfo?.price_in_usd 
              ? rune.usdValue.toFixed(2)
              : '0.00';

            return (
              <div key={rune.name} className={styles.listItem}>
                <div className={styles.runeName}>
                  <div className={styles.runeNameContent}>
                    <Image
                      src={rune.imageURI}
                      alt=""
                      className={styles.runeImage}
                      width={24}
                      height={24}
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        if (target) {
                          target.style.display = 'none';
                        }
                      }}
                    />
                    <div className={styles.runeNameText}>
                      <div className={styles.runeFullName}>{rune.formattedName}</div>
                    </div>
                  </div>
                </div>
                <div className={styles.runeBalance}>
                  <FormattedRuneAmount
                    runeName={rune.name}
                    rawAmount={rune.balance}
                  />
                </div>
                <div className={styles.runeValue}>
                  {!marketData ? '...' : `$${usdValue}`}
                </div>
                <button 
                  className={styles.swapButton}
                  onClick={() => handleSwap(rune.name)}
                >
                  Swap
                </button>
              </div>
            );
          })}
        </div>
        <div className={styles.portfolioTotals}>
          <div>Portfolio Total:</div>
          <div>â‰ˆ {totalBtcValue.toFixed(8)} BTC</div>
          <div>${totalUsdValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
          <div></div>
        </div>
      </div>
    </div>
  );
} -e 

==============================================================

-e FILE: src/components/PriceChart.tsx

-e ==============================================================

import React, { useEffect, useRef, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { fetchRunePriceHistoryFromApi, QUERY_KEYS } from '@/lib/apiClient';
import styles from './SwapInterface.module.css';

interface PriceChartProps {
  assetName: string;
  timeFrame?: '24h' | '7d' | '30d' | 'all';
  onClose?: () => void;
  btcPriceUsd?: number; // BTC price in USD
}

interface ChartDataPoint {
  x: number;
  y: number;
  price: number;
  timestamp: number;
}

const PriceChart: React.FC<PriceChartProps> = ({ assetName, timeFrame = '24h', onClose, btcPriceUsd }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [selectedTimeframe, setSelectedTimeframe] = useState<'24h' | '7d' | '30d' | 'all'>(timeFrame);
  const [hoverInfo, setHoverInfo] = useState<{ price: string; time: string; x: number; y: number } | null>(null);
  const chartPointsRef = useRef<ChartDataPoint[]>([]);
  
  // Fetch price history data using React Query
  const {
    data: priceHistoryData,
    isLoading,
    isError
  } = useQuery({
    queryKey: [QUERY_KEYS.RUNE_PRICE_HISTORY, assetName],
    queryFn: () => fetchRunePriceHistoryFromApi(assetName),
    staleTime: 5 * 60 * 1000, // Consider data stale after 5 minutes
    gcTime: 10 * 60 * 1000, // Keep in cache for 10 minutes
    refetchOnWindowFocus: false, // Don't refetch on window focus
    retry: 2, // Retry failed requests twice
  });
  
  // Debug logging for price history data
  useEffect(() => {
    // Force refresh if we have problems with the data
    if (priceHistoryData?.prices && priceHistoryData.prices.length > 0 && !priceHistoryData.available) {
      // Data inconsistency detected - prices exist but available is false
    }
  }, [priceHistoryData, assetName, btcPriceUsd]);

  // Convert sats to USD and filter by timeframe
  const filteredPriceData = React.useMemo(() => {
    if (!priceHistoryData?.prices || priceHistoryData.prices.length === 0) {
      return [];
    }

    // If BTC price is not available, use 1 as a fallback for display purposes
    const btcPrice = btcPriceUsd || 1;
    
    // Convert price data from sats to USD
    const convertedPriceData = priceHistoryData.prices.map(point => {
      // Convert sats to USD: sats_per_token * (btc_price_usd / 100_000_000)
      // floor_value is in sats per token
      const priceInUsd = point.price * (btcPrice / 100000000);
      
      return {
        ...point,
        price: priceInUsd,
        originalPriceInSats: point.price // Keep the original price for reference
      };
    });

    const now = Date.now();
    let timeframeMs: number;
    
    // Log the date range of the data
    if (convertedPriceData.length > 0) {
      const timestamps = convertedPriceData.map(item => item.timestamp);
      const earliest = new Date(Math.min(...timestamps));
      const latest = new Date(Math.max(...timestamps));
      const daysDiff = Math.floor((latest.getTime() - earliest.getTime()) / (1000 * 60 * 60 * 24));
      
      console.log(`[PriceChart] Data date range: ${daysDiff} days (${earliest.toLocaleDateString()} to ${latest.toLocaleDateString()})`);
    }
    
    switch(selectedTimeframe) {
      case '24h':
        timeframeMs = 24 * 60 * 60 * 1000; // 24 hours in ms
        break;
      case '7d':
        timeframeMs = 7 * 24 * 60 * 60 * 1000; // 7 days in ms
        break;
      case '30d':
        timeframeMs = 30 * 24 * 60 * 60 * 1000; // 30 days in ms
        break;
      case 'all':
      default:
        // For "all", return all available data points without filtering
        console.log(`[PriceChart] Returning all ${convertedPriceData.length} data points`);
        return convertedPriceData.sort((a, b) => a.timestamp - b.timestamp); // Return all data, sorted by timestamp
    }
    
    // Filter data points within the selected timeframe
    const filtered = convertedPriceData.filter(point => {
      return point.timestamp >= (now - timeframeMs);
    });
    
    // Always sort by timestamp to ensure the chart draws correctly
    return filtered.sort((a, b) => a.timestamp - b.timestamp);
  }, [priceHistoryData, selectedTimeframe, btcPriceUsd]);

  // Draw the chart
  useEffect(() => {
    if (!canvasRef.current || filteredPriceData.length === 0) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    // Extract price values
    const prices = filteredPriceData.map(d => d.price);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    
    // Calculate price difference
    const priceDiff = maxPrice - minPrice;
    
    // Simplified approach for y-axis scaling:
    // 1. Use actual min and max with small padding (never start at 0)
    // 2. Use nice round numbers for the y-axis
    console.log(`[PriceChart] Price range - Min: ${minPrice}, Max: ${maxPrice}, Diff: ${priceDiff}`);
    
    // Calculate a nice round interval for the y-axis
    // Based on the price difference (priceDiff)
    const magnitude = Math.floor(Math.log10(priceDiff));
    const normalizedDiff = priceDiff / Math.pow(10, magnitude);
    
    // Choose a nice interval based on the normalized difference
    let interval: number;
    if (normalizedDiff <= 1.5) {
      interval = 0.2 * Math.pow(10, magnitude); // Use 0.2, 2, 20, etc.
    } else if (normalizedDiff <= 3) {
      interval = 0.5 * Math.pow(10, magnitude); // Use 0.5, 5, 50, etc.
    } else if (normalizedDiff <= 7) {
      interval = 1 * Math.pow(10, magnitude); // Use 1, 10, 100, etc.
    } else {
      interval = 2 * Math.pow(10, magnitude); // Use 2, 20, 200, etc.
    }
    
    // For very small values, make sure the interval is not too small
    if (maxPrice < 0.01) {
      interval = Math.max(interval, Math.pow(10, Math.floor(Math.log10(minPrice)) - 1));
    }
    
    console.log(`[PriceChart] Using interval: ${interval}`);
    
    // Add padding (10% of the price range)
    const axisPadding = priceDiff * 0.1;
    
    // Calculate min/max values for y-axis
    // Round down for min, round up for max
    let yMin = Math.floor((minPrice - axisPadding) / interval) * interval;
    let yMax = Math.ceil((maxPrice + axisPadding) / interval) * interval;
    
    // If min is very close to 0, just use 0
    if (yMin < interval * 0.1) {
      yMin = 0;
    }
    
    // Make sure we have a positive range
    if (yMin >= yMax) {
      yMax = yMin + interval;
    }
    
    // Calculate the range
    const yRange = yMax - yMin;
    
    console.log(`[PriceChart] Final Y-axis range: ${yMin} to ${yMax} (${yRange})`);
    
    // Make sure we have a reasonable number of steps (5-7)
    const numberOfSteps = Math.round(yRange / interval);
    if (numberOfSteps < 3 || numberOfSteps > 8) {
      console.log(`[PriceChart] Adjusting steps: ${numberOfSteps} is outside ideal range`);
      // Adjust the interval if needed
      if (numberOfSteps < 3) {
        // If too few steps, use a smaller interval
        const newInterval = yRange / 5;
        yMin = Math.floor(minPrice / newInterval) * newInterval;
        yMax = Math.ceil(maxPrice / newInterval) * newInterval;
        console.log(`[PriceChart] Adjusted to smaller interval: ${newInterval}`);
      } else if (numberOfSteps > 8) {
        // If too many steps, use a larger interval
        const newInterval = yRange / 5;
        yMin = Math.floor(minPrice / newInterval) * newInterval;
        yMax = Math.ceil(maxPrice / newInterval) * newInterval;
        console.log(`[PriceChart] Adjusted to larger interval: ${newInterval}`);
      }
    }
    
    // Calculate chart area with padding
    const padding = {
      left: 40,
      right: 20,
      top: 30,
      bottom: 25
    };
    
    const chartWidth = canvas.width - padding.left - padding.right;
    const chartHeight = canvas.height - padding.top - padding.bottom;
    
    // Draw background grid
    ctx.beginPath();
    ctx.strokeStyle = '#C0C0C0';
    ctx.lineWidth = 1;
    
    // Calculate how many horizontal grid lines we need based on the interval
    // We want to include both min and max values, so we add 1 to include both ends
    const gridLines = Math.round((yMax - yMin) / interval) + 1;
    
    // Draw horizontal grid lines and y-axis labels
    for (let i = 0; i <= gridLines - 1; i++) {
      const yValue = yMin + i * interval;
      // Calculate relative position of value in the range
      const relativePos = (yValue - yMin) / yRange;
      const y = padding.top + chartHeight - (relativePos * chartHeight);
      
      // Grid line
      ctx.moveTo(padding.left, y);
      ctx.lineTo(padding.left + chartWidth, y);
      
      // Y-axis label with appropriate decimal places based on value size
      ctx.fillStyle = '#000';
      ctx.font = '10px Arial';
      ctx.textAlign = 'right';
      
      // Format with more decimal places for small values
      let formattedValue: string;
      if (yValue < 0.0001) {
        formattedValue = yValue.toExponential(2); // Use scientific notation for very small values
      } else if (yValue < 0.001) {
        formattedValue = yValue.toFixed(6);
      } else if (yValue < 0.01) {
        formattedValue = yValue.toFixed(5);
      } else if (yValue < 0.1) {
        formattedValue = yValue.toFixed(4);
      } else if (yValue < 1) {
        formattedValue = yValue.toFixed(3);
      } else if (yValue < 10) {
        formattedValue = yValue.toFixed(2);
      } else {
        formattedValue = yValue.toFixed(2);
      }
      
      ctx.fillText(formattedValue, padding.left - 5, y + 4);
    }
    
    // Vertical grid lines and x-axis labels - show nice time intervals
    const xAxisSteps = 4; // Show 5 intervals
    
    for (let i = 0; i <= xAxisSteps; i++) {
      const x = padding.left + (i / xAxisSteps) * chartWidth;
      
      // Grid line
      ctx.moveTo(x, padding.top);
      ctx.lineTo(x, padding.top + chartHeight);
      
      // Calculate nice time interval
      const dataIndex = Math.floor((i / xAxisSteps) * (filteredPriceData.length - 1));
      if (dataIndex >= 0 && dataIndex < filteredPriceData.length) {
        const date = new Date(filteredPriceData[dataIndex].timestamp);
        let timeLabel = '';
        
        switch (selectedTimeframe) {
          case '24h':
            // Round to nearest hour
            const roundedHour = date.getHours();
            const amPm = roundedHour >= 12 ? 'PM' : 'AM';
            const hour12 = roundedHour % 12 || 12; // Convert to 12h format
            timeLabel = `${hour12} ${amPm}`;
            break;
          case '7d':
            timeLabel = date.toLocaleDateString([], { weekday: 'short' });
            break;
          case '30d':
          case 'all':
            timeLabel = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            break;
        }
        
        ctx.fillStyle = '#000';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(timeLabel, x, padding.top + chartHeight + 15);
      }
    }
    
    ctx.stroke();
    
    // Draw price line
    ctx.beginPath();
    ctx.strokeStyle = '#000080'; // Navy blue
    ctx.lineWidth = 2;
    
    // Store data points for hover detection
    const points: ChartDataPoint[] = [];
    
    // Sort the data by timestamp to ensure the line is drawn correctly
    const sortedData = [...filteredPriceData].sort((a, b) => a.timestamp - b.timestamp);
    
    sortedData.forEach((data, index) => {
      const x = padding.left + (index / (sortedData.length - 1)) * chartWidth;
      const normalizedPrice = (data.price - yMin) / yRange;
      const y = padding.top + chartHeight - (normalizedPrice * chartHeight);
      
      points.push({
        x,
        y,
        price: data.price,
        timestamp: data.timestamp
      });
      
      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    
    // Update the ref with the current points
    chartPointsRef.current = points;
    
    ctx.stroke();
    
    // Draw latest price
    if (sortedData.length > 0) {
      const latestPrice = sortedData[sortedData.length - 1].price;
      
      // Format price in USD
      const formattedPrice = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 4,
        maximumFractionDigits: 4
      }).format(latestPrice);
      
      ctx.fillStyle = '#000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'right';
      ctx.fillText(`${formattedPrice}`, canvas.width - padding.right, padding.top - 10);
    }
    
    // If there's hover info, draw the indicator
    if (hoverInfo) {
      // Draw the hover indicator
      ctx.beginPath();
      ctx.arc(hoverInfo.x, hoverInfo.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = '#FF0000';
      ctx.fill();
      
      // Draw hover info box - make it wider for small values that need more digits
      const priceValue = parseFloat(hoverInfo.price.replace(/[^0-9.-]+/g, ''));
      const needsWiderBox = priceValue < 0.01 || hoverInfo.price.length > 10;
      
      const boxWidth = needsWiderBox ? 150 : 120;
      const boxHeight = 50;
      const boxX = Math.min(Math.max(hoverInfo.x - boxWidth / 2, 10), canvas.width - boxWidth - 10);
      const boxY = 10;
      
      // Draw box background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
      
      // Draw box border
      ctx.strokeStyle = '#000080';
      ctx.lineWidth = 1;
      ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
      
      // Draw hover info text
      ctx.fillStyle = '#000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`Price: ${hoverInfo.price}`, boxX + 10, boxY + 20); // The price already has a $ symbol
      ctx.fillText(`Time: ${hoverInfo.time}`, boxX + 10, boxY + 40);
    }
    
  }, [filteredPriceData, canvasRef, selectedTimeframe, hoverInfo]);
  
  // Handle mouse events for hover functionality
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const handleMouseMove = (e: MouseEvent) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Use the data points from our ref
      const dataPoints = chartPointsRef.current;
      
      // Find closest data point
      let closestPoint = null;
      let closestDistance = Number.MAX_VALUE;
      
      for (const point of dataPoints) {
        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
        if (distance < closestDistance && distance < 30) { // 30px threshold for "closeness"
          closestDistance = distance;
          closestPoint = point;
        }
      }
      
      if (closestPoint) {
        const date = new Date(closestPoint.timestamp);
        let timeLabel = '';
        
        switch (selectedTimeframe) {
          case '24h':
            timeLabel = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            break;
          case '7d':
            timeLabel = date.toLocaleDateString([], { weekday: 'short' }) + ' ' + 
                      date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            break;
          case '30d':
          case 'all':
            timeLabel = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            break;
        }
        
        // Format price in USD with appropriate decimal places based on value size
        let formattedPrice;
        if (closestPoint.price < 0.0001) {
          // For extremely small values, use scientific notation with currency
          formattedPrice = `$${closestPoint.price.toExponential(4)}`;
        } else {
          // Use Intl formatter with adaptive decimal places
          const decimalPlaces = closestPoint.price < 0.01 ? 6 : 
                               closestPoint.price < 0.1 ? 5 : 
                               closestPoint.price < 1 ? 4 : 
                               closestPoint.price < 10 ? 3 : 2;
                               
          formattedPrice = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: decimalPlaces,
            maximumFractionDigits: decimalPlaces
          }).format(closestPoint.price);
        }
        
        setHoverInfo({
          price: formattedPrice,
          time: timeLabel,
          x: closestPoint.x,
          y: closestPoint.y
        });
      } else {
        setHoverInfo(null);
      }
    };
    
    const handleMouseLeave = () => {
      setHoverInfo(null);
    };
    
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseleave', handleMouseLeave);
    
    return () => {
      canvas.removeEventListener('mousemove', handleMouseMove);
      canvas.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [canvasRef, selectedTimeframe]);

  // Render the chart
  return (
    <div className={styles.priceChartInner}>
      <div>
        <div className={styles.priceChartHeader}>
          <h3 className={styles.priceChartTitle}>{assetName} Price</h3>
        </div>
        <div style={{ position: 'relative' }}>
          <canvas 
            ref={canvasRef} 
            className={styles.priceChartCanvas}
          />

          {/* Show message when chart data is not available */}
          {(!isLoading && filteredPriceData.length === 0) && (
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              backgroundColor: 'rgba(240, 240, 240, 0.7)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              fontSize: '1.4rem',
              fontWeight: 'bold',
              color: '#000080',
              textShadow: '1px 1px 2px white'
            }}>
              Price Chart Not Available
            </div>
          )}

          {/* Show loading indicator */}
          {isLoading && (
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              backgroundColor: 'rgba(240, 240, 240, 0.7)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              fontSize: '1.4rem',
              fontWeight: 'bold',
              color: '#000080',
              textShadow: '1px 1px 2px white'
            }}>
              Loading...
            </div>
          )}

          {/* Show error message */}
          {isError && (
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              backgroundColor: 'rgba(240, 240, 240, 0.7)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              fontSize: '1.4rem',
              fontWeight: 'bold',
              color: '#CC0000',
              textShadow: '1px 1px 2px white'
            }}>
              Error loading price data
            </div>
          )}
        </div>
        <div className={styles.timeframeSelectorBottom}>
          <button 
            className={`${styles.timeframeButton} ${selectedTimeframe === '24h' ? styles.timeframeButtonActive : ''}`} 
            onClick={() => setSelectedTimeframe('24h')}
          >
            24h
          </button>
          <button 
            className={`${styles.timeframeButton} ${selectedTimeframe === '7d' ? styles.timeframeButtonActive : ''}`} 
            onClick={() => setSelectedTimeframe('7d')}
          >
            7d
          </button>
          <button 
            className={`${styles.timeframeButton} ${selectedTimeframe === '30d' ? styles.timeframeButtonActive : ''}`} 
            onClick={() => setSelectedTimeframe('30d')}
          >
            30d
          </button>
          <button 
            className={`${styles.timeframeButton} ${selectedTimeframe === 'all' ? styles.timeframeButtonActive : ''}`} 
            onClick={() => setSelectedTimeframe('all')}
          >
            90d
          </button>
        </div>
      </div>
      
      {/* Collapse Chart button */}
      <button 
        className={styles.collapseChartButton}
        onClick={onClose}
      >
        Collapse Price Chart
      </button>
    </div>
  );
};

export default PriceChart;-e 

==============================================================

-e FILE: src/components/RunesInfoTab.tsx

-e ==============================================================

'use client';

import React, { useState, useEffect, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import debounce from 'lodash.debounce';
import Image from 'next/image';
import styles from './SwapInterface.module.css'; // Reuse styles for now
import {
  type RuneInfo as OrdiscanRuneInfo,
  type RuneMarketInfo as OrdiscanRuneMarketInfo
} from '@/types/ordiscan'; // Import types
import {
  fetchRuneInfoFromApi,
  fetchRuneMarketFromApi,
  fetchRunesFromApi,
  fetchPopularFromApi
} from '@/lib/apiClient'; // Import API functions
import { formatNumberString, truncateTxid } from '@/utils/formatters'; // Import utils
import { FormattedRuneAmount } from './FormattedRuneAmount'; // Import component
import type { Rune } from '@/types/satsTerminal';
import { useRunesInfoStore } from '@/store/runesInfoStore'; // Import the store
import type { RuneData } from '@/lib/runesData';

interface RunesInfoTabProps {
  // Optional props for cached popular runes
  cachedPopularRunes?: Record<string, unknown>[];
  isPopularRunesLoading?: boolean;
  popularRunesError?: Error | null;
  // New props for price chart
  onShowPriceChart?: (assetName?: string, shouldToggle?: boolean) => void;
  showPriceChart?: boolean;
}

export function RunesInfoTab({
  cachedPopularRunes = [],
  isPopularRunesLoading = false,
  popularRunesError = null,
  onShowPriceChart,
  showPriceChart = false
}: RunesInfoTabProps) {
  // --- Get state from zustand store ---
  const {
    selectedRuneInfo: persistedSelectedRuneInfo,
    runeSearchQuery: persistedRuneSearchQuery,
    setSelectedRuneInfo,
    setRuneSearchQuery
  } = useRunesInfoStore();

  // --- Local state and hooks ---
  // Use persisted values for initial state
  const [runeInfoSearchQuery, setLocalRuneInfoSearchQuery] = useState(persistedRuneSearchQuery);
  const [selectedRuneForInfo, setLocalSelectedRuneForInfo] = useState<OrdiscanRuneInfo | null>(persistedSelectedRuneInfo);

  // New states for SatsTerminal search
  const [isSearching, setIsSearching] = useState(false);
  const [searchResults, setSearchResults] = useState<Rune[]>([]);
  const [searchError, setSearchError] = useState<string | null>(null);

  // States for popular runes
  const [isPopularLoading, setIsPopularLoading] = useState(isPopularRunesLoading);
  const [popularRunes, setPopularRunes] = useState<Rune[]>([]);
  const [popularError, setPopularError] = useState<string | null>(
    popularRunesError ? popularRunesError.message : null
  );

  // Query for Selected Rune Details (for details pane)
  const {
    data: detailedRuneInfo,
    isLoading: isDetailedRuneInfoLoading,
    error: detailedRuneInfoError,
  } = useQuery<RuneData | null, Error>({
    queryKey: ['runeInfoApi', selectedRuneForInfo?.name],
    queryFn: () => selectedRuneForInfo ? fetchRuneInfoFromApi(selectedRuneForInfo.name) : Promise.resolve(null),
    enabled: !!selectedRuneForInfo,
    staleTime: Infinity
  });

  // Query for Selected Rune Market Info
  const {
    data: runeMarketInfo,
    isLoading: isRuneMarketInfoLoading,
    error: runeMarketInfoError,
  } = useQuery<OrdiscanRuneMarketInfo | null, Error>({
    queryKey: ['runeMarketApi', selectedRuneForInfo?.name],
    queryFn: () => selectedRuneForInfo ? fetchRuneMarketFromApi(selectedRuneForInfo.name) : Promise.resolve(null),
    enabled: !!selectedRuneForInfo,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Fetch popular runes on mount using SatsTerminal API
  useEffect(() => {
    const fetchPopular = async () => {
      // If we already have cached popular runes, use them directly and don't fetch
      if (cachedPopularRunes && cachedPopularRunes.length > 0) {
        const liquidiumToken: Rune = {
          id: 'liquidiumtoken',
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
        };

        // Map the cached data to Rune format
        const fetchedRunes: Rune[] = cachedPopularRunes
          .map((collection: Record<string, unknown>) => ({
            id: collection?.rune as string || `unknown_${Math.random()}`,
            name: ((collection?.etching as Record<string, unknown>)?.runeName as string) || collection?.rune as string || 'Unknown',
            imageURI: collection?.icon_content_url_data as string || collection?.imageURI as string,
          }))
          .filter(rune => rune.id !== liquidiumToken.id && rune.name !== liquidiumToken.name);

        // Prepend the hardcoded token
        setPopularRunes([liquidiumToken, ...fetchedRunes]);
        setIsPopularLoading(false);
        return;
      }

      // If no cached data, fetch from API - but we shouldn't get here normally
      // as the parent component should always provide cached data
      setIsPopularLoading(true);
      setPopularError(null);
      setPopularRunes([]);
      try {
        // Define the hardcoded asset (using Rune type for consistency in this tab)
        const liquidiumToken: Rune = {
          id: 'liquidiumtoken', // Use a consistent ID
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
          // Add other Rune fields if necessary based on your Rune type definition
        };

        const response = await fetchPopularFromApi();
        let mappedRunes: Rune[] = [];

        if (!Array.isArray(response)) {
          // Even if fetch fails or returns non-array, still show Liquidium
          mappedRunes = [liquidiumToken];
        } else {
          const fetchedRunes: Rune[] = response
            .map((collection: Record<string, unknown>) => ({
              id: collection?.rune as string || `unknown_${Math.random()}`,
              name: ((collection?.etching as Record<string, unknown>)?.runeName as string) || collection?.rune as string || 'Unknown',
              imageURI: collection?.icon_content_url_data as string || collection?.imageURI as string,
              // Map other Rune fields if necessary
            }))
            // Filter out any existing liquidium token from the API result
            .filter(rune => rune.id !== liquidiumToken.id && rune.name !== liquidiumToken.name);

          // Prepend the hardcoded token
          mappedRunes = [liquidiumToken, ...fetchedRunes];
        }

        setPopularRunes(mappedRunes);

      } catch (error) {
        console.error("Error fetching popular runes:", error);
        setPopularError(error instanceof Error ? error.message : 'Failed to fetch popular runes');
        // Still show Liquidium even on error
         const liquidiumTokenOnError: Rune = {
          id: 'liquidiumtoken',
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
        };
        setPopularRunes([liquidiumTokenOnError]);
      } finally {
        setIsPopularLoading(false);
      }
    };
    
    fetchPopular();
    // Run this effect only once on mount, not when props change
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Create a debounced search function - MEMOIZED
  const debouncedSearch = useMemo(() =>
    debounce(async (query: string) => {
      if (!query) {
        setSearchResults([]);
        setIsSearching(false);
        setSearchError(null);
        return;
      }
      setIsSearching(true);
      setSearchError(null);
      try {
        const results: Rune[] = await fetchRunesFromApi(query);
        setSearchResults(results);
      } catch (error: unknown) {
        setSearchError(error instanceof Error ? error.message : 'Failed to search');
        setSearchResults([]);
      } finally {
        setIsSearching(false);
      }
    }, 300),
  []); // <-- Empty dependency array ensures it's created only once

  // Clean up the debounced function on component unmount
  useEffect(() => {
    return () => {
      debouncedSearch.cancel();
    };
  }, [debouncedSearch]);

  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setLocalRuneInfoSearchQuery(query);
    setRuneSearchQuery(query); // Update global store
    setIsSearching(true); // Indicate searching immediately
    debouncedSearch(query);
  };

  // Determine which runes to display
  const availableRunes = runeInfoSearchQuery.trim() ? searchResults : popularRunes;
  const isLoadingRunes = runeInfoSearchQuery.trim() ? isSearching : isPopularLoading;
  const currentRunesError = runeInfoSearchQuery.trim() ? searchError : popularError;

  // Update global store when detailed info changes
  useEffect(() => {
    if (detailedRuneInfo) {
      // Convert RuneData to OrdiscanRuneInfo for compatibility with existing code
      const updatedInfo: OrdiscanRuneInfo = {
        ...detailedRuneInfo,
        formatted_name: detailedRuneInfo.formatted_name || detailedRuneInfo.name,
      } as OrdiscanRuneInfo;
      setSelectedRuneInfo(updatedInfo);
    } else if (detailedRuneInfoError && selectedRuneForInfo) {
      // On error, use the minimal info in the global store
      setSelectedRuneInfo(selectedRuneForInfo);
    }
  }, [detailedRuneInfo, detailedRuneInfoError, selectedRuneForInfo, setSelectedRuneInfo]);

  // Handle rune selection
  const handleRuneSelect = (rune: Rune) => {
    // Create minimal rune info for immediate UI feedback
    const minimalRuneInfo = {
      id: rune.id,
      name: rune.name,
      formatted_name: rune.name,
      symbol: rune.name.split('â€¢')[0] || rune.name,
      decimals: 0,
      number: 0,
      etching_txid: '',
      premined_supply: '0',
      current_supply: '0',
    } as OrdiscanRuneInfo;

    // Update local state with minimal info
    setLocalSelectedRuneForInfo(minimalRuneInfo);

    // Update price chart if it's visible
    if (showPriceChart && onShowPriceChart) {
      onShowPriceChart(rune.name, false); // Update chart without toggling visibility
    }
  };

  return (
    <div className={styles.runesInfoTabContainer}>
      <div className={styles.searchAndResultsContainer}>
        <div className={styles.searchContainerRunesInfo}>
          <div className={styles.searchWrapper}>
            <Image
              src="/icons/magnifying_glass-0.png"
              alt="Search"
              className={styles.searchIconEmbedded}
              width={16}
              height={16}
            />
            <input
              type="text"
              placeholder="Search runes..."
              value={runeInfoSearchQuery}
              onChange={handleSearchChange}
              className={styles.searchInput}
            />
          </div>
        </div>

        <div className={styles.runesListContainer}>
          {isLoadingRunes && (
            <div className={styles.listboxLoadingOrEmpty}>
              {runeInfoSearchQuery.trim()
                ? `Searching for "${runeInfoSearchQuery}"...`
                : 'Loading Latest Runes...'}
            </div>
          )}
          {currentRunesError && (
            <div className={`${styles.listboxError} ${styles.messageWithIcon}`}>
              <Image
                src="/icons/msg_error-0.png"
                alt="Error"
                className={styles.messageIcon}
                width={16}
                height={16}
              />
              <span>{currentRunesError}</span>
            </div>
          )}
          {!isLoadingRunes && !currentRunesError && availableRunes.length === 0 && (
            <div className={styles.listboxLoadingOrEmpty}>
              {runeInfoSearchQuery.trim()
                ? `Rune "${runeInfoSearchQuery}" not found.`
                : 'No recent runes found'}
            </div>
          )}
          {!isLoadingRunes && !currentRunesError && availableRunes.map((rune) => (
            <button
              key={rune.id}
              className={`${styles.runeListItem} ${selectedRuneForInfo?.name === rune.name ? styles.runeListItemSelected : ''}`}
              onClick={() => handleRuneSelect(rune)}
            >
              <div className={styles.runeListItemContent}>
                {rune.imageURI && (
                  <Image
                    src={rune.imageURI}
                    alt=""
                    className={styles.runeImage}
                    width={24}
                    height={24}
                    onError={(e) => {
                      // Handle error in Next Image component by setting display to none
                      const target = e.target as HTMLImageElement;
                      if (target) {
                        target.style.display = 'none';
                      }
                    }}
                  />
                )}
                <span>{rune.name}</span>
              </div>
            </button>
          ))}
        </div>
      </div>

      <div className={styles.searchAndResultsContainer}>
        <div className={`${styles.runeDetailsContainer} ${showPriceChart ? styles.narrowRightPanel : ''}`}>
          {isDetailedRuneInfoLoading && selectedRuneForInfo && <p>Loading details for {selectedRuneForInfo.formatted_name}...</p>}
          {detailedRuneInfoError && selectedRuneForInfo && <p className={styles.errorText}>Error loading details: {detailedRuneInfoError.message}</p>}
          {!isDetailedRuneInfoLoading && detailedRuneInfo && (
            <div>
              <h3>{detailedRuneInfo.formatted_name} ({detailedRuneInfo.symbol})</h3>
              <p><strong>ID:</strong> {detailedRuneInfo.id}</p>
              <p><strong>Number:</strong> {detailedRuneInfo.number}</p>
              <p><strong>Decimals:</strong> {detailedRuneInfo.decimals}</p>
              <p>
                <strong>Etching Tx:</strong> {detailedRuneInfo.etching_txid ?
                  <a
                    href={`https://ordiscan.com/tx/${detailedRuneInfo.etching_txid}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className={styles.etchingTxLink}
                  >
                    {truncateTxid(detailedRuneInfo.etching_txid)}
                  </a>
                : 'N/A'
                }
              </p>
              {/* Price Information */}
              {runeMarketInfo && (
                <>
                  <p><strong>Price:</strong> <span className={styles.priceHighlight}>{runeMarketInfo.price_in_usd.toFixed(6)} USD</span> ({runeMarketInfo.price_in_sats.toFixed(2)} sats)</p>
                  <p><strong>Market Cap:</strong> {runeMarketInfo.market_cap_in_usd.toLocaleString()} USD</p>
                </>
              )}
              {isRuneMarketInfoLoading && (
                <p><strong>Price:</strong> <span className={styles.loadingText}>Loading market data...</span></p>
              )}
              {runeMarketInfoError && (
                <p><strong>Price:</strong> <span className={styles.errorText}>Market data unavailable: {runeMarketInfoError.message}</span></p>
              )}
              <p><strong>Premined Supply:</strong>{' '}
                <FormattedRuneAmount
                  runeName={detailedRuneInfo.name}
                  rawAmount={detailedRuneInfo.premined_supply}
                />
              </p>
              <p><strong>Total Supply:</strong> {detailedRuneInfo.current_supply !== undefined ?
                <FormattedRuneAmount
                  runeName={detailedRuneInfo.name}
                  rawAmount={detailedRuneInfo.current_supply}
                />
                : 'N/A'
              }</p>
              {/* Use FormattedRuneAmount for Amount/Mint */}
              {detailedRuneInfo.amount_per_mint !== null && detailedRuneInfo.amount_per_mint !== undefined &&
                <p><strong>Amount/Mint:</strong>{' '}
                  <FormattedRuneAmount
                    runeName={detailedRuneInfo.name}
                    rawAmount={detailedRuneInfo.amount_per_mint}
                  />
                </p>
              }
              {/* Keep using formatNumberString for mint_count_cap as it doesn't inherently have decimals */}
              {detailedRuneInfo.mint_count_cap && <p><strong>Mint Cap:</strong> {formatNumberString(detailedRuneInfo.mint_count_cap)}</p>}
              {detailedRuneInfo.mint_start_block !== null && <p><strong>Mint Start Block:</strong> {detailedRuneInfo.mint_start_block}</p>}
              {detailedRuneInfo.mint_end_block !== null && <p><strong>Mint End Block:</strong> {detailedRuneInfo.mint_end_block}</p>}
              {detailedRuneInfo.current_mint_count !== undefined && <p><strong>Current Mint Count:</strong> {detailedRuneInfo.current_mint_count?.toLocaleString() || 'N/A'}</p>}

              {/* Add Price Chart Button */}
              {onShowPriceChart && (
                <div className={styles.showPriceChartButtonContainer}>
                  <button
                    className={styles.showPriceChartButton}
                    onClick={() => onShowPriceChart(detailedRuneInfo.name, true)}
                  >
                    {showPriceChart ? 'Hide Price Chart' : 'Show Price Chart'}
                  </button>
                </div>
              )}
            </div>
          )}
          {/* Display hint only if no rune is selected and not currently loading */}
          {!selectedRuneForInfo && !isDetailedRuneInfoLoading && (
            <p className={styles.hintText}>Select a rune from the list or search by name.</p>
          )}
        </div>
      </div>
    </div>
  );
}

export default RunesInfoTab;-e 

==============================================================

-e FILE: src/components/SwapInterface.module.css

-e ==============================================================

/* src/components/SwapInterface.module.css */

.container {
  padding: 0;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 1rem;
  min-height: 450px;
}

.appLayout {
  display: flex;
  flex-direction: row;
  gap: 1rem;
  width: 100%;
  padding: 0;
}

/* Container with price chart visible takes up more space */
.containerWithChart {
  padding: 0;
}

.containerWithChart .appLayout {
  padding: 0;
  max-width: 100%;
  margin: 0;
}

.title {
  font-size: 1.125rem; /* text-lg */
  line-height: 1.75rem; /* text-lg */
  font-weight: 700; /* font-bold */
  /* margin-top: 1rem; */ /* Remove compensating margin */
}

.inputArea {
  padding: 0.5rem; /* p-2 */
  display: flex;
  flex-direction: column;
  gap: 0.25rem; /* space-y-1 */
  border-width: 2px;
  border-style: solid;
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  border-left-color: var(--win98-dark-gray);
  border-top-color: var(--win98-dark-gray);
  background-color: var(--win98-white);
  /* margin-top: 1rem; */ /* Remove compensating margin */
  width: 100%; /* Set width to 100% of container */
  min-width: auto; /* Override min-width for narrow containers */
}

/* Special case for input area when in narrowed container */
.narrowSwapContainer .inputArea {
  min-width: auto;
  width: 100%;
}

.inputLabel {
  font-size: 0.75rem; /* text-xs */
  line-height: 1rem; /* text-xs */
}

.inputHeader {
  display: flex;
  justify-content: space-between;
  align-items: baseline; /* Align baselines of label and balance text */
  width: 100%; /* Ensure it takes full width */
}

.availableBalance {
  font-size: 0.7rem; /* Smaller than label */
  line-height: 1rem;
  color: var(--win98-dark-gray);
  text-align: right;
  margin-left: 0.5rem; /* Add some space between label and balance */
}

.inputRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.amountInput {
  background-color: transparent;
  font-size: 1.25rem; /* text-xl */
  line-height: 1.75rem; /* text-xl */
  width: 100%;
  outline: none;
  padding: 0.25rem; /* p-1 */
}

.amountInput::placeholder {
  color: var(--win98-dark-gray);
}

/* Style for the input USD value display */
.usdValueText {
  font-size: 0.75rem; /* text-xs */
  color: var(--win98-dark-gray);
  text-align: left; /* Align with the input field */
  padding-left: 0.25rem; /* Align roughly with input text */
  margin-top: 0.1rem; /* Small space below input */
}

.amountInputReadOnly {
  composes: amountInput; /* Inherit base input styles */
  color: var(--win98-dark-gray); /* text-gray-500 approximation */
}

.assetButton {
  font-weight: 700; /* font-bold */
  padding: 0.25rem; /* p-1 */
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-size: 0.875rem; /* text-sm */
  flex-shrink: 0;
  width: 5rem; /* w-20 approximation */
}

/* Wrapper for asset button image + text */
.assetButtonContent {
  display: flex;
  align-items: center;
  justify-content: center; /* Center content within the button */
}

/* Style for the asset image within the button */
.assetButtonImage {
  height: 1.25rem; /* h-5 */
  width: 1.25rem; /* w-5 */
  margin-right: 0.5rem; /* mr-2 */
  flex-shrink: 0;
  /* Disable image smoothing */
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

.assetButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.swapButton {
  width: 100%;
  padding: 0.5rem 1rem; /* Increased vertical padding slightly for better feel */
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  color: var(--win98-black);
  font-weight: 700; /* font-bold */
}

.swapButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.swapButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  color: var(--win98-dark-gray);
}

.errorText {
  font-size: 0.75rem; /* text-xs */
  padding-top: 0.5rem; /* pt-2 */
  color: #dc2626; /* text-red-600 */
}

/* Style for quote-specific errors */
.quoteErrorText {
  composes: errorText; /* Inherit base error styles */
  padding-top: 0.25rem; /* pt-1, smaller top padding */
  width: 100%; /* Ensure it takes full width */
  color: var(--win98-red);
}

/* Style for swap success message */
.successText {
  font-size: 0.75rem; /* text-xs */
  padding-top: 0.5rem; /* pt-2 */
  color: #16a34a; /* text-green-600 approximation */
}

/* Style for transaction links in the swap success message or Tx list */
.txLink {
  color: #0000EE; /* Visited link color - adjust if needed */
  text-decoration: underline;
  margin-left: 0.5em;
}

.txLink:hover {
  color: #551A8B; /* Hover color - adjust if needed */
}

/* NEW: Specific style for the etching tx link */
.etchingTxLink {
  color: var(--win98-dark-blue);
  text-decoration: underline;
}

.etchingTxLink:hover {
  text-decoration: none;
}

.txLinkBold {
  composes: txLink; /* Inherit base link styles */
  font-weight: bold;
  font-size: 0.85rem;
}

.txTimestamp {
  color: var(--win98-dark-gray);
  font-size: 0.75rem;
}

.txDetails {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  padding-left: 0.5rem; /* Indent details slightly */
}

.txDetailRow {
  display: flex;
  justify-content: space-between;
}

/* Highlight rune names in tx details */
.runeNameHighlight {
  font-weight: bold;
  color: var(--win98-blue); /* Or another distinct color */
}

/* Container for messages with icons */
.messageWithIcon {
  display: flex;
  align-items: center;
  gap: 0.5rem; /* space-x-2 */
}

/* Style for message icons (error, warning, etc.) */
.messageIcon {
  width: 1rem; /* w-4 */
  height: 1rem; /* h-4 */
  flex-shrink: 0; /* Prevent icon from shrinking */
  /* Disable image smoothing */
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* New Info Area Styles */
.infoArea {
  margin-top: 1rem; /* mt-4 */
  padding-top: 1rem; /* pt-4 */
  border-top: 2px solid var(--win98-dark-gray);
  font-size: 0.875rem; /* text-sm */
  color: var(--win98-black);
  display: flex;
  flex-direction: column;
  gap: 0.5rem; /* space-y-2 */
}

.infoRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Headless UI Listbox Styles */
.listboxContainer {
  flex-shrink: 0;
}

.listboxRelative {
  position: relative;
}

.listboxButton {
  position: relative;
  width: 100%;
  cursor: default;
  background-color: var(--win98-gray);
  padding: 0.25rem 2.5rem 0.25rem 0.75rem; /* py-1 pl-3 pr-10 */
  text-align: left;
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-size: 0.875rem; /* text-sm */
}

.listboxButton:focus {
  outline: none;
  /* Add focus ring styles if desired */
}

.listboxButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.listboxButtonText {
  display: flex;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
  font-weight: 700; /* font-bold */
}

.listboxButtonIconContainer {
  pointer-events: none;
  position: absolute;
  inset: 0 0 0 auto; /* Equivalent to inset-y-0 right-0 */
  display: flex;
  align-items: center;
  padding-right: 0.5rem; /* pr-2 */
}

.listboxButtonIcon {
  height: 1.25rem; /* h-5 */
  width: 1.25rem; /* w-5 */
  color: #4b5563; /* text-gray-700 approximation */
}

.listboxOptions {
  position: absolute;
  right: 0; /* Align right edge with the button's right edge */
  margin-top: 0.25rem; /* mt-1 */
  max-height: 15rem; /* max-h-60 */
  min-width: 100%; /* Ensure it's at least as wide as the button */
  width: max-content; /* Allow dropdown to expand for long names */
  /* Remove scrollbar but keep scrolling functionality */
  overflow-y: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE/Edge */
  background-color: var(--win98-gray); /* Match other UI elements */
  padding: 0.25rem 0; /* py-1 */
  font-size: 0.875rem; /* sm:text-sm */
  /* ring-1 ring-black/5 approximation */
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  z-index: 20; /* Added z-index */
}

/* Hide webkit scrollbar */
.listboxOptions::-webkit-scrollbar {
  display: none;
}

.listboxOption {
  position: relative;
  cursor: default;
  user-select: none;
  padding: 0.5rem 1rem 0.5rem 2.5rem; /* py-2 pl-10 pr-4 */
}

.listboxOptionActive {
  background-color: var(--win98-blue);
  color: var(--win98-white);
}

.listboxOptionInactive {
  color: var(--win98-black);
}

.listboxOptionText {
  display: block;
  white-space: nowrap; /* Ensure full name is visible on one line */
  padding: 0.25rem 0; /* Add some padding */
}

.listboxOptionTextSelected {
  font-weight: 500; /* font-medium */
}

.listboxOptionTextUnselected {
  font-weight: 400; /* font-normal */
}

.listboxOptionCheckContainer {
  position: absolute;
  inset: 0 0 0 0; /* Equivalent to inset-y-0 left-0 */
  display: flex;
  align-items: center;
  padding-left: 0.75rem; /* pl-3 */
  color: var(--win98-blue);
}

.listboxOptionCheckIcon {
  height: 1.25rem; /* h-5 */
  width: 1.25rem; /* w-5 */
}

.listboxLoadingOrEmpty {
  position: relative;
  cursor: default;
  user-select: none;
  padding: 0.5rem 1rem; /* py-2 px-4 */
  color: #4b5563; /* text-gray-700 approximation */
}

.listboxError {
  composes: listboxLoadingOrEmpty;
  color: var(--win98-red);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* Add styles for the search container */
.searchContainer {
  padding: 0.5rem; /* p-2 */
  border-bottom: 1px solid var(--win98-dark-gray);
}

.searchWrapper { /* New wrapper for input + icon */
  position: relative;
  display: flex;
  align-items: center;
}

.searchInput {
  width: 100%;
  padding: 0.375rem 0.5rem; /* py-1.5 px-2 */
  padding-left: 2rem; /* Make space for the icon */
  background-color: var(--win98-white);
  border: 1px solid var(--win98-dark-gray);
  color: var(--win98-black);
  font-size: 0.875rem; /* text-sm */
}

.searchInput:focus {
  outline: 1px solid var(--win98-blue);
}

/* Style for the embedded search icon */
.searchIconEmbedded {
  position: absolute;
  left: 0.5rem; /* pl-2 */
  top: 50%;
  transform: translateY(-50%);
  height: 1rem; /* h-4 */
  width: 1rem; /* w-4 */
  color: var(--win98-dark-gray); /* text-gray-500 approximation */
  pointer-events: none; /* Don't interfere with input clicks */
  /* Disable image smoothing */
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* Remove old search form/button styles if they exist */
.searchForm {
  /* Remove or comment out */
}

.searchButton {
   /* Remove or comment out */
}

/* Style for the rune image in the dropdown */
.runeImage {
  height: 1.25rem; /* h-5 */
  width: 1.25rem; /* w-5 */
  margin-right: 0.5rem; /* mr-2 */
  flex-shrink: 0;
  /* Disable image smoothing */
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* Wrapper for rune image + text in dropdown option */
.runeOptionContent {
  display: flex;
  align-items: center; 
}

/* Add styles for the swap direction button */
.swapIconContainer {
  display: flex;
  justify-content: center;
  padding: 0.5rem 0; /* Add some vertical spacing */
}

.swapIconButton {
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  padding: 0.25rem; /* p-1 */
  line-height: 1; /* Ensure icon aligns well */
}

.swapIconButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.swapIconButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.swapIcon {
  width: 1.5rem; /* h-6 */
  height: 1.5rem; /* w-6 */
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
  .appLayout {
    flex-direction: column;
    gap: 1rem;
    width: 100%;
  }

  .container {
    width: 100%;
    padding: 0;
  }

  .containerWithChart .runesInfoContainer,
  .containerWithChart .swapContainer,
  .swapContainer,
  .runesInfoContainer,
  .priceChartContainer {
    max-width: 100%;
    width: 100%;
  }

  .priceChartContainer {
    position: static;
    height: auto;
    margin-top: 1rem;
  }

  .narrowSwapContainer,
  .narrowRightPanel {
    width: 100%;
    max-width: 100%;
  }

  .inputRow {
    flex-direction: column;
    align-items: stretch;
    gap: 0.5rem;
  }

  .amountInput,
  .amountInputReadOnly {
    font-size: 1.125rem;
    text-align: left;
  }

  .listboxContainer,
  .listboxButton {
    width: 100%;
  }

  .title {
    font-size: 1rem;
  }

  .inputArea {
    min-width: 100%;
    width: 100%;
    margin: 0;
  }
}

/* --- Runes Info Tab Styles --- */
.runesInfoTabContainer {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  white-space: nowrap;
}

/* Create a container that wraps both the search and results */
.searchAndResultsContainer {
  display: flex;
  flex-direction: column;
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  background-color: var(--win98-gray);
  overflow: hidden; /* Ensure no gaps between children */
  width: 100%;
  box-sizing: border-box;
  margin: 0;
  max-width: 100%;
}

.searchContainerRunesInfo {
  padding: 0.25rem;
  background-color: var(--win98-gray);
  /* Remove all borders as parent container handles them */
  border: none;
  margin: 0;
  position: relative;
}

/* Special style for search input in runes info tab */
.searchContainerRunesInfo .searchInput {
  border: 1px solid var(--win98-dark-gray);
  border-width: 1px;
  background-color: var(--win98-white);
  width: 100%;
}

.runesListContainer {
  max-height: 200px; 
  overflow-y: auto; 
  background-color: var(--win98-gray);
  padding: 0.25rem 0; 
  display: flex;
  flex-direction: column;
  gap: 0;
  /* Remove all borders as parent container handles them */
  border: none;
  /* Add a subtle separator */
  border-top: 1px solid var(--win98-dark-gray);
}

.runeListItem {
  padding: 0.5rem 1rem;
  border: 1px solid transparent; 
  background-color: transparent;
  text-align: left;
  width: 100%;
  font-family: inherit;
  font-size: 0.875rem;
  cursor: default; 
  color: var(--win98-black);
}

/* Ensure hover state applies correctly (match listboxOptionActive) */
.runeListItem:hover {
  background-color: var(--win98-blue);
  color: var(--win98-white);
}

/* Ensure selected state applies correctly */
.runeListItemSelected {
  background-color: var(--win98-highlight); 
  color: var(--win98-highlight-text);
}

.runeListItemContent {
  display: flex;
  align-items: center;
}

.hintText {
  color: var(--win98-dark-gray);
  font-style: italic;
  font-size: 0.875rem;
  text-align: center;
  padding: 1rem;
}

.loadingText {
  font-style: italic;
  color: var(--win98-dark-gray);
}

.errorText {
  color: var(--win98-red);
}

/* --- Styles for Your TXs Tab --- */
.yourTxsTabContainer {
  /* Similar padding/spacing as other tabs */
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.txListContainer {
  max-height: 350px; /* Or adjust as needed */
  overflow-y: auto;
  border: 1px solid var(--win98-dark-gray);
  padding: 0.5rem;
  background-color: var(--win98-white);
  /* Win98 scrollbar styling (optional, complex) */
}

.txListItem {
  border-bottom: 1px solid var(--win98-light-gray);
  padding: 0.75rem 0.5rem;
  font-size: 0.8rem; /* Smaller font for tx list */
}

.txListItem:last-child {
  border-bottom: none;
}

.txHeader {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-bottom: 0.5rem;
}

/* --- New BTC Price Footer Styles --- */
.btcPriceFooter {
  position: fixed;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  padding: 0.25rem 0.75rem; /* Smaller padding */
  background-color: var(--win98-gray);
  border: 2px solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  z-index: 10; /* Ensure it's above other content if needed */
  font-size: 0.875rem; /* text-sm */
  color: var(--win98-black);
  display: flex; /* Use flex to space content */
  justify-content: space-between; /* Push social links to the right */
  gap: 0.5rem; /* Space between "BTC Price:" and the value */
  align-items: center;
  width: auto; /* Allow width to adjust based on content */
  min-width: 300px; /* Ensure minimum width for readability */
  max-width: 90%; /* Don't exceed screen width on small devices */
  /* Optional: Add a subtle shadow like buttons */
  /* box-shadow: 2px 2px 0px 0px var(--win98-black); */
}

/* Ensure text within the footer looks okay */
.btcPriceFooter span {
  /* No specific overrides needed for now */
}

.socialLinks {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-left: auto; /* Push social links to the right */
}

.docsButton {
  color: var(--win98-blue);
  font-size: 0.875rem;
  text-decoration: none;
  padding: 0.25rem 0.5rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
}

.docsButton:hover {
  background-color: var(--win98-light-gray);
}

.docsButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.socialLink {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 22px;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
}

.socialLink:hover {
  background-color: var(--win98-light-gray);
}

.socialLink:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

/* Price styling */
.priceHighlight {
  color: var(--win98-dark-green);
  font-weight: bold;
}

/* Price Chart Styles */
.swapContainer {
  flex: 1;
  width: 100%;
  transition: all 0.3s ease;
}

.narrowSwapContainer {
  max-width: calc(50% - 0.5rem); /* Exactly 50% of the width minus half the gap */
  width: calc(50% - 0.5rem);
  transition: all 0.3s ease;
  margin: 0; /* Ensure no margin when in narrow mode */
}

.priceChartContainer {
  padding: 0.5rem;
  border-width: 2px;
  border-style: solid;
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  border-left-color: var(--win98-light-gray);
  border-top-color: var(--win98-light-gray);
  background-color: var(--win98-gray);
  max-width: calc(50% - 0.5rem); /* Exactly 50% of the width minus half the gap */
  width: calc(50% - 0.5rem); /* Ensuring exact 50/50 split */
  flex: 0 0 calc(50% - 0.5rem); /* Do not grow, do not shrink, fixed width */
  min-height: auto;
  max-height: auto;
  margin: 0; /* Ensure no margin */
}

.priceChartInner {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  position: relative;
  height: 100%;
}

.priceChartHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.priceChartTitle {
  font-size: 1rem;
  font-weight: bold;
  margin: 0;
}

.timeframeSelectorBottom {
  display: flex;
  justify-content: center;
  gap: 0.25rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}

.timeframeButton {
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
}

.timeframeButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.timeframeButtonActive {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  background-color: var(--win98-navy);
  color: var(--win98-white);
}

.priceChartCanvas {
  width: 100%;
  height: 250px;
  border-width: 2px;
  border-style: solid;
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  border-left-color: var(--win98-dark-gray);
  border-top-color: var(--win98-dark-gray);
  background-color: var(--win98-white);
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  cursor: crosshair; /* Change cursor to crosshair when hovering over the chart */
}

.showPriceChartButton {
  width: 100%;
  padding: 0.5rem;
  margin-top: 0.5rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-weight: 700;
  cursor: pointer;
}

.showPriceChartButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

/* ... Rest of CSS ... */

.collapseChartButton {
  width: 100%;
  padding: 0.5rem;
  margin: 0;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-weight: 700;
  cursor: pointer;
  margin-top: auto; /* Push button to bottom */
}

.collapseChartButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

/* Apply mobile layout to narrowSwapContainer */
.narrowSwapContainer .inputRow {
  flex-direction: column; /* Stack input and selector vertically */
  align-items: stretch; /* Make children take full width */
  gap: 0.5rem; /* Add space between input and selector */
}

.narrowSwapContainer .amountInput,
.narrowSwapContainer .amountInputReadOnly {
  font-size: 1.125rem; /* text-lg - Slightly smaller font */
  text-align: left; /* Ensure text starts left */
}

.narrowSwapContainer .listboxContainer {
  width: 100%; /* Make selector take full width */
}

.narrowSwapContainer .listboxButton {
  width: 100%; /* Ensure button takes full width */
}

/* Style for narrowed rune details panel when price chart is visible */
.narrowRightPanel {
  width: calc(100% - 20px);
  transition: width 0.3s ease;
}

@media (max-width: 768px) {
  .appLayout {
    flex-direction: column;
  }
  
  .priceChartContainer {
    position: static;
    width: 100%;
    height: 300px;
    margin-top: 1rem;
  }
  
  .swapContainer {
    width: 100%;
  }
  
  .narrowSwapContainer {
    width: 100%;
  }
  
  /* Update narrowRightPanel for mobile */
  .narrowRightPanel {
    width: 100%;
  }
}

/* Container for the price chart show/hide button */
.showPriceChartButtonContainer {
  display: flex;
  justify-content: center;
  margin-top: 1rem;
  width: 100%;
}

.showPriceChartButton {
  width: 100%;
  padding: 0.5rem;
  margin-top: 0.5rem;
  background-color: var(--win98-gray);
  border-width: 2px;
  border-style: solid;
  border-top-color: var(--win98-light-gray);
  border-left-color: var(--win98-light-gray);
  border-right-color: var(--win98-dark-gray);
  border-bottom-color: var(--win98-dark-gray);
  font-weight: 700;
  cursor: pointer;
}

.showPriceChartButton:active {
  border-top-color: var(--win98-dark-gray);
  border-left-color: var(--win98-dark-gray);
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
}

.runesInfoContainer {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* When the price chart is visible */
.containerWithChart .runesInfoContainer,
.containerWithChart .swapContainer {
  max-width: calc(50% - 0.5rem);
  width: calc(50% - 0.5rem);
}

@media (max-width: 768px) {
  .container {
    width: 100%;
    padding: 0;
  }

  .containerWithChart .runesInfoContainer,
  .containerWithChart .swapContainer,
  .swapContainer,
  .runesInfoContainer,
  .priceChartContainer {
    max-width: 100%;
    width: 100%;
  }

  .priceChartContainer {
    position: static;
    height: auto;
    margin-top: 1rem;
  }

  .narrowSwapContainer,
  .narrowRightPanel {
    width: 100%;
    max-width: 100%;
  }
}

.runeDetailsContainerWrapper {
  padding: 0;
  margin: 0;
  width: 100%;
  display: flex;
  flex-direction: column;
}

.runeDetailsContainer {
  padding: 0.5rem;
  background-color: var(--win98-white);
  min-height: 100px;
  width: 100%; 
  box-sizing: border-box;
  margin: 0;
  border: 2px solid;
  border-right-color: var(--win98-light-gray);
  border-bottom-color: var(--win98-light-gray);
  border-left-color: var(--win98-dark-gray);
  border-top-color: var(--win98-dark-gray);
}

.runeDetailsContainer h3 {
  font-weight: bold;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid var(--win98-dark-gray);
  padding-bottom: 0.25rem;
}

.runeDetailsContainer p {
  margin-bottom: 0.25rem;
  font-size: 0.875rem;
}

.hintText {
  color: var(--win98-dark-gray);
  font-style: italic;
  font-size: 0.875rem;
  text-align: center;
  padding: 1rem;
} -e 

==============================================================

-e FILE: src/components/SwapInterface.tsx

-e ==============================================================

'use client';

import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useSharedLaserEyes } from '@/context/LaserEyesContext';
import styles from './SwapInterface.module.css';
import { fetchPopularFromApi, QUERY_KEYS } from '@/lib/apiClient';

// Import the tab components
import SwapTab from './SwapTab';
import RunesInfoTab from './RunesInfoTab';
import YourTxsTab from './YourTxsTab';
import PortfolioTab from './PortfolioTab';
import FooterComponent from './FooterComponent';
import PriceChart from './PriceChart';

// CoinGecko API endpoint
const COINGECKO_BTC_PRICE_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd';

// Function to fetch BTC price
const getBtcPrice = async (): Promise<number> => {
  const response = await fetch(COINGECKO_BTC_PRICE_URL);
  if (!response.ok) {
    throw new Error('Failed to fetch BTC price from CoinGecko');
  }
  const data = await response.json();
  if (!data.bitcoin || !data.bitcoin.usd) {
    throw new Error('Invalid response format from CoinGecko');
  }
  return data.bitcoin.usd;
};

// --- Props Interface ---
interface SwapInterfaceProps {
  activeTab: 'swap' | 'runesInfo' | 'yourTxs' | 'portfolio';
}
// --- End Props --- 

// --- Component ---
export function SwapInterface({ activeTab }: SwapInterfaceProps) {
  // Get URL parameters
  const searchParams = new URLSearchParams(typeof window !== 'undefined' ? window.location.search : '');
  const preSelectedRune = searchParams.get('rune');

  // Separate state for showing/hiding price chart for each tab
  const [showSwapTabPriceChart, setShowSwapTabPriceChart] = useState(false);
  const [showRunesInfoTabPriceChart, setShowRunesInfoTabPriceChart] = useState(false);
  
  // State for selected assets for each tab
  const [swapTabSelectedAsset, setSwapTabSelectedAsset] = useState(preSelectedRune || "LIQUIDIUMâ€¢TOKEN");
  const [runesInfoTabSelectedAsset, setRunesInfoTabSelectedAsset] = useState("LIQUIDIUMâ€¢TOKEN");

  // Update swapTabSelectedAsset when preSelectedRune changes
  React.useEffect(() => {
    if (preSelectedRune) {
      setSwapTabSelectedAsset(preSelectedRune);
    }
  }, [preSelectedRune]);

  // LaserEyes hook for wallet info and signing
  const { 
    connected, 
    address, 
    publicKey, 
    paymentAddress, 
    paymentPublicKey, 
    signPsbt
  } = useSharedLaserEyes();

  // Fetch BTC price using React Query
  const {
    data: btcPriceUsd,
    isLoading: isBtcPriceLoading,
    error: btcPriceError,
  } = useQuery<number, Error>({
    queryKey: ['btcPriceUsd'],
    queryFn: getBtcPrice,
    refetchInterval: 60000, // Refetch every 60 seconds
    staleTime: 30000, // Consider data stale after 30 seconds
  });

  // Fetch popular runes using React Query for caching across tabs
  const {
    data: popularRunes,
    isLoading: isPopularRunesLoading,
    error: popularRunesError
  } = useQuery<Record<string, unknown>[], Error>({
    queryKey: [QUERY_KEYS.POPULAR_RUNES],
    queryFn: () => {
      console.log('[SwapInterface] Fetching popular runes...');
      return fetchPopularFromApi();
    },
    staleTime: Infinity, // Data never goes stale, so React Query won't refetch
    gcTime: 365 * 24 * 60 * 60 * 1000, // Keep in cache for a year
    refetchOnMount: false, // Don't refetch when component mounts
    refetchOnWindowFocus: false, // Don't refetch when window regains focus
    refetchOnReconnect: false, // Don't refetch on reconnect
    retry: false, // Don't retry on failure
  });

  // Handler for toggling the price chart based on active tab
  const togglePriceChart = React.useCallback((assetName?: string, shouldToggle: boolean = true) => {
    if (activeTab === 'swap') {
      if (assetName) {
        setSwapTabSelectedAsset(assetName);
      }
      if (shouldToggle) {
        setShowSwapTabPriceChart(prev => !prev);
      }
    } else if (activeTab === 'runesInfo') {
      if (assetName) {
        setRunesInfoTabSelectedAsset(assetName);
      }
      if (shouldToggle) {
        setShowRunesInfoTabPriceChart(prev => !prev);
      }
    }
  }, [activeTab]);

  // Listen for tabChange events specifically for rune selection
  React.useEffect(() => {
    const handleTabChangeEvent = (event: CustomEvent) => {
      const { tab, rune } = event.detail;
      
      if (tab === 'swap' && rune) {
        // Update the swap tab selected asset directly
        setSwapTabSelectedAsset(rune);
        
        // If price chart is visible, update the selected asset there too
        if (showSwapTabPriceChart) {
          togglePriceChart(rune, false);
        }
      }
    };

    window.addEventListener('tabChange', handleTabChangeEvent as EventListener);
    return () => window.removeEventListener('tabChange', handleTabChangeEvent as EventListener);
  }, [showSwapTabPriceChart, togglePriceChart]);

  // Determine if price chart should be shown based on active tab
  const isPriceChartVisible = activeTab === 'swap' ? showSwapTabPriceChart : 
                             activeTab === 'runesInfo' ? showRunesInfoTabPriceChart : 
                             false;
  
  // Get the selected asset for the active tab
  const selectedAssetForActiveTab = activeTab === 'swap' ? swapTabSelectedAsset : 
                                   activeTab === 'runesInfo' ? runesInfoTabSelectedAsset : 
                                   "";
  // Render the active tab content
  const renderActiveTab = () => {
    switch (activeTab) {
      case 'swap':
        return (
          <SwapTab
            connected={connected}
            address={address}
            paymentAddress={paymentAddress}
            publicKey={publicKey}
            paymentPublicKey={paymentPublicKey}
            signPsbt={signPsbt}
            btcPriceUsd={btcPriceUsd}
            isBtcPriceLoading={isBtcPriceLoading}
            btcPriceError={btcPriceError}
            cachedPopularRunes={popularRunes || []}
            isPopularRunesLoading={isPopularRunesLoading}
            popularRunesError={popularRunesError}
            onShowPriceChart={togglePriceChart}
            showPriceChart={showSwapTabPriceChart}
            preSelectedRune={preSelectedRune}
          />
        );
      case 'runesInfo':
        return (
          <RunesInfoTab 
            cachedPopularRunes={popularRunes || []}
            isPopularRunesLoading={isPopularRunesLoading}
            popularRunesError={popularRunesError}
            onShowPriceChart={togglePriceChart}
            showPriceChart={showRunesInfoTabPriceChart}
          />
        );
      case 'yourTxs':
        return <YourTxsTab connected={connected} address={address} />;
      case 'portfolio':
        return <PortfolioTab />;
      default:
        return null;
    }
  };

  return (
    <div className={`${styles.container} ${isPriceChartVisible ? styles.containerWithChart : ''}`}>
      {(activeTab === 'swap' || activeTab === 'runesInfo') ? (
        <div className={styles.appLayout}>
          <div className={`${styles.swapContainer} ${isPriceChartVisible ? styles.narrowSwapContainer : ''}`}>
            {renderActiveTab()}
          </div>
          {isPriceChartVisible && (
            <div className={styles.priceChartContainer}>
              <PriceChart 
                assetName={selectedAssetForActiveTab} 
                onClose={togglePriceChart}
                btcPriceUsd={btcPriceUsd}
              />
            </div>
          )}
        </div>
      ) : (
        renderActiveTab()
      )}
      
      {/* Render footer for all tabs */}
      <FooterComponent 
        btcPriceUsd={btcPriceUsd}
        isBtcPriceLoading={isBtcPriceLoading}
        btcPriceError={btcPriceError}
      />
    </div>
  );
}

export default SwapInterface;-e 

==============================================================

-e FILE: src/components/SwapTab.tsx

-e ==============================================================

import React, { useState, useEffect, Fragment, useCallback, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Listbox, Transition } from '@headlessui/react';
import { ChevronUpDownIcon, CheckIcon, ArrowPathIcon } from '@heroicons/react/24/solid';
import Image from 'next/image';
import styles from './SwapInterface.module.css';
import debounce from 'lodash.debounce';
import { useDebounce } from 'use-debounce';
import { type QuoteResponse, type RuneOrder, type GetPSBTParams, type ConfirmPSBTParams } from 'satsterminal-sdk';
import { Asset, BTC_ASSET } from '@/types/common';
import type { Rune } from '@/types/satsTerminal.ts';
import { 
  fetchRunesFromApi,
  fetchPopularFromApi,
  fetchQuoteFromApi,
  getPsbtFromApi,
  confirmPsbtViaApi,
  fetchBtcBalanceFromApi,
  fetchRuneBalancesFromApi,
  fetchRuneInfoFromApi,
  fetchRuneMarketFromApi
} from '@/lib/apiClient';
import { type RuneBalance as OrdiscanRuneBalance, type RuneMarketInfo as OrdiscanRuneMarketInfo } from '@/types/ordiscan';
import { type RuneData } from '@/lib/runesData';

// Mock address for fetching quotes when disconnected
const MOCK_ADDRESS = '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo';

interface SwapTabProps {
  connected: boolean;
  address: string | null;
  paymentAddress: string | null;
  publicKey: string | null;
  paymentPublicKey: string | null;
  signPsbt: (tx: string, finalize?: boolean, broadcast?: boolean) => Promise<{ signedPsbtHex?: string; signedPsbtBase64?: string; txId?: string; } | undefined>;
  btcPriceUsd: number | undefined;
  isBtcPriceLoading: boolean;
  btcPriceError: Error | null;
  // New props for cached popular runes
  cachedPopularRunes?: Record<string, unknown>[];
  isPopularRunesLoading?: boolean;
  popularRunesError?: Error | null;
  // New props for price chart
  onShowPriceChart?: (assetName?: string, shouldToggle?: boolean) => void;
  showPriceChart?: boolean;
  preSelectedRune?: string | null;
}

export function SwapTab({ 
  connected, 
  address, 
  paymentAddress, 
  publicKey, 
  paymentPublicKey, 
  signPsbt, 
  btcPriceUsd, 
  isBtcPriceLoading, 
  btcPriceError,
  cachedPopularRunes = [],
  isPopularRunesLoading = false,
  popularRunesError = null,
  onShowPriceChart,
  showPriceChart = false,
  preSelectedRune = null
}: SwapTabProps) {
  // State for input/output amounts
  const [inputAmount, setInputAmount] = useState('');
  const [outputAmount, setOutputAmount] = useState('');

  // State for selected assets
  const [assetIn, setAssetIn] = useState<Asset>(BTC_ASSET);
  const [assetOut, setAssetOut] = useState<Asset | null>(null);

  // Track if the preselected rune has been loaded
  const [hasLoadedPreselectedRune, setHasLoadedPreselectedRune] = useState(false);

  // State for rune fetching/searching
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [isPopularLoading, setIsPopularLoading] = useState(isPopularRunesLoading);
  const [popularRunes, setPopularRunes] = useState<Asset[]>([]);
  const [searchResults, setSearchResults] = useState<Asset[]>([]);
  const [searchError, setSearchError] = useState<string | null>(null);
  const [popularError, setPopularError] = useState<string | null>(
    popularRunesError ? popularRunesError.message : null
  );
  // Add a loading state specifically for a preselected rune
  const [isPreselectedRuneLoading, setIsPreselectedRuneLoading] = useState(!!preSelectedRune);

  // Determine which runes to display
  const availableRunes = searchQuery.trim() ? searchResults : popularRunes;
  const isLoadingRunes = searchQuery.trim() ? isSearching : isPopularLoading;
  const currentRunesError = searchQuery.trim() ? searchError : popularError;

  // Handle pre-selected rune
  useEffect(() => {
    const findAndSelectRune = async () => {
      if (preSelectedRune && !hasLoadedPreselectedRune) {
        // Show loading state while searching
        setIsPreselectedRuneLoading(true);
        
        // Force search for the rune if it changes
        // Normalize names by removing spacers for comparison
        const normalizedPreSelected = preSelectedRune.replace(/â€¢/g, '');
        
        // Try to find in available runes first
        const rune = availableRunes.find(r => r.name.replace(/â€¢/g, '') === normalizedPreSelected);
        
        if (rune) {
          // Found in available runes, set it
          setAssetIn(BTC_ASSET);
          setAssetOut(rune);
          setIsPreselectedRuneLoading(false);
          setHasLoadedPreselectedRune(true);
          
          // Clear the URL parameter
          if (typeof window !== 'undefined') {
            const url = new URL(window.location.href);
            url.searchParams.delete('rune');
            window.history.replaceState({}, '', url.toString());
          }
          
          // Clear search field after loading
          setSearchQuery('');
        } else {
          // Not found in available runes, search for it
          try {
            setIsSearching(true);
            const searchResults = await fetchRunesFromApi(preSelectedRune);
            
            if (searchResults && searchResults.length > 0) {
              // Find closest match
              const matchingRune = searchResults.find(r => r.name.replace(/â€¢/g, '') === normalizedPreSelected);
              
              // If found a match or just take the first result if no exact match
              const foundRune = matchingRune || searchResults[0];
              
              // Convert to Asset format
              const foundAsset: Asset = {
                id: foundRune.id,
                name: foundRune.name,
                imageURI: foundRune.imageURI,
                isBTC: false,
              };
              
              // Add to search results
              setSearchResults(prev => {
                // Avoid duplicates
                if (!prev.some(r => r.id === foundAsset.id)) {
                  return [...prev, foundAsset];
                }
                return prev;
              });
              
              // Set as output asset
              setAssetIn(BTC_ASSET);
              setAssetOut(foundAsset);
              setIsPreselectedRuneLoading(false);
              setHasLoadedPreselectedRune(true);
              
              // Clear the URL parameter
              if (typeof window !== 'undefined') {
                const url = new URL(window.location.href);
                url.searchParams.delete('rune');
                window.history.replaceState({}, '', url.toString());
              }
              
              // Clear search field
              setSearchQuery('');
            }
          } catch (error) {
            console.error(`Error searching for pre-selected rune:`, error);
          } finally {
            setIsSearching(false);
            setIsPreselectedRuneLoading(false);
            setHasLoadedPreselectedRune(true);
            
            // Clear the URL parameter even if there was an error
            if (typeof window !== 'undefined') {
              const url = new URL(window.location.href);
              url.searchParams.delete('rune');
              window.history.replaceState({}, '', url.toString());
            }
            
            // Clear search field
            setSearchQuery('');
          }
        }
      } else if (!preSelectedRune) {
        // No preselected rune, ensure loading state is cleared
        setIsPreselectedRuneLoading(false);
        setHasLoadedPreselectedRune(false);
      }
    };
    
    findAndSelectRune();
  }, [preSelectedRune, availableRunes, hasLoadedPreselectedRune, searchQuery]);

  // Fetch popular runes on mount using API
  useEffect(() => {
    const fetchPopular = async () => {
      // If we already have cached popular runes, use them instead of fetching again
      if (cachedPopularRunes && cachedPopularRunes.length > 0) {
        const liquidiumToken: Asset = {
          id: 'liquidiumtoken',
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
          isBTC: false,
        };

        // Map the cached data to Asset format
        const fetchedRunes: Asset[] = cachedPopularRunes
          .map((collection: Record<string, unknown>) => {
            const runeName = ((collection?.etching as Record<string, unknown>)?.runeName as string) || collection?.rune as string || 'Unknown';
            return {
              id: collection?.rune as string || `unknown_${Math.random()}`,
              name: runeName,
              imageURI: collection?.icon_content_url_data as string || collection?.imageURI as string,
              isBTC: false,
            };
          })
          .filter(rune => rune.id !== liquidiumToken.id && rune.name.replace(/â€¢/g, '') !== liquidiumToken.name.replace(/â€¢/g, ''));

        // Prepend the hardcoded token ONLY if no pre-selected rune
        const mappedRunes = preSelectedRune ? fetchedRunes : [liquidiumToken, ...fetchedRunes];
        setPopularRunes(mappedRunes);
        
        // Only set default assetOut if there's no pre-selected rune and no current assetOut and no search query
        if (!preSelectedRune && !assetOut && !searchQuery && mappedRunes.length > 0) {
          setAssetOut(mappedRunes[0]);
        }
        
        setIsPopularLoading(false);
        return;
      }
      
      // If no cached data, fetch from API
      setIsPopularLoading(true);
      setPopularError(null);
      setPopularRunes([]);
      try {
        // Define the hardcoded asset
        const liquidiumToken: Asset = {
          id: 'liquidiumtoken',
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
          isBTC: false,
        };

        const response = await fetchPopularFromApi();
        let mappedRunes: Asset[] = [];

        if (!Array.isArray(response)) {
          mappedRunes = [liquidiumToken];
        } else {
          const fetchedRunes: Asset[] = response
            .map((collection: Record<string, unknown>) => ({
              id: collection?.rune as string || `unknown_${Math.random()}`,
              name: ((collection?.etching as Record<string, unknown>)?.runeName as string) || collection?.rune as string || 'Unknown',
              imageURI: collection?.icon_content_url_data as string || collection?.imageURI as string,
              isBTC: false,
            }))
            .filter(rune => rune.id !== liquidiumToken.id && rune.name.replace(/â€¢/g, '') !== liquidiumToken.name.replace(/â€¢/g, ''));

          mappedRunes = [liquidiumToken, ...fetchedRunes];
        }

        setPopularRunes(mappedRunes);

        // Only set default assetOut if there's no pre-selected rune and no current assetOut
        if (!preSelectedRune && !assetOut && mappedRunes.length > 0) {
          setAssetOut(mappedRunes[0]);
        }

      } catch (error) {
        console.error("Error fetching popular runes:", error);
        setPopularError(error instanceof Error ? error.message : 'Failed to fetch popular runes');
        const liquidiumTokenOnError: Asset = {
          id: 'liquidiumtoken',
          name: 'LIQUIDIUMâ€¢TOKEN',
          imageURI: 'https://icon.unisat.io/icon/runes/LIQUIDIUM%E2%80%A2TOKEN',
          isBTC: false,
        };
        // Only set Liquidium Token if no pre-selected rune
        setPopularRunes(preSelectedRune ? [] : [liquidiumTokenOnError]);
        
        // Only set default assetOut if there's no pre-selected rune and no current assetOut
        if (!preSelectedRune && !assetOut) {
          setAssetOut(liquidiumTokenOnError);
        }
      } finally {
        setIsPopularLoading(false);
      }
    };
    fetchPopular();
  }, [cachedPopularRunes, preSelectedRune, assetOut, searchQuery]);

  // State for quote fetching
  const [isQuoteLoading, setIsQuoteLoading] = useState(false);
  const [quote, setQuote] = useState<QuoteResponse | null>(null);
  const [quoteError, setQuoteError] = useState<string | null>(null);
  const [quoteExpired, setQuoteExpired] = useState(false);

  // State for calculated prices
  const [exchangeRate, setExchangeRate] = useState<string | null>(null);
  const [inputUsdValue, setInputUsdValue] = useState<string | null>(null);
  const [outputUsdValue, setOutputUsdValue] = useState<string | null>(null);

  // State for swap process
  const [isSwapping, setIsSwapping] = useState(false);
  const [swapStep, setSwapStep] = useState<'idle' | 'getting_psbt' | 'signing' | 'confirming' | 'success' | 'error'>('idle');
  const [swapError, setSwapError] = useState<string | null>(null);
  const [txId, setTxId] = useState<string | null>(null); // Store final transaction ID

  // State for loading dots animation
  const [loadingDots, setLoadingDots] = useState('.');

  // Ordiscan Balance Queries 
  const {
    data: btcBalanceSats,
    isLoading: isBtcBalanceLoading,
    error: btcBalanceError,
  } = useQuery<number, Error>({
    queryKey: ['btcBalance', paymentAddress], // Include address in key
    queryFn: () => fetchBtcBalanceFromApi(paymentAddress!), // Use API function
    enabled: !!connected && !!paymentAddress, // Only run query if connected and address exists
    staleTime: 30000, // Consider balance stale after 30 seconds
    refetchInterval: 60000, // Refetch every 60 seconds
  });

  const {
    data: runeBalances,
    isLoading: isRuneBalancesLoading,
    error: runeBalancesError,
  } = useQuery<OrdiscanRuneBalance[], Error>({
    queryKey: ['runeBalancesApi', address],
    queryFn: () => fetchRuneBalancesFromApi(address!), // Use API function
    enabled: !!connected && !!address, // Only run query if connected and address exists
    staleTime: 30000, // Consider balances stale after 30 seconds
    refetchInterval: 60000, // Refetch every 60 seconds
  });

  // Query for Input Rune Info (needed for decimals and other info)
  const {
    data: swapRuneInfo, 
    isLoading: isSwapRuneInfoLoading,
    error: swapRuneInfoError,
  } = useQuery<RuneData | null, Error>({
    queryKey: ['runeInfoApi', assetIn?.name?.replace(/â€¢/g, '')],
    queryFn: () => assetIn && !assetIn.isBTC && assetIn.name ? fetchRuneInfoFromApi(assetIn.name) : Promise.resolve(null), // Use API function
    enabled: !!assetIn && !assetIn.isBTC && !!assetIn.name, // Only fetch for non-BTC assets
    staleTime: Infinity,
  });

  // Query for Input Rune Market Info (for swap tab)
  const {
    data: inputRuneMarketInfo,
  } = useQuery<OrdiscanRuneMarketInfo | null, Error>({
    queryKey: ['runeMarketApi', assetIn?.name],
    queryFn: () => assetIn && !assetIn.isBTC ? fetchRuneMarketFromApi(assetIn.name) : Promise.resolve(null),
    enabled: !!assetIn && !assetIn.isBTC,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
  
  // Query for Output Rune Market Info (for swap tab)
  const {
    data: outputRuneMarketInfo,
  } = useQuery<OrdiscanRuneMarketInfo | null, Error>({
    queryKey: ['runeMarketApi', assetOut?.name],
    queryFn: () => assetOut && !assetOut.isBTC ? fetchRuneMarketFromApi(assetOut.name) : Promise.resolve(null),
    enabled: !!assetOut && !assetOut.isBTC,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Effect for loading dots animation
  useEffect(() => {
    let intervalId: NodeJS.Timeout | null = null;
    if (isQuoteLoading || isBtcPriceLoading || isSwapping) { // Added isSwapping
      intervalId = setInterval(() => {
        setLoadingDots(dots => dots.length < 3 ? dots + '.' : '.');
      }, 500); // Update every 500ms
    } else {
      setLoadingDots('.'); // Reset when not loading
    }

    // Cleanup function to clear interval
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isQuoteLoading, isBtcPriceLoading, isSwapping]); // Added isSwapping

  // Create a debounced search function - MEMOIZED
  const debouncedSearch = useMemo(() => 
    debounce(async (query: string) => {
      if (!query) {
        setSearchResults([]);
        setIsSearching(false);
        setSearchError(null);
        return;
      }
      setIsSearching(true);
      setSearchError(null);
      try {
        // *** Ensure this uses the API fetch function ***
        const results: Rune[] = await fetchRunesFromApi(query); 
        // Map results to Asset type for consistency in the component
        const mappedResults: Asset[] = results.map(rune => ({
          id: rune.id, 
          name: rune.name,
          imageURI: rune.imageURI,
          isBTC: false,
        }));
        setSearchResults(mappedResults); // Store as Asset[]
      } catch (error: unknown) {
        // Keep actual error logging
        console.error("[SwapTab] Error searching runes:", error);
        setSearchError(error instanceof Error ? error.message : 'Failed to search');
        setSearchResults([]); // Clear results on error
      } finally {
        setIsSearching(false);
      }
    }, 300),
  []); // <-- Empty dependency array ensures it's created only once

  // Clean up the debounced function on component unmount
  useEffect(() => {
    return () => {
      debouncedSearch.cancel();
    };
  }, [debouncedSearch]);

  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setSearchQuery(query);
    setIsSearching(true); // Indicate searching immediately
    
    // If we were using a preselected rune, make sure the URL stays clean
    if (hasLoadedPreselectedRune && typeof window !== 'undefined') {
      const url = new URL(window.location.href);
      if (url.searchParams.has('rune')) {
        url.searchParams.delete('rune');
        window.history.replaceState({}, '', url.toString());
      }
    }
    
    debouncedSearch(query);
  };

  // Define debounced value for input amount
  // Correctly use the imported useDebounce hook - extract the first element
  const [debouncedInputAmount] = useDebounce(inputAmount ? parseFloat(inputAmount) : 0, 500); 

  // --- Asset Selection Logic ---
  const handleSelectAssetIn = (selectedAsset: Asset) => {
    // Prevent selecting the same asset for both input and output
    if (assetOut && selectedAsset.id === assetOut.id) return;

    setAssetIn(selectedAsset);
    // If selected asset is BTC, ensure output is a Rune
    if (selectedAsset.isBTC) {
      if (!assetOut || assetOut.isBTC) {
        // Set to first available rune or null if none
        setAssetOut(popularRunes.length > 0 ? popularRunes[0] : null);
      }
    } else {
      // If selected asset is a Rune, ensure output is BTC
      setAssetOut(BTC_ASSET);
    }
    // Clear amounts and quote when assets change
    setInputAmount('');
    setOutputAmount('');
    setQuote(null);
    setQuoteError(null);
    setExchangeRate(null);
    setInputUsdValue(null);
    setOutputUsdValue(null);
    setQuoteExpired(false); // Reset quote expired state
  };

  const handleSelectAssetOut = (selectedAsset: Asset) => {
    // Prevent selecting the same asset for both input and output
    if (assetIn && selectedAsset.id === assetIn.id) return;

    const previousAssetIn = assetIn; // Store previous input asset

    setAssetOut(selectedAsset);

    // If the price chart is visible, update it with the new asset
    if (showPriceChart) {
      onShowPriceChart?.(selectedAsset.name, false);
    }

    // If the NEW output asset is BTC, ensure input is a Rune
    if (selectedAsset.isBTC) {
      if (!previousAssetIn || previousAssetIn.isBTC) {
        // Input was BTC (or null), now must be Rune
        setAssetIn(popularRunes.length > 0 ? popularRunes[0] : BTC_ASSET); // Fallback needed if no popular runes
        // Since input asset type changed, reset amounts
        setInputAmount('');
        setOutputAmount('');
      }
      // else: Input was already a Rune, keep it. Amount reset handled below.
    } else {
      // If the NEW output asset is a Rune, ensure input is BTC
      setAssetIn(BTC_ASSET);
      // Check if the input asset type *actually* changed
      if (!previousAssetIn || !previousAssetIn.isBTC) {
         // Input was Rune (or null), now is BTC. Reset both amounts.
         setInputAmount('');
         setOutputAmount('');
      } else {
         // Input was already BTC and remains BTC. Keep inputAmount, just reset output.
         setOutputAmount('');
      }
    }

    // Always clear quote and related state when output asset changes
    setQuote(null);
    setQuoteError(null);
    setExchangeRate(null);
    setInputUsdValue(null);
    setOutputUsdValue(null);
    setQuoteExpired(false); // Reset quote expired state
  };

  // --- Swap Direction Logic ---
  const handleSwapDirection = () => {
    // Swap assets
    const tempAsset = assetIn;
    setAssetIn(assetOut ?? BTC_ASSET); // Fallback if assetOut is null
    setAssetOut(tempAsset);

    // Swap amounts (if outputAmount has a value)
    const tempAmount = inputAmount;
    setInputAmount(outputAmount); // Set input to previous output
    setOutputAmount(tempAmount); // Reset output (will be recalculated by quote)

    // Clear quote and related state
    setQuote(null);
    setQuoteError(null);
    setExchangeRate(null);
    setInputUsdValue(null);
    setOutputUsdValue(null);
    // Reset swap process state
    setIsSwapping(false);
    setSwapStep('idle');
    setSwapError(null);
    setTxId(null);
    setQuoteExpired(false); // Reset quote expired state
  };

  // --- Quote & Price Calculation ---
  // Memoized quote fetching using API
  const handleFetchQuote = useCallback(() => {
    setQuoteExpired(false);
    const fetchQuoteAsync = async () => {
      const isBtcToRune = assetIn?.isBTC;
      const runeAsset = isBtcToRune ? assetOut : assetIn;
      const currentInputAmount = parseFloat(inputAmount); // Read latest input from ref

      if (!assetIn || !assetOut || !runeAsset || runeAsset.isBTC || currentInputAmount <= 0) return;
      
      setIsQuoteLoading(true);
      setQuote(null); // Clear previous quote
      setQuoteError(null);
      setExchangeRate(null); // Clear previous rate

      // Use MOCK_ADDRESS if no wallet is connected to allow quote fetching
      const effectiveAddress = address || MOCK_ADDRESS;
      if (!effectiveAddress) { // Should theoretically never happen with MOCK_ADDRESS fallback
           setQuoteError("Internal error: Missing address for quote.");
           setIsQuoteLoading(false);
           return;
      }

      try {
        const params = {
          btcAmount: currentInputAmount, 
          runeName: runeAsset.name,
          address: effectiveAddress,
          sell: !isBtcToRune,
          // TODO: Add other params like marketplace, rbfProtection if needed
        };

        // *** Use API client function ***
        const quoteResponse = await fetchQuoteFromApi(params); 
        setQuote(quoteResponse);
        
        let calculatedOutputAmount = '';
        let calculatedRate = null;

        if (quoteResponse) {
          const inputVal = currentInputAmount;
          let outputVal = 0;
          let btcValue = 0;
          let runeValue = 0;

          try {
            if (isBtcToRune) {
              outputVal = parseFloat(quoteResponse.totalFormattedAmount || '0');
              btcValue = inputVal;
              runeValue = outputVal;
              calculatedOutputAmount = outputVal.toLocaleString(undefined, {});
            } else {
              outputVal = parseFloat(quoteResponse.totalPrice || '0');
              runeValue = inputVal;
              btcValue = outputVal;
              calculatedOutputAmount = outputVal.toLocaleString(undefined, { maximumFractionDigits: 8 });
            }

            if (btcValue > 0 && runeValue > 0 && btcPriceUsd) {
               const btcUsdAmount = (isBtcToRune ? btcValue : btcValue) * btcPriceUsd;
               const pricePerRune = btcUsdAmount / runeValue;
               calculatedRate = `${pricePerRune.toLocaleString(undefined, { 
                  style: 'currency', 
                  currency: 'USD',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 6
                })} per ${runeAsset.name}`;
            }
            setExchangeRate(calculatedRate);

          } catch (e) {
            console.error("Error parsing quote amounts:", e);
            calculatedOutputAmount = 'Error';
            setExchangeRate('Error calculating rate');
          }
        }
        setOutputAmount(calculatedOutputAmount);

      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to fetch quote';
        if (errorMessage.includes('Insufficient liquidity') || errorMessage.includes('not found')) {
           setQuoteError(`Could not find a quote for this pair/amount.`);
        } else {
           setQuoteError(`Quote Error: ${errorMessage}`);
        }
        setQuote(null);
        setOutputAmount('');
        setExchangeRate(null);
      } finally {
        setIsQuoteLoading(false);
      }
    };
    fetchQuoteAsync();
  }, [assetIn, assetOut, inputAmount, address, btcPriceUsd,
      setIsQuoteLoading, setQuote, setQuoteError, setExchangeRate, setOutputAmount, setQuoteExpired
  ]);

  // Effect to call the memoized fetchQuote when debounced amount or assets change
  useEffect(() => {
    // Fetch quote only if amount and assets are valid
    const runeAsset = assetIn?.isBTC ? assetOut : assetIn;
    if (debouncedInputAmount > 0 && assetIn && assetOut && runeAsset && !runeAsset.isBTC) {
      handleFetchQuote();
    } else {
      // Reset quote state if conditions aren't met
      setQuote(null);
      // Don't set loading to false here, handleFetchQuote does it
      setQuoteError(null);
      setOutputAmount('');
      setExchangeRate(null);
      setInputUsdValue(null);
      setOutputUsdValue(null);
      setQuoteExpired(false); // Reset quote expired state here too
    }
  }, [debouncedInputAmount, assetIn, assetOut, handleFetchQuote]);

  // UseEffect to calculate input USD value
  useEffect(() => {
    if (!inputAmount || !assetIn || isBtcPriceLoading || btcPriceError) {
        setInputUsdValue(null);
        setOutputUsdValue(null);
        return;
    }

    try {
      const amountNum = parseFloat(inputAmount);
      if (isNaN(amountNum) || amountNum <= 0) {
          setInputUsdValue(null);
          setOutputUsdValue(null);
          return;
      }

      let inputUsdVal: number | null = null;

      if (assetIn.isBTC && btcPriceUsd) {
          // Input is BTC
          inputUsdVal = amountNum * btcPriceUsd;
      } else if (!assetIn.isBTC && inputRuneMarketInfo) {
          // Input is Rune, use market info
          inputUsdVal = amountNum * inputRuneMarketInfo.price_in_usd;
      } else if (!assetIn.isBTC && quote && quote.totalPrice && btcPriceUsd && !isQuoteLoading) {
          // Fallback to quote calculation if market info not available
          const btcPerRune = (quote.totalPrice && quote.totalFormattedAmount && parseFloat(quote.totalFormattedAmount) > 0)
              ? parseFloat(quote.totalPrice) / parseFloat(quote.totalFormattedAmount)
              : 0;

          if (btcPerRune > 0) {
              inputUsdVal = amountNum * btcPerRune * btcPriceUsd;
          }
      }

      // Calculate output USD value
      let outputUsdVal: number | null = null;
      if (outputAmount && assetOut) {
        // Remove commas from outputAmount before parsing
        const sanitizedOutputAmount = outputAmount.replace(/,/g, '');
        const outputAmountNum = parseFloat(sanitizedOutputAmount);
        
        if (!isNaN(outputAmountNum) && outputAmountNum > 0) {
          if (assetOut.isBTC && btcPriceUsd) {
            // Output is BTC
            outputUsdVal = outputAmountNum * btcPriceUsd;
          } else if (!assetOut.isBTC && outputRuneMarketInfo) {
            // Output is Rune, use market info
            outputUsdVal = outputAmountNum * outputRuneMarketInfo.price_in_usd;
          } else if (!assetOut.isBTC && quote && quote.totalPrice && btcPriceUsd && !isQuoteLoading) {
            // Fallback to quote calculation if market info not available
            const btcPerRune = (quote.totalPrice && quote.totalFormattedAmount && parseFloat(quote.totalFormattedAmount) > 0)
                ? parseFloat(quote.totalPrice) / parseFloat(quote.totalFormattedAmount)
                : 0;

            if (btcPerRune > 0) {
                outputUsdVal = outputAmountNum * btcPerRune * btcPriceUsd;
            }
          }
        }
      }

      // Format and set input USD value
      if (inputUsdVal !== null && inputUsdVal > 0) {
        setInputUsdValue(inputUsdVal.toLocaleString(undefined, {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }));
      } else {
        setInputUsdValue(null);
      }

      // Format and set output USD value
      if (outputUsdVal !== null && outputUsdVal > 0) {
        setOutputUsdValue(outputUsdVal.toLocaleString(undefined, {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }));
      } else {
        setOutputUsdValue(null);
      }
    } catch (e) {
      console.error("Failed to calculate USD values:", e);
      setInputUsdValue(null);
      setOutputUsdValue(null);
    }
  }, [inputAmount, outputAmount, assetIn, assetOut, btcPriceUsd, isBtcPriceLoading, btcPriceError, 
      quote, isQuoteLoading, inputRuneMarketInfo, outputRuneMarketInfo]);

  // Function to handle the entire swap process using API
  const handleSwap = async () => {
    const isBtcToRune = assetIn?.isBTC;
    const runeAsset = isBtcToRune ? assetOut : assetIn;

    // Double-check required data
    if (!connected || !address || !publicKey || !paymentAddress || !paymentPublicKey || !quote || !assetIn || !assetOut || !runeAsset || runeAsset.isBTC) {
      setSwapError("Missing connection details, assets, or quote. Please connect wallet and ensure quote is fetched.");
      setSwapStep('error');
      return;
    }

    setIsSwapping(true);
    setSwapError(null);
    setTxId(null);
    setQuoteExpired(false); // Ensure reset before attempting swap

    try {
      // 1. Get PSBT via API
      setSwapStep('getting_psbt');
      const orders: RuneOrder[] = quote.selectedOrders || [];
      const psbtParams: GetPSBTParams = {
        orders: orders, 
        address: address, 
        publicKey: publicKey, 
        paymentAddress: paymentAddress, 
        paymentPublicKey: paymentPublicKey,
        runeName: runeAsset.name, 
        sell: !isBtcToRune,
        // TODO: Add feeRate, slippage, rbfProtection from UI state later
      };
      // *** Use API client function ***
      const psbtResult = await getPsbtFromApi(psbtParams); 

      const mainPsbtBase64 = (psbtResult as unknown as { psbtBase64?: string, psbt?: string })?.psbtBase64 
                           || (psbtResult as unknown as { psbtBase64?: string, psbt?: string })?.psbt;
      const swapId = (psbtResult as unknown as { swapId?: string })?.swapId;
      const rbfPsbtBase64 = (psbtResult as unknown as { rbfProtected?: { base64?: string } })?.rbfProtected?.base64;

      if (!mainPsbtBase64 || !swapId) {
        throw new Error(`Invalid PSBT data received from API: ${JSON.stringify(psbtResult)}`);
      }

      // 2. Sign PSBT(s) - Remains client-side via LaserEyes
      setSwapStep('signing');
      const mainSigningResult = await signPsbt(mainPsbtBase64);
      const signedMainPsbt = mainSigningResult?.signedPsbtBase64;
      if (!signedMainPsbt) {
          throw new Error("Main PSBT signing cancelled or failed.");
      }

      let signedRbfPsbt: string | null = null;
      if (rbfPsbtBase64) {
          const rbfSigningResult = await signPsbt(rbfPsbtBase64);
          signedRbfPsbt = rbfSigningResult?.signedPsbtBase64 ?? null;
          if (!signedRbfPsbt) {
              console.warn("RBF PSBT signing cancelled or failed. Proceeding without RBF confirmation might be possible depending on API.");
          }
      }

      // 3. Confirm PSBT via API
      setSwapStep('confirming');
      const confirmParams: ConfirmPSBTParams = {
        orders: orders,
        address: address,
        publicKey: publicKey,
        paymentAddress: paymentAddress,
        paymentPublicKey: paymentPublicKey,
        signedPsbtBase64: signedMainPsbt,
        swapId: swapId,
        runeName: runeAsset.name,
        sell: !isBtcToRune,
        signedRbfPsbtBase64: signedRbfPsbt ?? undefined,
        rbfProtection: !!signedRbfPsbt,
      };
      // *** Use API client function ***
      const confirmResult = await confirmPsbtViaApi(confirmParams); 

      // Define a basic interface for expected response structure
      interface SwapConfirmationResult {
        txid?: string;
        rbfProtection?: {
          fundsPreparationTxId?: string;
        };
      }

      // Use proper typing instead of 'any'
      const finalTxId = (confirmResult as SwapConfirmationResult)?.txid || 
                        (confirmResult as SwapConfirmationResult)?.rbfProtection?.fundsPreparationTxId;
      if (!finalTxId) {
          throw new Error(`Confirmation failed or transaction ID missing. Response: ${JSON.stringify(confirmResult)}`);
      }
      setTxId(finalTxId);
      setSwapStep('success');

    } catch (error: unknown) {
      console.error("Swap failed:", error);
      const errorMessage = error instanceof Error ? error.message : "An unknown error occurred during the swap.";

      // Check for specific errors
      if (errorMessage.includes("Quote expired. Please, fetch again.") || 
          (error && typeof error === 'object' && 'code' in error && 
           (error as { code?: string }).code === 'QUOTE_EXPIRED')) {
        // Quote expired error
        setQuoteExpired(true);
        setSwapError("Quote expired. Please fetch a new one."); // Set error message
        setSwapStep('idle'); // Reset step to allow button click for re-fetch
      } else if (errorMessage.includes("User canceled the request")) {
        // User cancelled signing
        setSwapError(errorMessage); // Keep the error message
        setSwapStep('idle'); // Reset step to allow retry, button remains active
      } else {
        // Other swap errors
        setQuoteExpired(false); // Ensure quote expired state is reset
        setSwapError(errorMessage);
        setSwapStep('error'); // Set to error state, button might disable
      }
    } finally {
      // Setting isSwapping false ONLY if not in a state that requires user action (like quote expired)
      // This ensures the button text/state reflects the quoteExpired status correctly.
      if (!quoteExpired) {
         setIsSwapping(false); // Only set isSwapping false if it wasn't a quote expiry error
      }
      // If quoteExpired is true, isSwapping should remain false anyway because we didn't set it true
      // or we exited the try block before confirming. Let's ensure it's false in finally.
       setIsSwapping(false); // Ensure isSwapping is always false after attempt
    }
  };

  // Dynamic swap button text
  const getSwapButtonText = () => {
    if (quoteExpired) return 'Fetch New Quote'; // Check first
    if (!connected) return 'Connect Wallet';
    if (isQuoteLoading) return `Fetching Quote${loadingDots}`;
    if (!assetIn || !assetOut) return 'Select Assets';
    if (!inputAmount || parseFloat(inputAmount) <= 0) return 'Enter Amount';
    // If quote expired, we already returned. If quoteError exists BUT it wasn't expiry, show error.
    if (quoteError && !quoteExpired) return 'Quote Error';
    // Show loading quote only if not expired and amount > 0
    if (!quote && !quoteError && !quoteExpired && debouncedInputAmount > 0) return `Getting Quote${loadingDots}`;
    if (!quote && !quoteExpired) return 'Get Quote'; // Before debounce or if amount is 0
    if (isSwapping) { // isSwapping is false if quoteExpired is true due to finally block logic
      switch (swapStep) {
        case 'getting_psbt': return `Generating Transaction${loadingDots}`;
        case 'signing': return `Waiting for Signature${loadingDots}`;
        case 'confirming': return `Confirming Swap${loadingDots}`;
        default: return `Processing Swap${loadingDots}`;
      }
    }
    if (swapStep === 'success' && txId) return 'Swap Successful!';
    // Show 'Swap Failed' only if it's an error state AND not a quote expiry requiring action
    if (swapStep === 'error' && !quoteExpired) return 'Swap Failed';
    // If idle after cancellation, show Swap. If idle after quote expiry, show Fetch New Quote (handled above)
    return 'Swap';
  };

  // --- Asset Selector Component (Simplified Inline) ---
  const renderAssetSelector = (
      value: Asset | null,
      onChange: (asset: Asset) => void,
      disabled: boolean,
      purpose: 'selectRune' | 'selectBtcOrRune',
      otherAsset: Asset | null,
      availableRunes: Asset[],
      isLoadingRunes: boolean,
      currentRunesError: string | null,
      searchQuery: string,
      handleSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void,
      isPreselectedLoading: boolean = false
  ) => {
    const runesToShow = purpose === 'selectBtcOrRune' ? [BTC_ASSET, ...availableRunes] : availableRunes;
    // Filter out the other selected asset if necessary
    const filteredRunes = runesToShow.filter(rune => !otherAsset || rune.id !== otherAsset.id);

    return (
      <div className={styles.listboxContainer}>
          <Listbox value={value} onChange={onChange} disabled={disabled || isLoadingRunes || isPreselectedLoading}>
              <div className={styles.listboxRelative}>
                  <Listbox.Button className={styles.listboxButton}>
                      <span className={styles.listboxButtonText}>
                          {isPreselectedLoading ? (
                            <span className={styles.loadingText}>Loading Rune{loadingDots}</span>
                          ) : (
                            <>
                              {value?.imageURI && (
                                  <Image
                                      src={value.imageURI}
                                      alt={`${value.name} logo`}
                                      className={styles.assetButtonImage}
                                      width={24}
                                      height={24}
                                      aria-hidden="true"
                                      onError={(e) => {
                                        const target = e.target as HTMLImageElement;
                                        if (target) {
                                          target.style.display = 'none';
                                        }
                                      }}
                                  />
                              )}
                              {isLoadingRunes && purpose === 'selectRune' ? 'Loading...' : value ? value.name : 'Select Asset'}
                            </>
                          )}
                      </span>
                      <span className={styles.listboxButtonIconContainer}>
                          <ChevronUpDownIcon className={styles.listboxButtonIcon} aria-hidden="true" />
                      </span>
                  </Listbox.Button>
                  <Transition
                      as={Fragment}
                      leave="transition ease-in duration-100"
                      leaveFrom="opacity-100"
                      leaveTo="opacity-0"
                  >
                      <Listbox.Options className={styles.listboxOptions}>
                          {purpose === 'selectBtcOrRune' && (
                             <Listbox.Option
                                  key={BTC_ASSET.id}
                                  className={({ active }) =>
                                      `${styles.listboxOption} ${ active ? styles.listboxOptionActive : styles.listboxOptionInactive }`
                                  }
                                  value={BTC_ASSET}
                                  disabled={BTC_ASSET.id === otherAsset?.id}
                             >
                                  {({ selected }) => (
                                       <>
                                          <span className={styles.runeOptionContent}> {/* Use rune option style */}
                                              {BTC_ASSET.imageURI && (
                                                  <Image 
                                                    src={BTC_ASSET.imageURI} 
                                                    alt="" 
                                                    className={styles.runeImage} 
                                                    width={24}
                                                    height={24}
                                                    aria-hidden="true" 
                                                  />
                                              )}
                                              <span className={`${styles.listboxOptionText} ${ selected ? styles.listboxOptionTextSelected : styles.listboxOptionTextUnselected }`}>
                                                  {BTC_ASSET.name}
                                              </span>
                                          </span>
                                          {selected && (
                                              <span className={styles.listboxOptionCheckContainer}>
                                                  <CheckIcon className={styles.listboxOptionCheckIcon} aria-hidden="true" />
                                              </span>
                                          )}
                                      </>
                                  )}
                             </Listbox.Option>
                          )}

                          <div className={styles.searchContainer}>
                              <div className={styles.searchWrapper}>
                                  <Image 
                                      src="/icons/magnifying_glass-0.png" 
                                      alt="Search" 
                                      className={styles.searchIconEmbedded}
                                      width={16}
                                      height={16}
                                  />
                                  <input
                                      type="text"
                                      placeholder="Search runes..."
                                      value={searchQuery}
                                      onChange={handleSearchChange}
                                      className={styles.searchInput}
                                  />
                              </div>
                          </div>

                          {isLoadingRunes && <div className={styles.listboxLoadingOrEmpty}>Loading Runes...</div>}
                          {!isLoadingRunes && currentRunesError && (
                            <div className={`${styles.listboxError} ${styles.messageWithIcon}`}>
                              <Image 
                                src="/icons/msg_error-0.png" 
                                alt="Error" 
                                className={styles.messageIcon}
                                width={16}
                                height={16}
                              />
                              <span>{currentRunesError}</span>
                            </div>
                          )}
                          {!isLoadingRunes && !currentRunesError && availableRunes.length === 0 && (
                               <div className={styles.listboxLoadingOrEmpty}>
                                  {searchQuery ? 'No matching runes found' : (purpose === 'selectBtcOrRune' ? 'No other runes available' : 'No runes available')}
                               </div>
                          )}

                          {filteredRunes
                              .filter(rune => rune.id !== otherAsset?.id)
                              .map((rune) => (
                              <Listbox.Option
                                  key={rune.id}
                                  className={({ active }) =>
                                      `${styles.listboxOption} ${ active ? styles.listboxOptionActive : styles.listboxOptionInactive }`
                                  }
                                  value={rune}
                              >
                                  {({ selected }) => (
                                      <>
                                          <span className={styles.runeOptionContent}> {/* Use rune option style */}
                                              {rune.imageURI && (
                                                  <Image
                                                      src={rune.imageURI}
                                                      alt=""
                                                      className={styles.runeImage}
                                                      width={24}
                                                      height={24}
                                                      aria-hidden="true"
                                                      onError={(e) => {
                                                        const target = e.target as HTMLImageElement;
                                                        if (target) {
                                                          target.style.display = 'none';
                                                        }
                                                      }}
                                                  />
                                              )}
                                              <span className={`${styles.listboxOptionText} ${ selected ? styles.listboxOptionTextSelected : styles.listboxOptionTextUnselected }`}>
                                                  {rune.name}
                                              </span>
                                          </span>
                                          {selected && (
                                              <span className={styles.listboxOptionCheckContainer}>
                                                  <CheckIcon className={styles.listboxOptionCheckIcon} aria-hidden="true" />
                                              </span>
                                          )}
                                      </>
                                  )}
                              </Listbox.Option>
                          ))}
                      </Listbox.Options>
                  </Transition>
              </div>
          </Listbox>
      </div>
    );
  };

  // --- Find specific rune balance --- (Helper Function)
  const getSpecificRuneBalance = (runeName: string | undefined): string | null => {
    if (!runeName || !runeBalances) return null;
    // Ordiscan returns names without spacers, so compare without them
    const formattedRuneName = runeName.replace(/â€¢/g, '');
    const found = runeBalances?.find(rb => rb.name === formattedRuneName);
    return found ? found.balance : '0'; // Return '0' if not found, assuming 0 balance
  };

  // Reset swap state when inputs/wallet change significantly
  useEffect(() => {
    if (swapStep !== 'idle') {
      setIsSwapping(false);
      setSwapStep('idle');
      setSwapError(null);
      setTxId(null);
    }
  }, [address, connected, swapStep]); // Add swapStep to dependencies

  return (
    <div className={styles.runesInfoTabContainer}>
      <h2 className={styles.title}>Swap</h2>

      {/* Input Area */}
      <div className={styles.inputArea}>
        <div className={styles.inputHeader}>
          <label htmlFor="input-amount" className={styles.inputLabel}>You Pay</label>
          {connected && assetIn && (
            <span className={styles.availableBalance}>
              Available: {' '}
              {assetIn.isBTC ? (
                isBtcBalanceLoading ? (
                  <span className={styles.loadingText}>Loading{loadingDots}</span>
                ) : btcBalanceError ? (
                  <span className={styles.errorText}>Error loading balance</span>
                ) : btcBalanceSats !== undefined ? (
                  `${(btcBalanceSats / 100_000_000).toLocaleString(undefined, { maximumFractionDigits: 8 })} BTC`
                ) : (
                  'N/A' // Should not happen if connected
                )
              ) : (
                isRuneBalancesLoading || isSwapRuneInfoLoading ? (
                  <span className={styles.loadingText}>Loading{loadingDots}</span>
                ) : runeBalancesError || swapRuneInfoError ? (
                  <span className={styles.errorText}>Error loading balance</span>
                ) : (
                  () => {
                    const rawBalance = getSpecificRuneBalance(assetIn.name);
                    const decimals = swapRuneInfo?.decimals ?? 0; 
                    
                    if (rawBalance === null) return 'N/A';
                    try {
                      const balanceNum = parseFloat(rawBalance);
                      if (isNaN(balanceNum)) return 'Invalid Balance';
                      const displayValue = balanceNum / (10 ** decimals);
                      return `${displayValue.toLocaleString(undefined, { maximumFractionDigits: decimals })} ${assetIn.name}`;
                    } catch (e) {
                      console.error("Error formatting rune balance:", e);
                      return 'Formatting Error';
                    }
                  }
                )()
              )}
            </span>
          )}
          {!connected && (<span className={styles.availableBalance}></span>)}
        </div>
        <div className={styles.inputRow}>
          <input
            type="number"
            id="input-amount"
            placeholder="0.0"
            value={inputAmount}
            onChange={(e) => setInputAmount(e.target.value)}
            className={styles.amountInput}
            min="0"
            step="0.001"
          />
          {renderAssetSelector(
            assetIn,
            handleSelectAssetIn,
            false,
            assetOut?.isBTC ? 'selectRune' : 'selectBtcOrRune',
            assetOut,
            availableRunes,
            isLoadingRunes,
            currentRunesError,
            searchQuery,
            handleSearchChange,
            false // Input asset is never preselected
          )}
        </div>
        {inputUsdValue && !isQuoteLoading && (
          <div className={styles.usdValueText}>â‰ˆ {inputUsdValue}</div>
        )}
      </div>

      {/* Swap Direction Button */}
      <div className={styles.swapIconContainer}>
        <button
          onClick={handleSwapDirection}
          className={styles.swapIconButton}
          aria-label="Swap direction"
          disabled={!assetIn || !assetOut || isSwapping || isQuoteLoading}
        >
          <ArrowPathIcon className={styles.swapIcon} />
        </button>
      </div>

      {/* Output Area */}
      <div className={styles.inputArea}>
        <label htmlFor="output-amount" className={styles.inputLabel}>
          You Receive (Estimated)
        </label>
        <div className={styles.inputRow}>
          <input
            type="text"
            id="output-amount"
            placeholder="0.0"
            value={isQuoteLoading ? `Loading${loadingDots}` : outputAmount}
            readOnly
            className={styles.amountInputReadOnly}
          />
          {renderAssetSelector(
            assetOut,
            handleSelectAssetOut,
            false,
            assetIn?.isBTC ? 'selectRune' : 'selectBtcOrRune',
            assetIn,
            availableRunes,
            isLoadingRunes,
            currentRunesError,
            searchQuery,
            handleSearchChange,
            isPreselectedRuneLoading // Output asset can be preselected from URL
          )}
        </div>
        {outputUsdValue && !isQuoteLoading && (
          <div className={styles.usdValueText}>â‰ˆ {outputUsdValue}</div>
        )}
        {quoteError && !isQuoteLoading && (
          <div className={`${styles.quoteErrorText} ${styles.messageWithIcon}`}>
            <Image 
              src="/icons/msg_error-0.png" 
              alt="Error" 
              className={styles.messageIcon}
              width={16}
              height={16}
            />
            <span>{quoteError}</span>
          </div>
        )}
      </div>

      {/* Show Price Chart button - Moved here */}
      {!showPriceChart && (
        <button 
          className={styles.showPriceChartButton}
          onClick={() => onShowPriceChart?.(assetOut?.name || "LIQUIDIUMâ€¢TOKEN")}
        >
          Show Price Chart
        </button>
      )}

      {/* Info Area */}
      <div className={styles.infoArea}>
        {assetIn && assetOut && (
          <div className={styles.infoRow}>
            <span>Price:</span>
            <span>
              {(() => {
                if (isQuoteLoading) return loadingDots;
                if (exchangeRate) return exchangeRate;
                // Show N/A only if amount entered, but no quote/rate yet and no specific quote error
                if (debouncedInputAmount > 0 && !quoteError) return 'N/A'; 
                return ''; // Otherwise, display nothing
              })()}
            </span>
          </div>
        )}
      </div>

      {/* Swap Button */}
      <button
        className={styles.swapButton}
        onClick={quoteExpired ? handleFetchQuote : handleSwap} 
        disabled={
          (quoteExpired && isQuoteLoading) ||
          (!quoteExpired && (
            !connected ||
            !inputAmount ||
            parseFloat(inputAmount) <= 0 ||
            !assetIn ||
            !assetOut ||
            isQuoteLoading || 
            !!quoteError || 
            !quote || 
            isSwapping ||
            swapStep === 'success' ||
            (swapStep === 'error' && !quoteExpired)
          ))
        }
      >
        {getSwapButtonText()}
      </button>

      {/* Display Swap Process Status */}
      {isSwapping && swapStep !== 'error' && swapStep !== 'success' && (
        <div className={`${styles.statusText} ${styles.messageWithIcon}`}>
          <Image 
            src="@windows_hourglass.png" 
            alt="Processing" 
            className={styles.messageIcon}
            width={16}
            height={16}
          />
          <span>
            {swapStep === 'getting_psbt' && 'Preparing transaction...'}
            {swapStep === 'signing' && 'Waiting for wallet signature...'}
            {swapStep === 'confirming' && 'Broadcasting transaction...'}
            {swapStep === 'idle' && 'Processing...'}
          </span>
        </div>
      )}

      {/* Display Swap Error/Success Messages */}
      {swapError && (
        <div className={`${styles.errorText} ${styles.messageWithIcon}`}>
          <Image 
            src="/icons/msg_error-0.png" 
            alt="Error" 
            className={styles.messageIcon}
            width={16}
            height={16}
          />
          <span>Error: {swapError}</span>
        </div>
      )}
      {!swapError && swapStep === 'success' && txId && (
        <div className={`${styles.successText} ${styles.messageWithIcon}`}>
          <Image 
            src="/icons/check-0.png" 
            alt="Success" 
            className={styles.messageIcon}
            width={16}
            height={16}
          />
          <span>
            Swap successful!
            <a
              href={`https://ordiscan.com/tx/${txId}`}
              target="_blank"
              rel="noopener noreferrer"
              className={styles.txLink}
            >
              View on Ordiscan
            </a>
          </span>
        </div>
      )}
    </div>
  );
}

export default SwapTab; -e 

==============================================================

-e FILE: src/components/YourTxsTab.tsx

-e ==============================================================

'use client';

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import Image from 'next/image';
import styles from './SwapInterface.module.css'; // Reuse styles for now
import { 
  RuneActivityEvent
} from '@/types/ordiscan'; // Import types
import { fetchRuneActivityFromApi } from '@/lib/apiClient'; // Import API functions
import { FormattedRuneAmount } from './FormattedRuneAmount'; // Import component
import { interpretRuneTransaction } from '@/utils/transactionHelpers'; // Import the new utility function

interface YourTxsTabProps {
  connected: boolean;
  address: string | null;
}

export function YourTxsTab({ connected, address }: YourTxsTabProps) {
  // --- Query for User's Rune Transaction Activity ---
  const {
    data: runeActivity,
    isLoading: isRuneActivityLoading,
    error: runeActivityError,
    // Add pagination state/controls later if needed
  } = useQuery<RuneActivityEvent[], Error>({
    queryKey: ['runeActivityApi', address],
    queryFn: () => fetchRuneActivityFromApi(address!), // Use API function
    enabled: !!connected && !!address, // Only fetch when connected and address exists
    staleTime: 60 * 1000, // Stale after 1 minute
    refetchInterval: 2 * 60 * 1000, // Refetch every 2 minutes
  });

  return (
    <div className={styles.yourTxsTabContainer}>
      <h2 className={styles.title}>Your Rune Transactions</h2>
      {!connected || !address ? (
        <p className={styles.hintText}>Connect your wallet to view your transactions.</p>
      ) : isRuneActivityLoading ? (
        <div className={styles.listboxLoadingOrEmpty}>
          <span className={styles.loadingText}>Loading your transactions...</span>
        </div>
      ) : runeActivityError ? (
        <div className={`${styles.listboxError} ${styles.messageWithIcon}`}>
          <Image 
            src="/icons/msg_error-0.png" 
            alt="Error" 
            className={styles.messageIcon} 
            width={16}
            height={16}
          />
          <span>Error loading transactions: {runeActivityError instanceof Error ? runeActivityError.message : String(runeActivityError)}</span>
        </div>
      ) : !runeActivity || runeActivity.length === 0 ? (
        <p className={styles.hintText}>No recent rune transactions found for this address.</p>
      ) : (
        <div className={styles.txListContainer}> 
          {runeActivity.map((tx: RuneActivityEvent) => {
            // Get transaction interpretation using the utility function
            const { action, runeName, runeAmountRaw } = address 
              ? interpretRuneTransaction(tx, address) 
              : { action: 'Unknown', runeName: 'N/A', runeAmountRaw: 'N/A' };
              
            return (
              <div key={tx.txid} className={styles.txListItem}>
                <div className={styles.txHeader}>
                  <a
                    href={`https://ordiscan.com/tx/${tx.txid}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className={styles.txLinkBold}
                  >
                    TXID: {tx.txid.substring(0, 8)}...{tx.txid.substring(tx.txid.length - 8)}
                  </a>
                  <span className={styles.txTimestamp}>
                    {new Date(tx.timestamp).toLocaleString()}
                  </span>
                </div>
                <div className={styles.txDetails}> 
                  <div className={styles.txDetailRow}> 
                    <span>Action:</span>
                    <span style={{ fontWeight: 'bold' }}>{action}</span>
                  </div>
                  <div className={styles.txDetailRow}> 
                    <span>Rune:</span>
                    <span className={styles.runeNameHighlight}>{runeName}</span>
                  </div>
                  <div className={styles.txDetailRow}> 
                    <span>Amount:</span>
                    <span>
                      <FormattedRuneAmount runeName={runeName} rawAmount={runeAmountRaw} />
                    </span>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}

export default YourTxsTab; -e 

==============================================================

-e FILE: src/context/LaserEyesContext.tsx

-e ==============================================================

'use client';

import { createContext, useContext } from 'react';
import type { ProviderType } from '@omnisat/lasereyes'; // Import ProviderType
// REMOVED: import type { LaserEyesData } from '@omnisat/lasereyes'; // Assuming LaserEyes exports a type for its hook return value

// Define the shape of the context data based on current usage
interface ILaserEyesContext {
  connected: boolean;
  isConnecting: boolean;
  address: string | null;
  paymentAddress: string | null;
  publicKey: string | null;
  paymentPublicKey: string | null;
  provider?: string; // Keep this as string for display?
  connect: (providerName: ProviderType) => Promise<void>; // Use ProviderType
  disconnect: () => void;
  signPsbt: (tx: string, finalize?: boolean, broadcast?: boolean) => Promise<{ 
    signedPsbtHex?: string;
    signedPsbtBase64?: string;
    txId?: string;
   } | undefined>;
  // Wallet availability properties
  hasUnisat?: boolean;
  // Add other properties/methods from LaserEyesData if needed later
}

// Create the context with a default value (or null/undefined)
const LaserEyesContext = createContext<ILaserEyesContext | null>(null);

// Custom hook to use the LaserEyes context
export const useSharedLaserEyes = () => {
  const context = useContext(LaserEyesContext);
  if (!context) {
    throw new Error('useSharedLaserEyes must be used within a LaserEyesProvider via SharedLaserEyesProvider');
  }
  return context;
};

// Export the context itself if needed, and the Provider component wrapper
export { LaserEyesContext }; -e 

==============================================================

-e FILE: src/lib/apiClient.ts

-e ==============================================================

import {
    type RuneBalance as OrdiscanRuneBalance,
    type RuneInfo as OrdiscanRuneInfo,
    type RuneMarketInfo as OrdiscanRuneMarketInfo,
    type RuneActivityEvent,
} from '@/types/ordiscan';
import type { Rune } from '@/types/satsTerminal';
import { type QuoteResponse, type GetPSBTParams, type ConfirmPSBTParams } from 'satsterminal-sdk';
import { type RuneData } from './runesData';

// API Query Keys for React Query caching
export const QUERY_KEYS = {
  POPULAR_RUNES: 'popularRunes',
  RUNE_INFO: 'runeInfo',
  RUNE_MARKET: 'runeMarket',
  RUNE_PRICE_HISTORY: 'runePriceHistory',
  BTC_BALANCE: 'btcBalance',
  RUNE_BALANCES: 'runeBalances',
  RUNE_LIST: 'runesList',
  RUNE_ACTIVITY: 'runeActivity',
  PORTFOLIO_DATA: 'portfolioData'
};

// Standard API response handler
const handleApiResponse = <T>(data: unknown, expectedArrayType = false): T => {
  // Handle the standardized response format
  if (data && typeof data === 'object' && 'success' in data && (data as Record<string, unknown>).success === true && 'data' in data) {
    // Return the data property
    const responseData = (data as { data: unknown }).data;
    if (expectedArrayType && !Array.isArray(responseData)) {
      console.error("[Client] API response data is not an array:", responseData);
      return ([] as unknown) as T; // Return empty array
    }
    return responseData as T;
  }
  
  // Fallback for direct array/object response (backward compatibility)
  if ((expectedArrayType && Array.isArray(data)) || (!expectedArrayType && data !== null)) {
    return data as T;
  }
  
  console.error("[Client] API response was OK, but data format is unexpected:", data);
  return (expectedArrayType ? [] : null) as unknown as T;
};

// Fetch Runes search results from API
export const fetchRunesFromApi = async (query: string): Promise<Rune[]> => {
  if (!query) return [];
  
  const response = await fetch(`/api/sats-terminal/search?query=${encodeURIComponent(query)}`);
  let data;
  try {
      data = await response.json();
  } catch (error) {
      console.error(`[Client] Failed to parse API response as JSON for ${query}:`, error);
      throw new Error('Failed to parse search results');
  }

  if (!response.ok) {
      console.error('[Client] API returned error:', data);
      throw new Error(data?.error?.message || data?.error || `Search failed: ${response.statusText}`);
  }

  return handleApiResponse<Rune[]>(data, true);
};

// Fetch Popular Collections from API (cached version)
export const fetchPopularFromApi = async (): Promise<Record<string, unknown>[]> => {
  const response = await fetch('/api/cached-popular-runes');
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse popular collections');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch popular collections: ${response.statusText}`);
  }
  return handleApiResponse<Record<string, unknown>[]>(data, true);
};

// Direct access to SatsTerminal popular collections (if needed)
export const fetchSatsTerminalPopularFromApi = async (): Promise<Record<string, unknown>[]> => {
  const response = await fetch('/api/sats-terminal/popular');
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse popular collections');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch popular collections: ${response.statusText}`);
  }
  return handleApiResponse<Record<string, unknown>[]>(data, true);
};

// Fetch Quote from API
export const fetchQuoteFromApi = async (params: Record<string, unknown>): Promise<QuoteResponse> => {
  const response = await fetch('/api/sats-terminal/quote', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
  });
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse quote response');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch quote: ${response.statusText}`);
  }
  return handleApiResponse<QuoteResponse>(data, false);
};

// Get PSBT from API
export const getPsbtFromApi = async (params: GetPSBTParams): Promise<Record<string, unknown>> => {
  const response = await fetch('/api/sats-terminal/psbt/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
  });
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse PSBT response');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to create PSBT: ${response.statusText}`);
  }
  return handleApiResponse<Record<string, unknown>>(data, false);
};

// Confirm PSBT via API
export const confirmPsbtViaApi = async (params: ConfirmPSBTParams): Promise<Record<string, unknown>> => {
  const response = await fetch('/api/sats-terminal/psbt/confirm', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params)
  });
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse confirmation response');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to confirm PSBT: ${response.statusText}`);
  }
  return handleApiResponse<Record<string, unknown>>(data, false);
};

// Fetch BTC Balance from API
export const fetchBtcBalanceFromApi = async (address: string): Promise<number> => {
  const response = await fetch(`/api/ordiscan/btc-balance?address=${encodeURIComponent(address)}`);
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error(`Failed to parse BTC balance for ${address}`);
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch BTC balance: ${response.statusText}`);
  }
  const parsedData = handleApiResponse<{ balance: number }>(data, false);
  return parsedData?.balance || 0;
};

// Fetch Rune Balances from API
export const fetchRuneBalancesFromApi = async (address: string): Promise<OrdiscanRuneBalance[]> => {
  const response = await fetch(`/api/ordiscan/rune-balances?address=${encodeURIComponent(address)}`);
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error(`Failed to parse rune balances for ${address}`);
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch rune balances: ${response.statusText}`);
  }
  return handleApiResponse<OrdiscanRuneBalance[]>(data, true);
};

// Fetch Rune Info from API
export const fetchRuneInfoFromApi = async (name: string): Promise<RuneData | null> => {
  const normalizedName = name.replace(/â€¢/g, '')
  const response = await fetch(`/api/ordiscan/rune-info?name=${encodeURIComponent(normalizedName)}`);
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error(`Failed to parse rune info for ${name}`);
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch rune info: ${response.statusText}`);
  }
  // Handle 404 (null) responses
  if (response.status === 404) {
      return null;
  }
  return handleApiResponse<RuneData | null>(data, false);
};

// Fetch Rune Market Info from API
export const fetchRuneMarketFromApi = async (name: string): Promise<OrdiscanRuneMarketInfo | null> => {
  const normalizedName = name.replace(/â€¢/g, '')
  const response = await fetch(`/api/ordiscan/rune-market?name=${encodeURIComponent(normalizedName)}`);
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error(`Failed to parse market info for ${name}`);
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch market info: ${response.statusText}`);
  }
  // Handle 404 (null) responses
  if (response.status === 404) {
      return null;
  }
  return handleApiResponse<OrdiscanRuneMarketInfo | null>(data, false);
};

// Fetch List Runes from API
export const fetchListRunesFromApi = async (): Promise<OrdiscanRuneInfo[]> => {
  const response = await fetch('/api/ordiscan/list-runes');
  let data;
  try {
      data = await response.json();
  } catch {
      throw new Error('Failed to parse runes list');
  }
  if (!response.ok) {
      throw new Error(data?.error?.message || data?.error || `Failed to fetch runes list: ${response.statusText}`);
  }
  return handleApiResponse<OrdiscanRuneInfo[]>(data, true);
};

// Fetch Rune Activity from API
export const fetchRuneActivityFromApi = async (address: string): Promise<RuneActivityEvent[]> => {
  const response = await fetch(`/api/ordiscan/rune-activity?address=${encodeURIComponent(address)}`);
  let data;
  try {
      data = await response.json();
  } catch (error) {
      console.error("[Client] Failed to parse API response as JSON:", error);
      if (!response.ok) {
         throw new Error(`Failed to fetch rune activity: Server responded with status ${response.status}`);
      }
      throw new Error("Failed to parse successful API response.");
  }

  if (!response.ok) {
      console.error("[Client] API returned error:", data);
      throw new Error(data?.error?.message || data?.error || `Failed to fetch rune activity: ${response.statusText}`);
  }

  return handleApiResponse<RuneActivityEvent[]>(data, true);
};

// Interface for Price History response
export interface PriceHistoryDataPoint {
  timestamp: number; // Unix timestamp in milliseconds
  price: number;     // Price in USD
}

export interface PriceHistoryResponse {
  slug: string;
  prices: PriceHistoryDataPoint[];
  available: boolean;
}

// Fetch Rune Price History from API
export const fetchRunePriceHistoryFromApi = async (runeName: string): Promise<PriceHistoryResponse> => {
  // Don't send empty requests
  if (!runeName || runeName.trim() === '') {
    return {
      slug: '',
      prices: [],
      available: false
    };
  }

  // Apply direct formatting to specific runes
  let querySlug = runeName;
  
  // Special case for LIQUIDIUMâ€¢TOKEN
  if (runeName.includes('LIQUIDIUM')) {
    querySlug = 'LIQUIDIUMTOKEN';
  }

  const response = await fetch(`/api/rune-price-history?slug=${encodeURIComponent(querySlug)}`);
  let data;
  
  try {
    data = await response.json();
  } catch (error) {
    console.error(`[Client] Failed to parse price history for ${runeName}:`, error);
    throw new Error(`Failed to parse price history for ${runeName}`);
  }

  if (!response.ok) {
    console.error('[Client] API returned error:', data);
    throw new Error(data?.error?.message || data?.error || `Failed to fetch price history: ${response.statusText}`);
  }

  return handleApiResponse<PriceHistoryResponse>(data, false);
};

// Fetch Portfolio Data from API (optimized batch request)
export const fetchPortfolioDataFromApi = async (address: string): Promise<{
  balances: OrdiscanRuneBalance[];
  runeInfos: Record<string, RuneData>;
  marketData: Record<string, OrdiscanRuneMarketInfo>;
}> => {
  if (!address) {
    return { balances: [], runeInfos: {}, marketData: {} };
  }
  
  const response = await fetch(`/api/portfolio-data?address=${encodeURIComponent(address)}`);
  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error(`Failed to parse portfolio data for ${address}`);
  }
  if (!response.ok) {
    throw new Error(data?.error?.message || data?.error || `Failed to fetch portfolio data: ${response.statusText}`);
  }
  return handleApiResponse<{
    balances: OrdiscanRuneBalance[];
    runeInfos: Record<string, RuneData>;
    marketData: Record<string, OrdiscanRuneMarketInfo>;
  }>(data, false);
}; -e 

==============================================================

-e FILE: src/lib/apiUtils.ts

-e ==============================================================

import { NextResponse } from 'next/server';

/**
 * Creates a standardized success response object
 * 
 * @param data - The data to include in the response
 * @param status - HTTP status code (default: 200)
 * @returns NextResponse with standardized format
 */
export function createSuccessResponse<T>(data: T, status = 200): NextResponse {
  return NextResponse.json({
    success: true,
    data,
  }, { status });
}

/**
 * Creates a standardized error response object
 * 
 * @param message - Main error message
 * @param details - Optional detailed error information
 * @param status - HTTP status code (default: 500)
 * @returns NextResponse with standardized format
 */
export function createErrorResponse(message: string, details?: string, status = 500): NextResponse {
  console.error(`[API Error] ${message}${details ? `: ${details}` : ''}`);
  
  return NextResponse.json({
    success: false,
    error: {
      message,
      ...(details && { details }),
    }
  }, { status });
}

/**
 * Processes different error types into a standardized format
 * 
 * @param error - The error object to process
 * @param defaultMessage - Fallback message if error type can't be determined
 * @returns Standardized error object with message and status
 */
export function handleApiError(error: unknown, defaultMessage = 'An error occurred'): { message: string, status: number, details?: string } {
  // For standard Error objects
  if (error instanceof Error) {
    return {
      message: error.message || defaultMessage,
      status: 500,
      details: error.stack,
    };
  }
  
  // For errors with HTTP status (like from external APIs)
  if (error && typeof error === 'object') {
    // Check for status property
    if ('status' in error) {
      const status = (error as { status: number }).status;
      
      // Handle common HTTP status codes
      if (status === 404) {
        return { message: 'Resource not found', status: 404 };
      }
      
      if (status === 400) {
        return { 
          message: 'Bad request', 
          status: 400,
          details: 'response' in error ? JSON.stringify((error as Record<string, unknown>).response) : undefined
        };
      }
      
      return { 
        message: defaultMessage, 
        status: status || 500,
        details: JSON.stringify(error)
      };
    }
    
    // If it has a message property
    if ('message' in error) {
      return {
        message: (error as { message: string }).message || defaultMessage,
        status: 500,
        details: JSON.stringify(error)
      };
    }
  }
  
  // Default case for unknown error types
  return {
    message: defaultMessage,
    status: 500,
    details: typeof error === 'string' ? error : JSON.stringify(error)
  };
} -e 

==============================================================

-e FILE: src/lib/popularRunesCache.ts

-e ==============================================================

import { supabase } from './supabase';

export interface CachedPopularRune {
  id: string;
  name: string;
  imageURI?: string;
  rune: string;
  etching?: {
    runeName?: string;
  };
  icon_content_url_data?: string;
  last_updated_at: string;
}

/**
 * Fetch popular runes from cache
 * @returns Cached popular runes if present and not expired
 */
export async function getCachedPopularRunes(): Promise<Record<string, unknown>[] | null> {
  try {
    // Check for cached popular runes
    const { data, error } = await supabase
      .from('popular_runes_cache')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (error) {
      console.error('[popularRunesCache] Error fetching from cache:', error);
      return null;
    }

    if (!data) {
      return null;
    }

    // Check if the cache is expired (30 days)
    const cacheExpiry = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds
    const cacheDate = new Date(data.created_at).getTime();
    const now = new Date().getTime();
    
    if (now - cacheDate > cacheExpiry) {
      console.log('[popularRunesCache] Cache expired, will fetch fresh data');
      return null;
    }

    return data.runes_data as Record<string, unknown>[];
  } catch (error) {
    console.error('[popularRunesCache] Error in getCachedPopularRunes:', error);
    return null;
  }
}

/**
 * Store popular runes in cache
 * @param runesData The popular runes data to cache
 */
export async function cachePopularRunes(runesData: Record<string, unknown>[]): Promise<void> {
  try {
    const { error } = await supabase
      .from('popular_runes_cache')
      .insert([
        {
          runes_data: runesData,
          created_at: new Date().toISOString()
        }
      ]);

    if (error) {
      console.error('[popularRunesCache] Error storing in cache:', error);
    } else {
      console.log('[popularRunesCache] Successfully cached popular runes data');
    }
  } catch (error) {
    console.error('[popularRunesCache] Error in cachePopularRunes:', error);
  }
} -e 

==============================================================

-e FILE: src/lib/runeMarketData.ts

-e ==============================================================

import { supabase } from './supabase'

export interface RuneMarketData {
  price_in_sats: number
  price_in_usd: number
  market_cap_in_btc: number
  market_cap_in_usd: number
}

export async function getRuneMarketData(runeName: string): Promise<RuneMarketData | null> {
  try {
    const normalizedName = runeName.replace(/â€¢/g, '')
    
    // First, try to get from Supabase
    const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000)
    
    const { data: existingMarketData, error: dbError } = await supabase
      .from('rune_market_data')
      .select('*')
      .eq('rune_name', normalizedName)
      .gt('last_updated_at', tenMinutesAgo.toISOString())
      .single()

    if (dbError) {
      console.error('[DEBUG] Error fetching from DB:', dbError)
    }

    if (existingMarketData) {
      return {
        price_in_sats: existingMarketData.price_in_sats,
        price_in_usd: existingMarketData.price_in_usd,
        market_cap_in_btc: existingMarketData.market_cap_in_btc,
        market_cap_in_usd: existingMarketData.market_cap_in_usd
      }
    }

    // If not in DB or data is stale, fetch from Ordiscan
    const response = await fetch(`${process.env.NEXT_PUBLIC_ORDISCAN_API_URL}/v1/rune/${normalizedName}/market`, {
      headers: {
        'Authorization': `Bearer ${process.env.ORDISCAN_API_KEY || ''}`,
      }
    })

    if (!response.ok) {
      console.error('[DEBUG] Ordiscan API error:', response.status, response.statusText)
      throw new Error(`Ordiscan API error: ${response.statusText}`)
    }

    const responseData = await response.json()
    const { data: marketData } = responseData

    if (!marketData) {
      return null
    }

    // Store in Supabase
    const upsertData = {
      rune_name: normalizedName,
      price_in_sats: marketData.price_in_sats,
      price_in_usd: marketData.price_in_usd,
      market_cap_in_btc: marketData.market_cap_in_btc,
      market_cap_in_usd: marketData.market_cap_in_usd,
      last_updated_at: new Date().toISOString()
    }

    const { error: upsertError } = await supabase
      .from('rune_market_data')
      .upsert(upsertData)

    if (upsertError) {
      console.error('[DEBUG] Error storing market data:', upsertError)
      console.error('[DEBUG] Upsert error details:', {
        code: upsertError.code,
        message: upsertError.message,
        details: upsertError.details,
        hint: upsertError.hint
      })
    }

    return marketData as RuneMarketData
  } catch (error) {
    console.error('[DEBUG] Error in getRuneMarketData:', error)
    return null
  }
} -e 

==============================================================

-e FILE: src/lib/runesData.ts

-e ==============================================================

import { supabase } from './supabase'

export interface RuneData {
  id: string
  name: string
  formatted_name: string | null
  spacers: number | null
  number: number | null
  inscription_id: string | null
  decimals: number | null
  mint_count_cap: string | null
  symbol: string | null
  etching_txid: string | null
  amount_per_mint: string | null
  timestamp_unix: string | null
  premined_supply: string  // Changed to match API response
  mint_start_block: number | null
  mint_end_block: number | null
  current_supply: string | null
  current_mint_count: number | null
}

export async function getRuneData(runeName: string): Promise<RuneData | null> {
  try {
    // First, try to get from Supabase
    const { data: existingRune, error: dbError } = await supabase
      .from('runes')
      .select('*')
      .eq('name', runeName)
      .single()

    if (dbError) {
      console.error('[DEBUG] Error fetching from DB:', dbError)
    }

    if (existingRune) {
      return existingRune as RuneData
    }

    // If not in DB, fetch from Ordiscan
    const response = await fetch(`${process.env.NEXT_PUBLIC_ORDISCAN_API_URL}/v1/rune/${runeName}`, {
      headers: {
        'Authorization': `Bearer ${process.env.ORDISCAN_API_KEY || ''}`,
      }
    })

    if (!response.ok) {
      console.error('[DEBUG] Ordiscan API error:', response.status, response.statusText)
      throw new Error(`Ordiscan API error: ${response.statusText}`)
    }

    const responseData = await response.json()
    const { data: runeData } = responseData

    if (!runeData) {
      return null
    }

    // Store in Supabase - ensure we're using the correct field names
    const dataToInsert = {
      ...runeData,
      last_updated_at: new Date().toISOString()
    }

    const { error: insertError } = await supabase
      .from('runes')
      .insert([dataToInsert])
      .select()

    if (insertError) {
      console.error('[DEBUG] Error storing rune data:', insertError)
      console.error('[DEBUG] Insert error details:', {
        code: insertError.code,
        message: insertError.message,
        details: insertError.details,
        hint: insertError.hint
      })
    }

    return runeData as RuneData
  } catch (error) {
    console.error('[DEBUG] Error in getRuneData:', error)
    return null
  }
}

export async function updateRuneData(runeName: string): Promise<RuneData | null> {
  try {
    const response = await fetch(`${process.env.NEXT_PUBLIC_ORDISCAN_API_URL}/v1/rune/${runeName}`, {
      headers: {
        'Authorization': `Bearer ${process.env.ORDISCAN_API_KEY || ''}`,
      }
    })

    if (!response.ok) {
      console.error('[DEBUG] Ordiscan API error:', response.status, response.statusText)
      throw new Error(`Ordiscan API error: ${response.statusText}`)
    }

    const responseData = await response.json()
    const { data: runeData } = responseData

    if (!runeData) {
      return null
    }

    // Update in Supabase - ensure we're using the correct field names
    const dataToUpdate = {
      ...runeData,
      last_updated_at: new Date().toISOString()
    }

    const { error: updateError } = await supabase
      .from('runes')
      .update(dataToUpdate)
      .eq('name', runeName)
      .select()

    if (updateError) {
      console.error('[DEBUG] Error updating rune data:', updateError)
      console.error('[DEBUG] Update error details:', {
        code: updateError.code,
        message: updateError.message,
        details: updateError.details,
        hint: updateError.hint
      })
    }

    return runeData as RuneData
  } catch (error) {
    console.error('[DEBUG] Error in updateRuneData:', error)
    return null
  }
} -e 

==============================================================

-e FILE: src/lib/serverUtils.ts

-e ==============================================================

/**
 * Server-side utility functions.
 */

import { Ordiscan } from 'ordiscan';
import { SatsTerminal } from 'satsterminal-sdk';

/**
 * Gets an initialized Ordiscan SDK client instance.
 * Requires ORDISCAN_API_KEY environment variable to be set on the server.
 * 
 * @throws Error if ORDISCAN_API_KEY is not set.
 * @returns Initialized Ordiscan client instance.
 */
export function getOrdiscanClient(): Ordiscan {
  const apiKey = process.env.ORDISCAN_API_KEY;

  if (!apiKey) {
    console.error('Ordiscan API key not found. Please set ORDISCAN_API_KEY environment variable on the server.');
    throw new Error('Server configuration error: Missing Ordiscan API Key');
  }

  // Note: The Ordiscan constructor expects the API key directly.
  return new Ordiscan(apiKey);
}

/**
 * Gets an initialized SatsTerminal SDK client instance.
 * Requires SATS_TERMINAL_API_KEY environment variable to be set on the server.
 * 
 * @throws Error if SATS_TERMINAL_API_KEY is not set.
 * @returns Initialized SatsTerminal client instance.
 */
export function getSatsTerminalClient(): SatsTerminal {
  const apiKey = process.env.SATS_TERMINAL_API_KEY;

  if (!apiKey) {
    console.error('SatsTerminal API key not found. Please set SATS_TERMINAL_API_KEY environment variable on the server.');
    throw new Error('Server configuration error: Missing SatsTerminal API Key');
  }

  // Note: The SatsTerminal constructor expects an options object.
  return new SatsTerminal({ apiKey });
} -e 

==============================================================

-e FILE: src/lib/supabase.ts

-e ==============================================================

import { createClient } from '@supabase/supabase-js'

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL')
}
if (!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_ANON_KEY')
}

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  {
    auth: {
      persistSession: true,
    },
  }
) -e 

==============================================================

-e FILE: src/store/runesInfoStore.ts

-e ==============================================================

import { create } from 'zustand';
import { type RuneInfo as OrdiscanRuneInfo } from '@/types/ordiscan';

interface RunesInfoState {
  selectedRuneInfo: OrdiscanRuneInfo | null;
  runeSearchQuery: string;
  setSelectedRuneInfo: (runeInfo: OrdiscanRuneInfo | null) => void;
  setRuneSearchQuery: (query: string) => void;
}

export const useRunesInfoStore = create<RunesInfoState>((set) => ({
  selectedRuneInfo: null,
  runeSearchQuery: '',
  setSelectedRuneInfo: (runeInfo) => set({ selectedRuneInfo: runeInfo }),
  setRuneSearchQuery: (query) => set({ runeSearchQuery: query }),
})); -e 

==============================================================

-e FILE: src/types/common.ts

-e ==============================================================

/**
 * Represents a generic asset, which can be BTC or a Rune.
 */
export interface Asset {
  id: string; // Rune ID or 'BTC'
  name: string; // Rune name or 'BTC'
  imageURI?: string; // URI for the asset image (optional)
  isBTC?: boolean; // Flag to explicitly identify BTC
}

/**
 * Represents Bitcoin (BTC) as a selectable asset.
 */
export const BTC_ASSET: Asset = { id: 'BTC', name: 'BTC', imageURI: '/Bitcoin.svg', isBTC: true }; -e 

==============================================================

-e FILE: src/types/ordiscan.ts

-e ==============================================================

import type { RuneBalance as OrdiscanRuneBalance } from 'ordiscan';

// Re-export the RuneBalance type from the SDK for consistency if needed elsewhere
export type RuneBalance = OrdiscanRuneBalance;

// Define local RuneInfo type based on Ordiscan docs for GET /v1/rune/{name}
export interface RuneInfo {
  id: string;
  name: string;
  formatted_name: string;
  number: number;
  inscription_id: string | null;
  decimals: number;
  symbol: string | null;
  etching_txid: string | null;
  timestamp_unix: string | null;
  premined_supply: string;
  amount_per_mint: string | null;
  mint_count_cap: string | null;
  mint_start_block: number | null;
  mint_end_block: number | null;
  current_supply?: string;
  current_mint_count?: number;
}

// Define market info type based on Ordiscan docs for GET /v1/rune/{name}/market
export interface RuneMarketInfo {
  price_in_sats: number;
  price_in_usd: number;
  market_cap_in_btc: number;
  market_cap_in_usd: number;
}

// --- Types for Address Rune Activity ---
export interface RunestoneMessage {
  rune: string;
  type: 'ETCH' | 'MINT' | 'TRANSFER';
}

export interface RunicInput {
  address: string;
  output: string; // txid:vout
  rune: string;
  rune_amount: string;
}

export interface RunicOutput {
  address: string;
  vout: number;
  rune: string;
  rune_amount: string;
}

export interface RuneActivityEvent {
  txid: string;
  runestone_messages: RunestoneMessage[];
  inputs: RunicInput[];
  outputs: RunicOutput[];
  timestamp: string; // ISO datetime string
} -e 

==============================================================

-e FILE: src/types/satsTerminal.ts

-e ==============================================================

/**
 * Types related to SatsTerminal SDK interactions and API responses.
 */

export interface Rune {
  id: string;
  name: string;
  imageURI?: string;
  formattedAmount?: string;
  formattedUnitPrice?: string;
  price?: number; // This might come from SatsTerminal or be enriched from Ordiscan
}

// Add other SatsTerminal specific types here as needed, e.g.:
// export interface SatsTerminalQuote {
//   ...
// } -e 

==============================================================

-e FILE: src/utils/formatters.ts

-e ==============================================================

// Function to truncate TXIDs for display
export const truncateTxid = (txid: string, length: number = 8): string => {
  if (!txid) return '';
  if (txid.length <= length * 2 + 3) return txid;
  return `${txid.substring(0, length)}...${txid.substring(txid.length - length)}`;
};

// Function to format large number strings with commas
export function formatNumberString(numStr: string | undefined | null, defaultDisplay = 'N/A'): string {
  if (!numStr) return defaultDisplay;
  
  try {
    // Parse the number string
    const num = parseFloat(numStr);
    if (isNaN(num)) return defaultDisplay;
    
    // Format with commas for thousands separator
    return num.toLocaleString();
  } catch (error) {
    console.error("Error formatting number string:", numStr, error);
    return defaultDisplay;
  }
} -e 

==============================================================

-e FILE: src/utils/transactionHelpers.ts

-e ==============================================================

import { 
  RuneActivityEvent, 
  RunestoneMessage, 
  RunicInput, 
  RunicOutput 
} from '@/types/ordiscan';

/**
 * Result of interpreting a Rune transaction
 */
export interface RuneTransactionInterpretation {
  /** The type of action (Minted, Etched, Sent, Received, etc.) */
  action: string;
  /** The name of the Rune involved in the transaction */
  runeName: string;
  /** The raw amount of the Rune involved in the transaction */
  runeAmountRaw: string;
}

/**
 * Interprets a Rune transaction to determine the action, involved Rune and amount
 * 
 * @param tx - The Rune transaction event data
 * @param userAddress - The address of the current user
 * @returns An object containing the interpreted action, Rune name, and amount
 * 
 * @remarks
 * This function handles several transaction types:
 * 
 * 1. Minting or Etching - When a new Rune is created or minted
 * 2. Sending - When the user sends Runes to another address
 * 3. Receiving - When the user receives Runes from another address
 * 4. Internal Transfer - When the user sends Runes to themselves or consolidates UTXOs
 * 5. External Transfer - When the transaction involves Runes but the user is not directly involved
 */
export function interpretRuneTransaction(
  tx: RuneActivityEvent, 
  userAddress: string
): RuneTransactionInterpretation {
  let action = 'Unknown';
  let runeName = 'N/A';
  let runeAmountRaw = 'N/A';

  try {
    // Check for MINT or ETCH message types first
    const mintEtchMessage = tx.runestone_messages.find(
      (m: RunestoneMessage) => m.type === 'MINT' || m.type === 'ETCH'
    );
    
    if (mintEtchMessage) {
      // Case 1: This is a minting or etching transaction
      action = mintEtchMessage.type === 'MINT' ? 'Minted' : 'Etched';
      runeName = mintEtchMessage.rune;
      const userOutput = tx.outputs.find(
        (o: RunicOutput) => o.address === userAddress && o.rune === runeName
      );
      runeAmountRaw = userOutput ? userOutput.rune_amount : 'N/A';
    } else {
      // Determine if user sent or received runes
      const userSent = tx.inputs.some((i: RunicInput) => i.address === userAddress);
      const userReceived = tx.outputs.some((o: RunicOutput) => o.address === userAddress);

      if (userSent && !userReceived) {
        // Case 2: User only sent runes (no change back)
        action = 'Sent';
        const sentInput = tx.inputs.find((i: RunicInput) => i.address === userAddress);
        if (sentInput) {
          runeName = sentInput.rune;
          runeAmountRaw = sentInput.rune_amount;
        }
      } else if (userReceived && !userSent) {
        // Case 3: User only received runes
        action = 'Received';
        const receivedOutput = tx.outputs.find((o: RunicOutput) => o.address === userAddress);
        if (receivedOutput) {
          runeName = receivedOutput.rune;
          runeAmountRaw = receivedOutput.rune_amount;
        }
      } else if (userSent && userReceived) {
        // Case 4: User both sent and received runes
        // This could be sending with change, or an internal transfer/consolidation
        
        // Check if user sent runes to another address
        const sentOutput = tx.outputs.find(
          (o: RunicOutput) => 
            o.address !== userAddress && 
            o.rune && 
            parseFloat(o.rune_amount) > 0
        );

        if (sentOutput) {
          // Found an output sending runes to another address - this is a Send
          action = 'Sent';
          runeName = sentOutput.rune;
          runeAmountRaw = sentOutput.rune_amount;
        } else {
          // No runes sent externally, but user is sender & receiver.
          // This is an Internal Transfer (e.g., UTXO consolidation)
          action = 'Internal Transfer';
          
          // Try to find the relevant rune from the runestone message
          const relevantRune = tx.runestone_messages[0]?.rune;
          const userOutput = tx.outputs.find(
            (o: RunicOutput) => o.address === userAddress && o.rune === relevantRune
          );
          
          if (userOutput) {
            runeName = userOutput.rune;
            runeAmountRaw = userOutput.rune_amount;
          } else {
            // Fallback: Look for any rune output back to the user
            const anyUserOutput = tx.outputs.find(
              (o: RunicOutput) => 
                o.address === userAddress && 
                o.rune && 
                parseFloat(o.rune_amount) > 0
            );
            
            if (anyUserOutput) {
              runeName = anyUserOutput.rune;
              runeAmountRaw = anyUserOutput.rune_amount;
            } else {
              // If still nothing, use input info or default to N/A
              runeName = relevantRune || 
                tx.inputs.find(
                  (i: RunicInput) => i.address === userAddress && i.rune
                )?.rune || 
                'N/A';
              runeAmountRaw = 'N/A'; // Can't reliably determine amount
            }
          }
        }
      } else {
        // Case 5: User was not involved as sender or receiver
        // This might be an external event related to a rune they watch
        action = 'Transfer (External)';
        
        // Try to find any rune involved in the transaction
        runeName = tx.runestone_messages[0]?.rune || 
          tx.inputs.find((i: RunicInput) => i.rune)?.rune || 
          tx.outputs.find((o: RunicOutput) => o.rune)?.rune || 
          'N/A';
        runeAmountRaw = 'N/A'; // Amount for external transfers is ambiguous
      }
    }
  } catch (error) {
    console.error('Error interpreting rune transaction:', error);
    // Default values will be returned
  }

  return { action, runeName, runeAmountRaw };
} 